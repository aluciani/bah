#include "<signal.h>"
#include "<string.h>"

#darwin {
    #include "<mach/mach.h>"
}


#rcp {
	#define RCP_decr(p ptr)
}

#define __BAH_panic(e cpstring, l cpstring)

#define __Bah_safe_string(s cpstring) cpstring

const null = <ptr>0

const true = <bool>1
const false = <bool>0

#define! exit(i int)
#define! strcmp(a cpstring, b cpstring) int
#define! strlen(a cpstring) int
#define! sizeof(p ptr) int

//Compare two cpstrings.
//This function is used by the compiler.
__bah_strcmp(a cpstring, b cpstring) int {
    ai = <int>a
	bi = <int>b
	if ai*bi == 0 {
		return 1
	}
    return strcmp(a, b)
}
 
const strcmp = __bah_strcmp

//Gives the length of a cpstring.
//This is used by the compiler.
__bah_strlen(s cpstring) int {
    if <ptr>s == null {
        return 0
    }
    return strlen(s)
}

const strlen = __bah_strlen

#include "<stdio.h>"
#include "<unistd.h>"
#include "<sys/types.h>"
#include "<sys/stat.h>"
#include "<fcntl.h>"

#define! write(fd FILE*, t cpstring, l int)
#define! read(fd FILE*, t cpstring, l int) int

//Prints text to the terminal.
print(s cpstring) {
    write(<ptr>1, s, strlen(s))
}

#unoptimized {
	#define __BAH_memcpy(dest cpstring, source cpstring, l int)
	const memcpy = __BAH_memcpy
}

#optimized {
	#import "stdopti.bahstrp"
}


#include "memory.bah"

__Bah_realocate_arr(arr []ptr, nLength uint32) {
	if nLength < noCheck(arr->length) {
		return
	}
	if nLength >= noCheck(arr->realLength) {
		if noCheck(arr->realLength) != 0 {
			noCheck(arr->realLength *= 2)
		} else {
			noCheck(arr->realLength = 50)
		}
		newPtr = memoryRealloc(noCheck(arr->data), noCheck(arr->realLength) * noCheck(arr->elemSize))
		noCheck(arr->data = newPtr)
		#rcp {
			RCP_incr(newPtr)
		}
	}
	noCheck(arr->length = arr->length + 1)
	return
}


#define! alloca(s int) ptr
__Bah_multiple_concat(b cpstring*, l uint32) cpstring {
    lens uint32* = alloca(l * sizeof(uint32)) //stack list of lengths
    tot uint32 = 0 //total length
    offset int32 = 0 //offset for concatenation

    //calculate lengths of cpstrings and total length
    i=0; for i < l, i++ {
        sl = strlen(noCheck(b[i]))
        tot += sl
        noCheck(lens[i] = sl)
    }

    //allocate return cpstring
    r = memoryAllocSTR(tot + 1)

    //concatenate all cpstring
    i=0; for i < l, i++ {
        memcpy(<ptr>(<int>r + offset), noCheck(b[i]), noCheck(lens[i]))
        offset += noCheck(lens[i])
    }

    return r
}

#cLib "lm"

#define! signal(sig int, hdl ptr)

#define! strlen(a cpstring) int
#define! strncpy(a cpstring, b cpstring, l int)
#define! strcat(a cpstring, b cpstring)

//Function used by the compiler when concatenating cpstrings.
//You can use it as a function or do cpstring+cpstring.
concatCPSTRING(a cpstring, b cpstring) cpstring {
	lenA = strlen(a)
	lenB = strlen(b)
	r cpstring = memoryAlloc(lenA + lenB + 1)
	strncpy(r,a,lenA)
	strcat(r,b)
	return r
}

//Funcion used by the compiler to declare a cpstring.
//It allocates memory for the cpstring.
__STR(a cpstring) cpstring {
	lenA = strlen(a)
	r cpstring = memoryAllocSTR(lenA+1)
	memcpy(r,a,lenA)
	return r
}

//Converts a bah array to a C array.
cArr(arr ptr) ptr {
	noCheck(array(void*)*a = arr)
	return noCheck(a->data)
}

//Checks if a cpstring is null.
//This was used by the compiler before strcmp and strlen where made safe.
__checkString(s cpstring, l cpstring) bool {

	if <ptr>s == null {
		print("cpstring ("+l+") is null \n")
		exit(1)
	}

	return true
}

#include "channel.bah"
__BAH_panic_chan chan:cpstring = null

//Print an error to the terminal and exits the program.
//Please use panic() instead.
__Bah_common_panic(e cpstring) {
    if strlen(e) {
        print(e)
        print("\n")
		cleanShutDown()
    }
}

const panic = __Bah_common_panic

struct __Bah_fnName_mapper {
	p: ptr
	n: cpstring
}

__Bah_fnNames = []__Bah_fnName_mapper

//Used by the compiler to identify functions in backtrace.
__Bah_fnNames_append(fnn __Bah_fnName_mapper) {
	__Bah_fnNames[len(__Bah_fnNames)] = fnn
}

#linux {
	#define backtrace(arr ptr, l int) int
	#define! readlink(p cpstring, res cpstring, l int) int
}

#define! fgets(r cpstring, l int, f FILE*) cpstring
#define! popen(cmd cpstring, type cpstring) ptr
#define! pclose(hndl FILE*) int

fastExec(s cpstring) cpstring {
    hdl = popen(s, "r")

    buff = buffer 1024
    response = ""
    res ptr = fgets(buff, 1023, hdl)
    for res != null {
        response += buff
        res = fgets(buff, 1023, hdl)
    }

    pclose(hdl)
	return response
}

//Used by the compiler when panic() is called.
__BAH_panic(e cpstring, line cpstring) {
	if __BAH_panic_chan != null {
		e -> __BAH_panic_chan
		return
	}

	print("panic ("+line+"): "+e+"\n")
	
	#linux {
		arr = []ptr
		allocateArray(arr, 10)
		size = backtrace(noCheck(arr->data), 10)

		print("Backtrace:\n")

		min = -1
		max = -1

		selfPath = buffer 4096
		readlink("/proc/self/exe", selfPath, 4096)

		i=1; for i < size, i++ {
			p int = arr[i]
			closest __Bah_fnName_mapper
			dist = -1
			j=0; for j < len(__Bah_fnNames), j++ {
				fnn = __Bah_fnNames[j]
				fnp int = fnn.p
				if fnp < min || min == -1 {
					min = fnp
				}
				if fnp > max || max == -1 {
					max = fnp
				}
				if p > fnp {
					if dist == -1 || p - fnp < dist {
						dist = p - fnp
						closest = fnn
					}
				}
			}
			buff = buffer 2048
			memset(buff, 0, 2048)
			noCheck(sprintf(buff, "addr2line %p -f -i -e %s", p, selfPath))
			s = fastExec(buff)
			name = buffer 255
			path = buffer 2048
			j=0; for s[j] != null, j++ {
				if s[j] == <char>10 {
					name[j] = null
					j++
					break
				}
				name[j] = s[j]
			}

			start = j
			for s[j] != null, j++ {
				if s[j] == <char>10 {
					path[j-start] = null
					break
				}
				path[j-start] = s[j]
			}

			if closest.n == "main" {
				path = "<internal>"
			}
			
			print("\t\033[33m"+<cpstring>name+"\033[m() \033[32m"+<cpstring>path+"\033[m \n")
			// system(buff)
			if closest.n == "main" {
				break
			}
		}
	}

	cleanShutDown()
}

onMemoryError function()cpstring = null

//Used by the compiler, called when a memory error occurs.
__Bah_segfault_handle(sig int) {
	res = ""
	if onMemoryError != null {
		res = onMemoryError()
	}
	__BAH_panic("Memory error (segfault).\n"+res, "???")
}

//Used to register __Bah_segfault_handle().
__Bah_init_segfaultHandle() bool {
	signal(noCheck(SIGSEGV), __Bah_segfault_handle)
	return true
}

__Bah_init_segfaultHandle_OK = __Bah_init_segfaultHandle()


//Used for recovering from a panic instead exitting the program.
//It needs a  pointer to a non null cpstring which will get the message.
recover(s cpstring*) bool {
	__BAH_panic_chan = chan cpstring
	err = <- __BAH_panic_chan
	if s != null {
		*s = err
	}
	return true
}

//Used by the compiler in -verboseRuntime.
//This truncates cpstrings that are too long.
__Bah_safe_string(s cpstring) cpstring {
	if <ptr>s == null {
		return "(nil)"
	}
	if strlen(s) > 50 {
		s = __STR(s)
		a = strAsArr(s)
		a[47] = '.'
		a[48] = '.'
		a[49] = '.'
		a[50] = <char>0
	}

	return "\""+s+"\""
}


//Used for getting a character by its index inside a cpstring.
//Used cpstring[i] instead.
cpstringCharAt(s cpstring, i int) char {
    c = <char>0
    noCheck(c = s[i])
    return c
}

//Used by the compiler for operations like cpstring[start:end].
cpstringSubsitute(s cpstring, i int, l int) cpstring {
	size = l - i
	ns = memoryAllocSTR(size+1)
	memcpy(ns, noCheck(s+i), size)
	return ns
}

//Used by the compiler for operations like array[start:end].
arraySubstitute(arr []ptr, i int, l int) ptr {
	length = l - i
	offset int = i * noCheck(arr->elemSize)
	na = []ptr
	noCheck(na->elemSize = arr->elemSize)
	noCheck(na->length = length)

	allocLength = length
	if length > 50 {
		allocLength += allocLength % 50
	} else {
		allocLength = 50
	}
	size = allocLength * noCheck(arr->elemSize)
	realSize = length * noCheck(arr->elemSize)
	data = memoryAlloc(size)
	oData cpstring = noCheck(arr->data)
	memcpy(data, noCheck(oData + offset), realSize)
	noCheck(na->data = data)
	return na
}

#include "map.bah"