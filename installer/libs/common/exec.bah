#include "iostream.bah"
#include "string.bah"
#include "rope.bah"

#define! popen(cmd cpstring, type cpstring) FILE*
#define! pclose(hndl FILE*) int
#define! fileno(f FILE*) int

//A wrapper for executting command.
//This is will return the output of the command.
//If you dont want stderr, set `.error = false`.
//The exit status code of the executed command is stored in `.status`.
struct command {
    command: cpstring
    error: bool = true
    status: int = 0
    input: cpstring = null

    handle: FILE*

    //To run the command.
    //This returns a cpstring containning the output of the command.
    run() cpstring {
        cm = this.command
        if this.error == false {
            cm = cm + " 2>/dev/null"
        } else {
            cm = cm + " 2>&1"
        }
        this.handle = popen(cm, "w")
        if this.handle == null {
            return ""
        }
        if this.input != null {
            fputs(this.input, <ptr>this.handle)
        }
        buff cpstring = memoryAlloc(1025)
        res = ""
        for <ptr>fgets(buff, 1024, this.handle) != null {
            res = res + buff
        }
        this.status = pclose(this.handle)
        return res
    }

    runBytes() []char {
        arr = []char
        cm = this.command
        if this.error == false {
            cm = cm + " 2>/dev/null"
        } else {
            cm = cm + " 2>&1"
        }
        this.handle = popen(cm, "r")
        if this.handle == null {
            return arr
        }
        
        total = 0
        fd = fileno(this.handle)

        buff cpstring = memoryAlloc(1024)

        response = ""
        res ptr = fgets(buff, 1023, this.handle)
        for res != null {
            response += buff
            res = fgets(buff, 1023, this.handle)
        }

        this.status = pclose(this.handle)
        noCheck(arr->data = response)
        noCheck(arr->length = strlen(response))
        return arr
    }

}

//To initiate a command.
//You must specify the command as a cpstring.
command(s cpstring) command {
    cmd = command{}
    cmd.command = s
    return cmd
}

#define! execvp(cmd cpstring, args ptr) int

//Exec will execute a binary/command with the specified arguments passed to it.
//Note that this will take the current proccess.
exec(s cpstring, args []cpstring) int {
    r int
    nArgs = []cpstring
    nArgs[0] = s
    i=0;for i < len(args) {
        nArgs[i+1] = args[i]
        i = i + 1
    }
    nArgs[i+2] = <cpstring>0
    noCheck(r = execvp(s, nArgs->data))
    return r
}
