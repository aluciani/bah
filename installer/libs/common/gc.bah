
#linux {
    #include "<gc.h>"
    #cLib "lgc" "lpthread"
}

#darwin {
    #include "<gc.h>"
    #cLib "lgc" "lpthread"
}

#windows {
    #include "<gc.h>"
    #cLib "l:gc.a" "lpthread"
}

#define! GC_INIT()
#define! GC_MALLOC(s int) ptr
#define! GC_REALLOC(p ptr, s int) ptr
#define! GC_FREE(a ptr)
#define! GC_REGISTER_FINALIZER_IGNORE_SELF(obj ptr, proc ptr, data ptr, ofn ptr, ocd ptr)


//Used for allocating memory (malloc in c). You must specify the size of the block to allocate.
//Will return a pointer to the allocated block. The memory is garbage collected.
//**The given memory is initiated with zeros.**
//The allocated memory cannot be shared by multiple processes. Use the sharedMemory() function instead.
memoryAlloc(s int) ptr {
    return GC_MALLOC(s)
}

//Destroy will force to free a pointer.
destroy(a ptr) {
    GC_FREE(a)
}

//Clear will remove the content of an array.
clear(a ptr) {
    noCheck(array(void*) * arr = a)
    memset(noCheck(arr->data), null, noCheck(arr->realLength * arr->elemSize))
    noCheck(arr->length = 0)
}


//Will realloc memory to a specified pointer.
//*The data contained in the block of memory is not necessarly preserved.*
memoryRealloc(p ptr, s int) ptr {
    return GC_REALLOC(p,s)
}

cleanShutDown() {
    exit(1)
    return
}

memoryOnEnd(obj ptr, fn ptr) {
    GC_REGISTER_FINALIZER_IGNORE_SELF(obj, fn, null, null, null)
}

__BAH_memcpy(dest cpstring, source cpstring, l int) {
    lm = l % sizeof(int)
    if lm != 0 {
        for lm != 0, lm-- {
            i = l - lm
            noCheck(dest[i] = source[i])
        }
    }
    destI int* = <ptr>(<int>dest - sizeof(int))
    sourceI int* = <ptr>(<int>source - sizeof(int))
    i=l/sizeof(int); for i != 0, i-- {
        noCheck(destI[i] = sourceI[i])
    }
}
