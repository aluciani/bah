
#linux {
    #include "<gc.h>"
    #cLib "lgc" "lpthread"
}

#darwin {
    #include "<gc.h>"
    #cLib "lgc" "lpthread"
}

#windows {
    #include "<gc.h>"
    #cLib "l:gc.a" "lpthread"
}

#define! GC_INIT()
#define! GC_MALLOC(s int) ptr
#define! GC_REALLOC(p ptr, s int) ptr
#define! GC_FREE(a ptr)
#define! GC_REGISTER_FINALIZER_IGNORE_SELF(obj ptr, proc ptr, data ptr, ofn ptr, ocd ptr)
#define! GC_malloc_atomic(s int) ptr


//Used for allocating memory (malloc in c). You must specify the size of the block to allocate.
//Will return a pointer to the allocated block. The memory is garbage collected.
//**The given memory is initiated with zeros.**
//The allocated memory cannot be shared by multiple processes. Use the sharedMemory() function instead.
memoryAlloc(s int) ptr {
    return GC_MALLOC(s)
}

//Destroy will force to free a pointer.
destroy(a ptr) {
    GC_FREE(a)
}

//Clear will remove the content of an array.
clear(a ptr) {
    noCheck(array(void*) * arr = a)
    memset(noCheck(arr->data), null, noCheck(arr->realLength * arr->elemSize))
    noCheck(arr->length = 0)
}


//Will realloc memory to a specified pointer.
memoryRealloc(p ptr, s int) ptr {
    return GC_REALLOC(p,s)
}

//Shuts down the program.
cleanShutDown() {
    exit(1)
    return
}

//Used for setting an end of line registerer to an allocated pointer.
memoryOnEnd(obj ptr, fn ptr) {
    GC_REGISTER_FINALIZER_IGNORE_SELF(obj, fn, null, null, null)
}

//The Bah version of memcpy.
//This will copy l bytes from the source to the end.
//A faster version is available with -optimize.
//This is called when calling memcpy().
__BAH_memcpy(dest cpstring, source cpstring, l int) {
    lm = l % sizeof(int)
    if lm != 0 {
        for lm != 0, lm-- {
            i = l - lm
            noCheck(dest[i] = source[i])
        }
    }
    destI int* = <ptr>(<int>dest - sizeof(int))
    sourceI int* = <ptr>(<int>source - sizeof(int))
    i=l/sizeof(int); for i != 0, i-- {
        noCheck(destI[i] = sourceI[i])
    }
}

//Used for allocating memory for a cpstring.
//The content of the memory block should not contain any pointer.
//It will not be checked for memory collection.
memoryAllocSTR(s int) cpstring {
    r cpstring = memoryAlloc(s + cpstringLenSize)
    ln uint32* = r
    *ln = (s-1)
    noCheck(r[s-1] = 0)
    // memset(r, 0, s)
    return r
}