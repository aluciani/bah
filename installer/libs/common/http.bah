#include "cBinds.bah"

#include "iostream.bah"
#include "string.bah"
#include "exec.bah"
#include "thread.bah"

#include "<unistd.h>"
#include "<signal.h>"

#linux {
    #include "<sys/types.h>"
    #include "<sys/socket.h>"
    #include "<sys/ioctl.h>"
    #include "<arpa/inet.h>"
    #include "<netinet/in.h>"
    #include "<netdb.h>"
    #include "<openssl/ssl.h>"
    #include "<openssl/err.h>"
    #include "<openssl/bio.h>"
    #include "<sys/select.h>"
    #include "<sys/time.h>"
    #include "<poll.h>"
    #include "<net/if.h>"
}

#windows {
    #include "<windows.h>"
    #include "<winsock2.h>"
    #include "<openssl/ssl.h>"
    #include "<openssl/err.h>"
    #include "<openssl/bio.h>"

    //#warning "Don't forget to copy the ssleay32.dll and libeay32.dll in your application path."
}



//sockets

#define! socklen_t uint
#define! pid_t int
#define! sigset_t int32

__httpDNSmutex = mutex()

struct! in_addr {
    s_addr: char
}


struct! hostent {
    h_name: cpstring
    h_aliases: cpstring
    h_addrtype: int
    h_length: int
    h_addr: uint*
    h_addr_list: cpstring*
}

struct! sigaction {
    sa_handler: ptr
    sa_sigation: ptr
    sa_mask: sigset_t
    sa_flags: int32
    sa_restorer: ptr
}

struct! sockaddr_in {
    sin_family: int
    sin_port: uint
    sin_addr: in_addr
    // sin_zero: char*
}

struct! addrinfo {
    ai_flags: int
    ai_family: int
    ai_socktype: int
    ai_protocol: int
    ai_addrlen: int
    ai_addr: sockaddr_in*
    ai_canonname: cpstring
    ai_next: addrinfo*
}

struct! timeval {
    tv_sec: int
    tv_usec: int
}

#define! fd_set ptr

#define! inet_ntoa(addr in_addr) cpstring
#define! inet_addr(a cpstring) in_addr

#define! socket(a int, b int, c int) int
#define! gethostbyname(h cpstring) hostent*
#define! htons(p int) uint
#define! connect(sockfd int, ser_addr sockaddr_in*, s int) int
#define! send(sockfd int, msg cpstring, msglen int, c int) int
#define! recv(sockfd int, buff cpstring, bufflen int, c int) int
#define! close(sockfd int) int
#define! htonl(inaddrt int) char
#define! bind(sockfd int, ser_addr sockaddr_in*, s int) int
#define! listen(sockfd int, s int) int
#define! memset(str ptr, w int, s int)
#define! accept(sockfd int, cliaddr sockaddr_in*, clilen int*) int
#define! shutdown(fd int, flags int) int
#define! setsockopt(fd int, w int, flag int, val ptr, flagSize int) int
#define! getsockopt(fd int, t int, w int, e ptr, el int*) int
#define! fcntl(fd int, oper int, flag int) int
#define! FD_ZERO(s ptr)
#define! FD_SET(sock int, s ptr)
#define! FD_ISSET(sock int, s ptr) int
#define! select(sock int, ws ptr, rs ptr, ex ptr, timeout timeval*) int
#define! ioctl(sock int, f int, v int*) int
#define! getaddrinfo(host cpstring, port cpstring, hints addrinfo*, addrs addrinfo**) int
#define! freeaddrinfo(addr addrinfo*)

struct! pollfd {
    fd: int
    events: int
    revents: int
}

#define! poll(fds pollfd*, nfd int, timeout int) int


struct! ifreq {
    ifr_name: cpstring
}

#define! snprintf(s cpstring, s int, format cpstring)

#windows {
    #define! WSADATA ptr
    #define! MAKEWORD(a int, b int) ptr
    #define! WSAStartup(w ptr, d WSADATA*) int
    #define! closesocket(sockfd int)
    #define! hostname_to_ip(host cpstring, ip cpstring)

    __Bah_win32_WSA_init() bool {
        wsadata WSADATA
        WSAStartup(MAKEWORD(1,1), &wsadata)
        return true
    }

    __Bah_win32_WSA_is_init = __Bah_win32_WSA_init()
}

struct response_buffer {
    data: cpstring
    len: int

    str() cpstring {
        return this.data
    }

    arr() []char {
        a = []char
        noCheck(a->data = this.data)
        noCheck(a->length = this.len)
        return a
    }

    append(buff cpstring, s int) {
        this.data = memoryRealloc(this.data, this.len + s)
        memcpy(noCheck(this.data + this.len), buff, s)
        this.len = this.len + s
    }

}

struct http_socket {
    sockfd: int = -1
    timeout: int = 0

    //To check if a socket is opened.
    isOpened() bool {
        return this.sockfd > 0
    }

    //To open a socket.
    //If a socket is opened, it must be closed.
    open() bool {
        this.sockfd = socket(2, 1, 0)
        if this.isOpened() {
            optVal = 1
            setsockopt(this.sockfd, noCheck(SOL_SOCKET), noCheck(SO_REUSEADDR), &optVal, SIZE_OF_INT)
            return true
        }
        return false
    }

    //To set the linux network interface on which the socket should operate.
    setInterface(s cpstring) bool {
        #linux {
            ifr ifreq
            memset(&ifr, 0, noCheck(sizeof(ifr)))
            snprintf(ifr.ifr_name, noCheck(sizeof(ifr.ifr_name)), s)
            return setsockopt(this.sockfd, noCheck(SOL_SOCKET), noCheck(SO_BINDTODEVICE), &ifr, noCheck(sizeof(ifr))) == 0
        }
        #windows {
            return false
        }
    }

    //To terminate a socket.
    terminate() bool {
        #linux {
            return shutdown(this.sockfd, noCheck(SHUT_RDWR)) != -1
        }
        #windows {
            return false
        }
    }

    //To close a socket.
    close() bool {
        if this.sockfd < 0 {
            return true
        }

        #linux {
            flags = fcntl(this.sockfd, noCheck(F_GETFL), 0)
            fcntl(this.sockfd, noCheck(F_SETFL), noCheck(flags | FD_CLOEXEC))
            err = 0
            errlen = SIZE_OF_INT
            getsockopt(this.sockfd, noCheck(SOL_SOCKET), noCheck(SO_ERROR), &err, &errlen)
            r = true
            if this.terminate() == false {
                r = close(this.sockfd) != -1
            }
        }
        #windows {
            closesocket(this.sockfd)
            r = true
        }

        this.sockfd = -1
        return r
    }

    //To reach a host by port.
    //Used for making requests.
    reach(host cpstring, port int) bool {
        if <ptr>host == null {
            return false
        }
        #linux {
            addrsup = addrinfo{}
            hints = addrinfo{}
            hints.ai_family = noCheck(AF_INET)
            hints.ai_socktype = noCheck(SOCK_STREAM)
            hints.ai_protocol = noCheck(IPPROTO_TCP)

            addrs = &addrsup

            err = getaddrinfo(host, intToStr(port), &hints, &addrs)
            if err != 0 {
                return false
            }

            res = -1
            if this.timeout > 0 {
                iMode = 1
                ioctl(this.sockfd, noCheck(FIONBIO), &iMode)
                if connect(this.sockfd, addrs.ai_addr, addrs.ai_addrlen) == 0 {
                    freeaddrinfo(addrs)
                    return false
                }
                iMode = 0
                ioctl(this.sockfd, noCheck(FIONBIO), &iMode)
                
                pfd = pollfd{}
                pfd.fd = this.sockfd
                pfd.events = noCheck(POLLOUT)


                res = poll(&pfd, 1, this.timeout * 1000)
                if res <= 0 {
                    freeaddrinfo(addrs)
                    return false
                }

                return true
            } else {
                res = connect(this.sockfd,addrs.ai_addr, addrs.ai_addrlen)
            }

            if res <= 0 {
            freeaddrinfo(addrs)
                return false
            }
            freeaddrinfo(addrs)
        }
        #windows {
            ip cpstring = memoryAlloc(20)
            server = sockaddr_in{}
            server.sin_family = noCheck(AF_INET)
            server.sin_port = htons(port)
            __httpDNSmutex.lock()
            he = gethostbyname(host)
            if he == null {
                __httpDNSmutex.unlock()
                addr = he.h_addr
                server.sin_addr.s_addr = <char>*addr
                return false
            }

            __httpDNSmutex.unlock()

            return connect(this.sockfd, &server, noCheck(sizeof(server))) >= 0
        }
        return true
    }

    //To listen on a specific port.
    listen(port int) bool {
        //binding
        servaddr sockaddr_in
        servaddr.sin_family = 2
        saddr = in_addr{}
        saddr.s_addr = htonl(0)
        servaddr.sin_addr = saddr
        servaddr.sin_port = htons(port)
        if bind(this.sockfd, &servaddr, 16) == -1 {
            return false
        }
        //listenning
        if listen(this.sockfd,1024) < 0 {
            return false
        }
        optVal = 1
        return true
    }

    //To accept a connection after listenning.
    accept() int {
        cliaddr sockaddr_in
        clilen = 16
        return  accept(this.sockfd, &cliaddr, &clilen)
    }

    //To send data through the socket.
    send(s cpstring) bool {
        if this.isOpened() == false {
            return false
        }
        return send(this.sockfd, s, strlen(s), 0) > 0
    }

    //To send data as bytes through the socket.
    sendBytes(bytes []char) bool {
        if this.isOpened() == false {
            return false
        }
        return send(this.sockfd, arrAsStr(bytes), len(bytes), 0) > 0
    }

    receiveBuff() response_buffer {
        buff cpstring = memoryAlloc(1025)
        rep = response_buffer{}

        #linux {
            iMode = 0
            ioctl(this.sockfd, noCheck(FIONBIO), &iMode)
            nDataLength = recv(this.sockfd,buff,1024,0)
            if nDataLength == -1 {
                return rep
            }
            rep.append(buff, nDataLength)
            iMode = 1
            ioctl(this.sockfd, noCheck(FIONBIO), &iMode)
        }

        for 1 == 1 {
            nDataLength = recv(this.sockfd,buff,1024,0)
            if nDataLength <= 0 {
                break
            }
            rep.append(buff, nDataLength)
        }
        return rep
    }

    //To receive data through the socket.
    receive() cpstring {
        r = this.receiveBuff()
        return r.str()
    }

    //To receive data as bytes through the socket.
    receiveBytes() []char {
        r = this.receiveBuff()
        return r.arr()
    }

}

//To check if a socket is opened.
isSocket(s http_socket) bool {
    return s.sockfd > 0
}


struct http_url {
    path: string
    host: string
    proto: string
    port: string
}



//Used for parsing an URL.
parseUrl(cps cpstring) http_url* {
    u = new http_url
    s = string(cps)
    
    //get protocol
    i = 0
    max = s.length - 1
    hasProto = 0
    for i<s.length {
        c = s.charAt(i)
        if c == ':' {
            hasProto = 1
            break
        }
        i = i + 1
    }
    if hasProto == 1 {
    proto = string("")
    i = 0
    for s.charAt(i) != ':' {
        c = s.charAt(i)
        proto.append(charToString(c))       
        i = i + 1
    }
    i = i + 1
    u.proto = proto
    } else {
        u.proto = string("http")
        i = 0
    }
    for s.charAt(i) == '/' {
        if i == max {
            break
        }
        i = i + 1
    }

    //get host
    hn = string("")
    for s.charAt(i) != '/' && s.charAt(i) != ':' {
        c = s.charAt(i)
        hn.append(charToString(c))
        if i == max {
            break
        }
        i = i + 1
    }
    u.host = hn


    if i == max {
        u.path = string("/")
        if u.proto.compare("https") {
            u.port = string("443")
        } else {
            u.port = string("80")
        }
        return u
    }
    
    port = string("")
    if s.charAt(i) == ':' {
        i = i + 1
        for i < s.length {
            c = s.charAt(i)
            if c == '/' {
                break
            }
            port.append(charToString(c))
            i = i + 1
        }
    }
    u.port = port

    if i == max {
        u.path = string("/")
        if u.proto.compare("https") {
            u.port = string("443")
        } else {
            u.port = string("80")
        }
        return u
    }

    path = string("")
    for i<=max {
        c = s.charAt(i)
        path.append(charToString(c))
        i = i + 1
    }
    u.path = path

    return u
}

__HTTP_urlSafeChars = []char{
    '.',
    '!'
}

//Used for encoding a string to a safe url format.
//Encoded strings can be used as url parameter without being interpreted as path.
urlEncode(s cpstring) cpstring {
    a = strAsArr(s)
    r = []char
    tmps cpstring = memoryAlloc(4)

    i=0; for i < len(a), i++ {
        c = a[i]
        if isAlphaNumeric(c) || c in __HTTP_urlSafeChars {
            r[len(r)] = c
        } else {
            r[len(r)] = '%'
            sprintf(tmps, "%x", c)
            n = strAsArr(tmps)
            j=0; for j < len(n), j++ {
                r[len(r)] = n[j]
            }
            
        }
    }

    r[len(r)] = <char>0

    return arrAsStr(r)
}

//Used for decoding an url encoded string.
urlDecode(encoded cpstring) cpstring {
    s = strAsArr(encoded)
    r = []char

    i=0; for i < len(s) {
        c = s[i]
        if c == '+' {
            r[len(r)] = ' '
        } else if c == '%' {
            hexStr = []char{s[i+1], s[i+2]}
            c = <char>strtol(arrAsStr(hexStr), null, 16)
            r[len(r)] = c
            i = i + 2

        } else {
            r[len(r)] = c
        }
        i = i + 1
    }

    return arrToStr(r)
}



//web server

#linux {
    sigchld_handler(signo int) {
        status int
        pid int
        pid = waitpid(-1, &status, 1)
        for pid > 0 {
            pid = waitpid(-1, &status, 1)
        }
    }
}

#define __Bah_http_handle_client(s ptr, cli int)

//A type difinning http server erros.
#define http_serverError int

const HTTP_SERVER_NO_ERROR = <http_serverError>0
const HTTP_SERVER_SOCKET_ERROR = <http_serverError>1
const HTTP_SERVER_BIND_ERROR = <http_serverError>2
const HTTP_SERVER_LISTEN_ERROR = <http_serverError>3

globalHTTPsockets = []http_socket

http_quit_handler(signo int) {
    i=0; for i < len(globalHTTPsockets), i++ {
        s = globalHTTPsockets[i]
        s.close()
    }
    exit(0)
}

http_broken_pipe(signo int) {
    println("http: warning, trying to send data to a closed socket.")
}

//A wrapper for a http web server.
struct http_server {
    port: int
    running: int = 1
    socket: http_socket
    error: http_serverError = HTTP_SERVER_NO_ERROR

    linux_interface: cpstring = ""

    //Event lisstener for when receiving connections.
    handle: function(http_server*, int)
    
    //Event listener for when server started successfully.
    done: function(http_server*)

    //To stop the server.
    stop() {
        if this.socket.isOpened() == false {
            println("cannot stop http_server, not running")
            return
        }
        this.running = 0
        this.socket.close()
    }



    //To start the server.
    listenAndServe() {
        this.error = HTTP_SERVER_NO_ERROR
        this.socket = http_socket{}

        this.socket.open()

        if strlen(this.linux_interface) > 0 && this.socket.setInterface(this.linux_interface) == false {
            panic("http: error setting server's linux interface")
        } 


        if this.socket.isOpened() == false {
            println("http: error opening socket")
            this.error = HTTP_SERVER_SOCKET_ERROR
            return
        }

        if this.socket.listen(this.port) == false {
            this.socket.close()
            println("http: failed to start listening")
            this.error = HTTP_SERVER_LISTEN_ERROR
            return
        }

        globalHTTPsockets[len(globalHTTPsockets)] = this.socket

        #linux {
            sa sigaction
            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = sigchld_handler
            sigaction(17, &sa, 0)

            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = http_quit_handler
            sigaction(2, &sa, 0)    

            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = http_broken_pipe
            sigaction(noCheck(SIGPIPE), &sa, 0)        
        }




        if this.done != null {
            async this.done()
        }

        for this.running == 1 {
            cli = this.socket.accept()

            if cli <= 0 {
                continue
            }


            #windows {
                async __Bah_http_handle_client(this, cli)
            }

            #linux {
                async __Bah_http_handle_client(this, cli)
                // childpid = fork()
                // if childpid < 0 {
                //     println("http: failed to fork client handler")
                //     close(cli)
                //     continue
                // }

                // if childpid == 0 {
                //     this.handle(cli)
                //     close(cli)
                //     exit(0)
                // }
                // close(cli)

            }


        }

        this.stop()

    }

}

#windows {
    __Bah_http_handle_client(sp ptr, cli int) {
        s http_server* = sp
        s.handle(cli)
        closesocket(cli)
    }
}

#linux {
    __Bah_http_handle_client(sp ptr, cli int) {
        s http_server* = sp
        s.handle(cli)
        close(cli)
    }
}

//To send a cpstring through the specified socket.
http_send(connfd int, s cpstring) {
    send(connfd, s, strlen(s), 0)
}

//To receive from a specified socket.
http_receive(connfd int) cpstring {
    buff cpstring = memoryAlloc(1025)
    response = string("")
    nDataLength = recv(connfd,buff,1024,0)
    if nDataLength < 1024 {
        response.append(buff)
    } else {
        for nDataLength > 0 {
            response.append(buff)
            if nDataLength < 1024 {
                trimAmm = 1024 - nDataLength
                response.trimRight(trimAmm)
                break
            } else {
                nDataLength = recv(connfd,buff,1024,0)
            }
        }
    }
    return response.str()
}


//HTTP code 200 means everything is ok
const HTTP_OK = 200
//HTTP code 404 means file not found
const HTTP_NOT_FOUND = 404
//HTTP code 400 means that you deny access to this request
const HTTP_FORBIDDEN = 400
//HTTP code 500 means that the server encountered an internal error
const HTTP_ERROR = 500
//HTTP code 301 means a permanent redirection
const HTTP_REDIRECT = 301
//HTTP code 206 means content can be seeked up in a range
const HTTP_PARTIAL_CONTENT = 206



struct http_transport {
    socket: http_socket
    headers: []string*
    code: int = HTTP_OK
    body: string*
    file: []char
    url: http_url*
    method: cpstring = ""
    path: cpstring = ""

        //To set a header by name.
    setHeader(name cpstring, value cpstring) {
        
        h = new string
        ln = toLower(string(name))
        h.set(ln.str())
        h.append(": ")
        h.append(value)

        lhs = len(this.headers)
        this.headers[lhs] = h
    }

    //To get the value of a header by name.
    getHeader(name cpstring) cpstring {
        headerName = string(name)
        headerName = toLower(headerName)
        headerName.append(":")
        i=0;for i < len(this.headers) {
            currentHeader = this.headers[i]
            if currentHeader.hasPrefix(headerName.str()) {
                header = string(currentHeader.str())
                space = 0
                c = header.charAt(headerName.length)
                if isSpace(c) {
                    space = 1
                }
                header.trimLeft(headerName.length+space)
                return header.str()
            }
            i=i+1
        }

        return ""

    }

    //To append to the body of the response.
    write(content cpstring) {
        body = this.body
        body.append(content)
    }

}


//A wrapper for HTTP responses. You will be able to set/retreive the headers sent/receive.
//You will encounter this when doing a request or sending a response to the client.
struct http_response extend http_transport {
    headersSent: bool = false
    //Send the response.
    //*Use it only when sending response to the client from a http_server*.
    send() {
        if this.headersSent == false {
            s = string("HTTP/1.0 ")
            if this.code == HTTP_OK {
                s.append("200 OK")
            } else if this.code == HTTP_NOT_FOUND {
                s.append("404 Not Found")
            } else if this.code == HTTP_FORBIDDEN {
                s.append("400 Bad Request")
            } else if this.code == HTTP_ERROR {
                s.append("500 Internal Server Error")
            } else if this.code == HTTP_REDIRECT {
                s.append("301 Moved Permanently")
            } else if this.code == HTTP_PARTIAL_CONTENT {
                s.append("206 Partial Content")
            } else {
                s.append(intToStr(this.code))
            }
            s.append("\r\n")
            
            i = 0
            
            for i < len(this.headers) {
                e = this.headers[i]
                s.append(e.str())
                s.append("\r\n")
                i = i + 1
            }
            
            s.append("\r\n")

            
            s.append(this.body.str())
            this.body.set("")
            if this.socket.send(s.str()) == false {
                this.socket.close()
            }
            headersSent = true
        } else {
            if this.socket.send(this.body.str()) == false {
                this.socket.close()
            }
            this.body.set("")
        }

    }

    //Used for flushing content rather than sending it fully.
    //Useful for sending large files, websockets, SSE, etc...
    flush(bytes []char) bool {
        if this.socket.sendBytes(bytes) == false {
            this.socket.close()
            return false
        }
        return true
    }

}

//To build a HTTP response.
//You will need to populate it before sending it to the client.
http_response(connfd int) http_response {
    resp = http_response{}
    resp.socket = http_socket{}
    resp.socket.sockfd = connfd

    resp.setHeader("Server", "bah-http-framework")
    resp.setHeader("Connection", "close")

    body = new string
    body.set("")
    resp.body = body

    return resp
}

makeRespFromBody(response response_buffer) http_response* {
    if response.len == 0 {
        return null
    }

    resp = new http_response
    resp.file = []char
    resp.body = new string

    arr = response.arr()

    tmp = []char

    //HTTP version
    i=0; for i < len(arr), i++ {
        c = arr[i]
        if c == ' ' {
            tmp[i] = null
            i++
            break
        }
        tmp[i] = c
    }
    if strHasPrefix(arrAsStr(tmp), "HTTP/") == false {
        return null
    }

    //HTTP code
    offset = i
    for i < len(arr), i++ {
        c = arr[i]
        if c == ' ' {
            tmp[i - offset] = null
            i++
            break
        }
        tmp[i - offset] = c
    }
    resp.code = strToInt(arrAsStr(tmp))

    //Skip Text version of the code
    for i < len(arr), i++ {
        if arr[i-1] == <char>13 && arr[i] == <char>10 {
            i++
            break
        }
    }

    //Headers
    for i < len(arr), i++ {
        
        headerName = []char
        headerCont = []char
        //Read header name until ':'
        for i < len(arr), i++ {
            c = arr[i]
            if c == ':' {
                i++
                break
            }
            headerName[len(headerName)] = c
        }

        //Read header content until "\r\n"
        for i < len(arr), i++ {
            c = arr[i]
            if c == <char>13 {
                if i+1 < len(arr) {
                    if arr[i+1] == <char>10 {
                        i = i + 2
                        break
                    }
                }
            }
            headerCont[len(headerCont)] = c
        }

        headerName[len(headerName)] = null
        headerCont[len(headerCont)] = null
        resp.setHeader(arrAsStr(headerName), arrAsStr(headerCont))

        //If "\r\n", end of headers, beggining of body
        if arr[i] == <char>13 {
            if i+1 < len(arr) {
                if arr[i+1] == <char>10 {
                    i = i + 2
                    break
                }
            }
        }
    }

    //Reading body to file array
    offset = i
    for i < len(arr), i++ {
        resp.file[i-offset] = arr[i]
    }

    //Setting body to content of file array + null character.
    resp.body.set(arrToStr(resp.file))

    return resp
}



//making requests

//SSL - TLS (https)

#cLib "lssl" "lcrypto"

#windows {
    #cLib "lws2_32"
}

// #linux {
//     #cLib "w /opt/bah/libs/libssl.a" "w /opt/bah/libs/libcrypto.a"
// }

#define! BIO int
#define! SSL int
#define! SSL_CTX int

#define! SSL_library_init()
#define! SSLv23_client_method() int
#define! SSL_CTX_new(m int) SSL_CTX*
#define! BIO_new_ssl_connect(ctx SSL_CTX*) BIO*
#define! BIO_set_conn_hostname(bio BIO*, h cpstring)
#define! BIO_do_connect(bio BIO*) int
#define! BIO_write(bio BIO*, cont cpstring, size int) int
#define! BIO_should_retry(bio BIO*) int
#define! BIO_read(bio BIO*, buff cpstring, size int) int
#define! BIO_free_all(bio BIO*)
#define! SSL_CTX_free(ctx SSL_CTX*)
#define! SSL_CTX_set_timeout(ctx SSL_CTX*, t int) int
#define! BIO_get_ssl(bio BIO*, ssl SSL**)
#define! SSL_set_mode(ssl SSL*, mode int)

//Used for making TLS requests.
//*This is an internal function, you should know what you're doing if you decide to use it.*
makeRawHttpsRequest(host cpstring, message cpstring, timeout int) response_buffer {
    
    SSL_library_init()
    ssl SSL*
    ctx = SSL_CTX_new(SSLv23_client_method())
    if timeout > 0 {
        SSL_CTX_set_timeout(ctx, timeout)
    }

    resp = response_buffer{}
    if ctx == null {
        println("http: cannot initialize ssl context")
        return resp
    }

    bio = BIO_new_ssl_connect(ctx)

    BIO_get_ssl(bio, &ssl)
    SSL_set_mode(ssl, 4)

    BIO_set_conn_hostname(bio, host)
    if BIO_do_connect(bio) <= 0 {
        println("http: error connecting through ssl to '"+host+"'")
        return resp
    }
    success = BIO_write(bio, message, strlen(message))

    if success <= 0 {
        if BIO_should_retry(bio) == 0 {
            println("http: failed sending request")
            return resp
        }
    }

    buff cpstring = memoryAlloc(1025)
    for true == true {
        size = BIO_read(bio, buff, 1025)
        if size <= 0 {
            break
        }
        resp.append(buff, size)
    }
    BIO_free_all(bio)
    SSL_CTX_free(ctx)
    return resp

}

#define! getpeername(connfd int, addr sockaddr_in*, s int*) int


//A wrapper for requests.
//When receiving a connection, you will be able to retreive the passed headers, path... from the client.
struct http_request extend http_transport {
    request: cpstring
    form: []string
    timeout: int = 0
    

    send() http_response* {
        socketWasOpenned = true
        isTLS = false
        host = ""
        if isSocket(this.socket) == false {
            this.socket = http_socket{}
            socketWasOpenned = false
            this.socket.open()
            this.socket.timeout = this.timeout
            if this.url != null {
                if strlen(this.path) == 0 {
                    this.path = this.url.path.str()
                }
                if this.url.proto.compare("https") {
                    isTLS = true
                    if this.url.port.length == 0 {
                        this.url.port.set("443")
                    }
                    host = this.url.host.str()+":"+this.url.port.str()
                } else {
                    if this.url.port.length == 0 {
                        this.url.port.set("80")
                    }
                    if this.socket.reach(this.url.host.str(), strToInt(this.url.port.str())) == false {
                        this.socket.close()
                        return null
                    }
                }
                    this.setHeader("host", this.url.host.str())
            } else {
                this.socket.close()
                return null
            }            
        }


        method = this.method
        if strlen(method) == 0 {
            method = "GET"
        }


        path = this.path
        if strlen(path) == 0 {
            path = "/"
        }
        message = method +" "+ path + " HTTP/1.0\r\n"
        i=0; for i < len(this.headers) {
            h = this.headers[i]
            message = message + h.str() + "\r\n"
            i = i + 1
        }
        message = message + "\r\n"

        if this.body != null {
            message = message + this.body.str()
        }

        resp response_buffer
        if isTLS == true {
            resp = makeRawHttpsRequest(host, message, this.timeout)
        } else {
            if this.socket.send(message) == false {
                if socketWasOpenned == false {
                    this.socket.close()
                }
                return null
            }

            resp = this.socket.receiveBuff()
        }

        if socketWasOpenned == false {
            this.socket.close()
        }

        return makeRespFromBody(resp)
    }

    //Call this to parse the post data form.
    //This will return false if anything goes wrong while parsing the form.
    parseForm() bool {
        if this.method != "POST" {
            return false
        }

        contentType = this.getHeader("Content-Type")
        if strHasPrefix(contentType, "multipart/form-data") {
            //cannot handle multipart for now
            return false
        }

        if contentType == "application/x-www-form-urlencoded" {
            body = this.body
            tmpBdy = *body
            tmpBdy.trimRight(2)
            this.form = splitString(tmpBdy, "&")
        }


        return true
    }

    //Used for getting the value of a form's input.
    getFormValue(name cpstring) cpstring {
        rName = string(name)
        rName = toLower(rName)
        i=0; for i < len(this.form) {
            f = this.form[i]
            if f.hasPrefix(rName.str() + "=") {
                f.trimLeft(rName.length + 1)
                f.trim()

                return urlDecode(f.str())
            }
            i = i + 1
        }
        return ""
    }

    //Used for getting the value of a cookie.
    getCookie(name cpstring) cpstring {
        encoded = string(this.getHeader("cookie"))
        cookies = splitString(encoded, ";")
        r = []char

        i=0; for i < len(cookies) {
            c = cookies[i]
            parts = splitString(c, "=")
            n = parts[0]
            n.trim()
            v = parts[1]

            if urlDecode(n.str()) == name {
                return urlDecode(v.str())
            }

            i = i + 1
        }
        return ""
    }

    //Returns the client IP address.
    getIP() cpstring {
        addr sockaddr_in
        addrSize int = sizeof(sockaddr_in)
        getpeername(this.socket.sockfd, &addr, &addrSize)
        return __STR(inet_ntoa(addr.sin_addr))
    }

}

//Used for parsing the request
http_request(connfd int) http_request {
    r = http_request{}
    r.socket = http_socket{}
    r.socket.sockfd = connfd
    reqcps = r.socket.receive()
    if reqcps == null {
        return r
    }
    req = string(reqcps)
    i = 0
    //parse method (GET, POST, PUT, DELETE...)
    method = string("")
    for i < req.length {
        c = req.charAt(i)
        if c == ' ' {
            break
        }
        cs = charToString(c)
        method.append(cs)
        i = i + 1
    }
    r.method = method.str()

    //parse path (/)
    path = string("")
    i = i + 1
    for i < req.length {
        c = req.charAt(i)
        if c == ' ' {
            break
        }
        cs = charToString(c)
        path.append(cs)
        i = i + 1
    }
    r.path = path.str()

    //trim rest of request (HTTP/1.1)
    for i < req.length {
        c = req.charAt(i)
        if c == <char>10 {
            break
        }
        i = i + 1
    }
    
    req.trimLeft(i)
    lines = splitString(req, "\r\n")

    isBody = false
    r.body = new string
    i=0; for i < len(lines) {
        l = lines[i]
        if isBody == true {
            r.body.append(l.str() + "\r\n")
        } else if l.length == 0 {
            isBody = true
        } else {
            l.trim()
            headerName = splitStringBefore(l, ":")
            headerCont = string(l.str())
            headerCont.trimLeft(strlen(headerName) + 1)
            headerCont.trim()
            r.setHeader(headerName, headerCont.str())
        }
        
        i = i + 1
    }


    r.request = reqcps

    return r
}


//Used for making any request.
//Method is either http or https. The arguments (args) are the variables to pass (can be post or get variable) formatted as: name=value.
// makeRawRequest(method cpstring, u http_url*, args []cpstring) http_response {
//     proto = u.proto
//     host = u.host
//     path = u.path
    
//     serv_addr sockaddr_in

//     portno = 80
//     if u.port.length > 0 {
//         portno = atoi(u.port.content)
//     }
//     response = string("")
    
//     message = string(" ")
//     message.prepend(method)
//     message.append(path.str())
//     serialArgs = string("?")
//     largs = len(args)
//     max = largs - 1
//     i = 0; for i < largs {
//         serialArgs.append(args[i])
//         if i < max {
//             serialArgs.append("&")
//         }
//         i = i + 1
//     }
//     if largs > 0 {
//         message.append(serialArgs.str())
//     }
//     message.append(" HTTP/1.0\r\nHost: ")
    
//     if proto.compare("https") {
//         host.append(":443")
//     }
    
//     message.append(host.str())
//     message.append("\r\nConnection: close\r\n\r\n")
    

//     if proto.compare("https") {
//         resp = makeRawHttpsRequest(host.str(), message.str(), 0)
//         response.set(resp)

//     } else {

//         sock = http_socket{}
//         if sock.open() == false {
//             panic("http: error opening socket")
//         }

//         if sock.reach(host.str(), portno) == false {
//             panic("http: error resolving host '"+host.str()+"'.")
//         }

//         if sock.send(message.str()) == false {
//             panic("http: error sending trought socket")
//         }

//         response.set(sock.receive())
//         sock.close()

//     }

//     resp = http_response{}
//     resp.body = new string

//     lines = splitString(response, "\r\n")
//     if len(lines) == 0 {
//         return resp
//     }


//     i = 0 
//     head = lines[0]
//     for i < head.length {
//         c = head.charAt(i)
//         if c == ' ' {
//             i = i + 1
//             break
//         }
//         i = i + 1
//     }

//     httpCode = string("")
//     for i < head.length {
//         c = head.charAt(i)
//         httpCode.append(charToString(c))
//         if c == ' ' {
//             break
//         }
//         i = i + 1
//     }
//     httpCodeInt = stringToInt(httpCode)
//     resp.code = httpCodeInt
    
//     isBody = 0
    
//     max = len(lines) - 1
//     body = string("")
//     i = 1; for i < len(lines) {

//         line = lines[i]
//         if isBody == 1 {
//             s = string(line.str())
//             if i < max {
//                 s.append("\r\n")
//             }
//             body.append(s.str())
//             i = i + 1
//             continue
//         }
//         if i > 0 {
//             pl = lines[i-1]
//             if strlen(pl.str()) == 0 {
//                 isBody = 1
//                 line.trimLeft(2)
//                 continue
//             }
//         }

//         header = new string
//         headerName = string(splitStringBefore(line, ":"))
//         if headerName.length > 0 {
//             headerName = toLower(headerName)
//             line.trimLeft(headerName.length)
//             line.prepend(headerName.str())
//         }
//         header.set(line.str())
//         lrh = len(resp.headers)
//         resp.headers[lrh] = header

//         i = i + 1
//     }

//     transferEncoding = resp.getHeader("Transfer-Encoding")
//     if strcmp(transferEncoding, "chunked") == 0 {
        
//         resp.body.set("")
        
//         for true == true {
//             chunkLen = splitStringBefore(body, "\r\n")
//             if strcmp(chunkLen, "0") == 0 {
//                 break
//             }
//             l = strtol(chunkLen, noCheck(0), 16)
//             l = l
//             body.trimLeft(strlen(chunkLen)+2)
//             chunk cpstring = memoryAlloc(l+1)
//             memcpy(chunk, body.content, l)
//             resp.body.append(chunk)
//             body.trimLeft(l+2)
//         }

//     } else {
//         resp.body.set(body.str())
//     }


//     return resp

// }

//Used for making simple get request.
get(url cpstring) http_response {
    panic("Deprecated get() call")
    r = http_response{}
    return r
}

//Used for making simple post request with variables (args) formatted as name=value.
post(url cpstring, args []cpstring) http_response {
    panic("Deprecated post() call")
    r = http_response{}
    return r
}

//Checks if a port is available.
//*Note: this command is very slow.*
isPortAvailable(port int) int {
    cmdS = intToString(port)
    cmdS.prepend("netstat -antu | grep :")
    cmd = command(cmdS.str())
    cmd.error = false
    s = cmd.run()
    if strlen(s) > 0 {
        return 0
    }
    return 1
}

//Example
// #include "http.bah"
//
//
// server(serv http_server*, connfd int) {
//
//     request = http_request(connfd)
//     response = http_response(connfd)
//
//     response.setHeader("Content-Type", "text/html")
//
//     response.write("Current path:")
//     response.write(request.path)
//
//     response.write("\nIt works!")
//     response.send()
//
// }
//
// main() {
//  
//     s = http_server{}
//     s.port = 8080
//     s.handle = server
//     s.listenAndServe()
//
// }