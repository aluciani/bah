#include "cBinds.bah"

#include "iostream.bah"
#include "string.bah"
#include "exec.bah"
#include "thread.bah"

#include "<unistd.h>"
#include "<signal.h>"

#linux {
    #include "<sys/types.h>"
    #include "<sys/socket.h>"
    #include "<sys/ioctl.h>"
    #include "<arpa/inet.h>"
    #include "<netinet/in.h>"
    #include "<netdb.h>"
    #include "<openssl/ssl.h>"
    #include "<openssl/err.h>"
    #include "<openssl/bio.h>"
    #include "<sys/select.h>"
    #include "<sys/time.h>"
    #include "<poll.h>"
    #include "<net/if.h>"
}

#windows {
    #include "<windows.h>"
    #include "<winsock2.h>"
    #include "<openssl/ssl.h>"
    #include "<openssl/err.h>"
    #include "<openssl/bio.h>"

    //#warning "Don't forget to copy the ssleay32.dll and libeay32.dll in your application path."
}



//sockets

#define! socklen_t uint

#windows {
    __httpDNSmutex = mutex()
}

struct! in_addr {
    s_addr: char
}


struct! hostent {
    h_name: str
    h_aliases: str
    h_addrtype: int
    h_length: int
    h_addr: uint*
    h_addr_list: str*
}

struct! sockaddr_in {
    sin_family: int
    sin_port: uint
    sin_addr: in_addr
}

struct! addrinfo {
    ai_flags: int
    ai_family: int
    ai_socktype: int
    ai_protocol: int
    ai_addrlen: int
    ai_addr: sockaddr_in*
    ai_canonname: str
    ai_next: addrinfo*
}

struct! timeval {
    tv_sec: int
    tv_usec: int
}

#define! fd_set ptr

#define! inet_ntoa(addr in_addr) str
#define! inet_addr(a str) in_addr

#define! socket(a int, b int, c int) int
#define! gethostbyname(h str) hostent*
#define! htons(p int) uint
#define! connect(sockfd int, ser_addr sockaddr_in*, s int) int
#define! send(sockfd int, msg str, msglen int, c int) int
#define! recv(sockfd int, buff char*, bufflen int, c int) int
#define! close(sockfd int) int
#define! htonl(inaddrt int) char
#define! bind(sockfd int, ser_addr sockaddr_in*, s int) int
#define! listen(sockfd int, s int) int
#define! memset(str ptr, w int, s int)
#define! accept(sockfd int, cliaddr sockaddr_in*, clilen int*) int
#define! shutdown(fd int, flags int) int
#define! setsockopt(fd int, w int, flag int, val ptr, flagSize int) int
#define! getsockopt(fd int, t int, w int, e ptr, el int*) int
#define! fcntl(fd int, oper int, flag int) int
#define! FD_ZERO(s ptr)
#define! FD_SET(sock int, s ptr)
#define! FD_ISSET(sock int, s ptr) int
#define! select(sock int, ws ptr, rs ptr, ex ptr, timeout timeval*) int
#define! ioctl(sock int, f int, v int*) int
#define! getaddrinfo(host str, port str, hints addrinfo*, addrs addrinfo**) int
#define! freeaddrinfo(addr addrinfo*)

struct! pollfd {
    fd: int
    events: int
    revents: int
}

#define! poll(fds pollfd*, nfd int, timeout int) int


struct! ifreq {
    ifr_name: str
}

#define! snprintf(s str, s int, format str)

#windows {
    #define! WSADATA ptr
    #define! MAKEWORD(a int, b int) ptr
    #define! WSAStartup(w ptr, d WSADATA*) int
    #define! closesocket(sockfd int)
    #define! hostname_to_ip(host str, ip str)

    //Ran at startup to initiate networking on windows platform.
    __Bah_win32_WSA_init() bool {
        wsadata WSADATA
        WSAStartup(MAKEWORD(1,1), &wsadata)
        return true
    }

    __Bah_win32_WSA_is_init = __Bah_win32_WSA_init()
}


//SSL - TLS (https)
#cLib "lssl" "lcrypto"

#windows {
    #cLib "lws2_32"
}


#define! SSL_library_init() int
#define! TLSv1_2_client_method() int
#define! SSL_CTX_new(m int) ptr
#define! BIO_new_ssl_connect(ctx ptr) ptr
#define! BIO_set_conn_hostname(bio ptr, h str) int
#define! BIO_do_connect(bio ptr) int
#define! BIO_do_handshake(bio ptr) int
#define! BIO_write(bio ptr, cont str, size int) int
#define! BIO_should_retry(bio ptr) int
#define! BIO_read(bio ptr, buff char*, size int) int
#define! BIO_free_all(bio ptr)
#define! SSL_CTX_free(ctx ptr)
#define! SSL_CTX_set_timeout(ctx ptr, t int) int
#define! BIO_get_ssl(bio ptr, ssl ptr*)
#define! SSL_set_mode(ssl ptr, mode int)
#define! SSL_set_tlsext_host_name(ssl ptr, host str) int
#define! SSL_CTX_set_cipher_list(ctx ptr, l str)
#define! SSL_CTX_load_verify_locations(ctx ptr, cert str, key str) int
#define! SSL_CTX_set_default_verify_paths(ctx ptr) int
#define! SSL_CTX_use_certificate_file(ctx ptr, cert str, ft int) int
#define! SSL_CTX_set_default_passwd_cb_userdata(ctx ptr, pass str)
#define! SSL_CTX_use_PrivateKey_file(ctx ptr, key str, ft iny) int
#define! SSL_CTX_check_private_key(ctx ptr) int
#define! OpenSSL_add_all_algorithms()
#define! SSL_new(ctx ptr) ptr
#define! SSL_set_fd(ssl ptr, sd int)
#define! SSL_accept(ssl ptr) int
#define! SSL_read(ssl ptr, buff char*, s int) int
#define! SSL_write(ssl ptr, buff str, s int) int
#define! SSL_free(ssl ptr)
#define! SSL_get_peer_certificate(ssl ptr) ptr
#define! X509_get_subject_name(cert ptr) char*
#define! X509_get_issuer_name(cert ptr) char*
#define! X509_NAME_oneline(s char*, a int, b int) str
#define! X509_free(cert ptr)
#define! TLSv1_2_server_method() int

__Bah_http_is_ssl_initialized = SSL_library_init()

//Represents a response buffer for easier i/o reading.
//You can append to the buffer and read its content.
struct response_buffer {
    data: str
    len: int

    //Returns the buffer as a str.
    str() str {
        return this.data
    }

    //Returns the buffer as an array of char.
    arr() []char {
        a = []char
        noCheck(a->data = this->data + strLenSize)
        noCheck(a->length = this->len)
        return a
    }

    //Appends data to the buffer.
    //s is the length of read data to append.
    append(buff char*, s int) {
        if len(this.data) == 0 {
            this.data = memoryAllocSTR(s+1)
        } else {
            d str = memoryRealloc(this.data, this.len + s + 1 + strLenSize)
            ln uint32* = d
            this.data = d
            *ln = this.len + s
        }
        memcpy(<ptr>(<int>this.data + strLenSize + this.len), buff, s)
        this.len = this.len + s
    }

}

//Represents a socket.
struct http_socket {
    sockfd: int = -1
    timeout: int = 0
    sizeLimit: uint = 0
    ssl: ptr = null

    //To check if a socket is opened.
    isOpened() bool {
        return this.sockfd > 0
    }

    //To open a socket.
    //If a socket is opened, it must be closed.
    open() bool {
        this.sockfd = socket(2, 1, 0)
        if this.isOpened() {
            optVal = 1
            setsockopt(this.sockfd, noCheck(SOL_SOCKET), noCheck(SO_REUSEADDR), &optVal, SIZE_OF_INT)
            return true
        }
        return false
    }

    //To set the linux network interface on which the socket should operate.
    setInterface(s str) bool {
        #linux {
            ifr ifreq
            memset(&ifr, 0, noCheck(sizeof(ifr)))
            snprintf(ifr.ifr_name, noCheck(sizeof(ifr.ifr_name)), s)
            return setsockopt(this.sockfd, noCheck(SOL_SOCKET), noCheck(SO_BINDTODEVICE), &ifr, noCheck(sizeof(ifr))) == 0
        }
        #windows {
            return false
        }
    }

    //To terminate a socket.
    terminate() bool {
        #linux {
            return shutdown(this.sockfd, noCheck(SHUT_RDWR)) != -1
        }
        #windows {
            return false
        }
    }

    //To close a socket.
    close() bool {
        if this.ssl != null {
            SSL_free(this.ssl)
        }

        if this.sockfd < 0 {
            return true
        }

        #linux {
            flags = fcntl(this.sockfd, noCheck(F_GETFL), 0)
            fcntl(this.sockfd, noCheck(F_SETFL), noCheck(flags | FD_CLOEXEC))
            err = 0
            errlen = SIZE_OF_INT
            getsockopt(this.sockfd, noCheck(SOL_SOCKET), noCheck(SO_ERROR), &err, &errlen)
            r = true
            if this.terminate() == false {
                r = close(this.sockfd) != -1
            }
        }
        #windows {
            closesocket(this.sockfd)
            r = true
        }

        this.sockfd = -1
        return r
    }

    //To reach a host by port.
    //Used for making requests.
    reach(host str, port int) bool {
        if <ptr>host == null {
            return false
        }
        #linux {
            addrsup = addrinfo{}
            hints = addrinfo{}
            hints.ai_family = noCheck(AF_INET)
            hints.ai_socktype = noCheck(SOCK_STREAM)
            hints.ai_protocol = noCheck(IPPROTO_TCP)

            addrs = &addrsup

            err = getaddrinfo(host, intToStr(port), &hints, &addrs)
            if err != 0 {
                return false
            }

            res = -1
            if this.timeout > 0 {
                iMode = 1
                ioctl(this.sockfd, noCheck(FIONBIO), &iMode)
                if connect(this.sockfd, addrs.ai_addr, addrs.ai_addrlen) == 0 {
                    freeaddrinfo(addrs)
                    return false
                }
                iMode = 0
                ioctl(this.sockfd, noCheck(FIONBIO), &iMode)
                
                pfd = pollfd{}
                pfd.fd = this.sockfd
                pfd.events = noCheck(POLLOUT)


                res = poll(&pfd, 1, this.timeout * 1000)
                if res <= 0 {
                    freeaddrinfo(addrs)
                    return false
                }

                return true
            } else {
                res = connect(this.sockfd,addrs.ai_addr, addrs.ai_addrlen)
            }

            if res <= 0 {
            freeaddrinfo(addrs)
                return false
            }
            freeaddrinfo(addrs)
        }
        #windows {
            ip str = memoryAlloc(20)
            server = sockaddr_in{}
            server.sin_family = noCheck(AF_INET)
            server.sin_port = htons(port)
            __httpDNSmutex.lock()
            he = gethostbyname(host)
            if he == null {
                __httpDNSmutex.unlock()
                addr = he.h_addr
                server.sin_addr.s_addr = <char>*addr
                return false
            }

            __httpDNSmutex.unlock()

            return connect(this.sockfd, &server, noCheck(sizeof(server))) >= 0
        }
        return true
    }

    //To listen on a specific port.
    listen(port int) bool {
        //binding
        servaddr sockaddr_in
        servaddr.sin_family = 2
        saddr = in_addr{}
        saddr.s_addr = htonl(0)
        servaddr.sin_addr = saddr
        servaddr.sin_port = htons(port)
        if bind(this.sockfd, &servaddr, 16) == -1 {
            return false
        }
        //listenning
        if listen(this.sockfd,1024) < 0 {
            return false
        }
        optVal = 1
        return true
    }

    //To accept a connection after listenning.
    accept() int {
        cliaddr sockaddr_in
        clilen = 16
        return  accept(this.sockfd, &cliaddr, &clilen)
    }

    //To send data through the socket.
    send(s str) bool {
        if this.isOpened() == false {
            return false
        }
        if this.ssl != null {
            return SSL_write(this.ssl, s, len(s)) > 0
        }
        return send(this.sockfd, s, len(s), 0) > 0
    }

    //To send data as bytes through the socket.
    sendBytes(bytes []char) bool {
        if this.isOpened() == false {
            return false
        }
        if this.ssl != null {
            return SSL_write(this.ssl, cArr(bytes), len(bytes)) > 0
        }
        return send(this.sockfd, cArr(bytes), len(bytes), 0) > 0
    }

    //To receive data as a response buffer.
    receiveBuff() response_buffer {
        buff = buffer 1025
        rep = response_buffer{}

        nDataLength = 0
        #linux {
            iMode = 0
            ioctl(this.sockfd, noCheck(FIONBIO), &iMode)
            if this.ssl != null {
                nDataLength = SSL_read(this.ssl,<char*>buff,1024)
            } else {
                nDataLength = recv(this.sockfd,<char*>buff,1024,0)
            }
            if nDataLength == -1 {
                return rep
            }
            rep.append(<char*>buff, nDataLength)
            iMode = 1
            ioctl(this.sockfd, noCheck(FIONBIO), &iMode)
        }

        for 1 == 1 {
            if this.ssl != null {
                nDataLength = SSL_read(this.ssl,<char*>buff,1024)
            } else {
                nDataLength = recv(this.sockfd,<char*>buff,1024,0)
            }
            if this.sizeLimit != 0 && rep.len >= this.sizeLimit {
                break
            }
            if nDataLength <= 0 {
                break
            }
            rep.append(<char*>buff, nDataLength)
        }
        return rep
    }

    //To receive data through the socket.
    receive() str {
        r = this.receiveBuff()
        return r.str()
    }

    //To receive data as bytes through the socket.
    receiveBytes() []char {
        r = this.receiveBuff()
        return r.arr()
    }

}

//To check if a socket is opened.
isSocket(s http_socket) bool {
    return s.sockfd > 0
}

//Represents an url.
struct http_url {
    path: string
    host: string
    proto: string
    port: string
}



//Used for parsing an URL.
parseUrl(s str) http_url* {
    u = new http_url
    
    //get protocol
    i = 0
    max = len(s)
    hasProto = false
    for i < max, i++ {
        c = s[i]
        if c == ':' {
            hasProto = true
            break
        }
    }
    if hasProto == true {
        i = 0;for i < max, i++ {
            if s[i] == ':' {
                break
            }
        }
        u.proto = string(s[:i])
        i++
    } else {
        u.proto = string("http")
        i = 0
    }
    for s[i] == '/', i++ {
        if i+1 == max {
            break
        }
    }

    //get host
    start = i
    for i != max, i++ {
        if s[i] == '/' || s[i] == ':' {
            break
        }
    }
    u.host = string(s[start:i])


    if i+1 == max {
        u.path = string("/")
        if u.proto.compare("https") {
            u.port = string("443")
        } else {
            u.port = string("80")
        }
        return u
    }
    
    if s[i] == ':' {
        i++
        start = i
        for i < max, i++ {
            if s[i] == '/' {
                break
            }
        }
        u.port = string(s[start:i])
    }
    

    if i+1 == max {
        u.path = string("/")
        return u
    }


    u.path = string(s[i:])

    return u
}

__HTTP_urlSafeChars = []char{
    '.',
    '!'
}

//Used for encoding a string to a safe url format.
//Encoded strings can be used as url parameter without being interpreted as path.
urlEncode(s str) str {
    r = []char
    tmps = buffer 10

    i=0; for i < len(s), i++ {
        c = s[i]
        if isAlphaNumeric(c) || c in __HTTP_urlSafeChars {
            r[len(r)] = c
        } else {
            r[len(r)] = '%'
            sprintf(<ptr>tmps, "%x", c)
            l = strlen(<ptr>tmps)
            j=0; for j < l, j++ {
                r[len(r)] = tmps[j]
            }
            
        }
    }

    return arrToStr(r)
}

//Used for decoding an url encoded string.
urlDecode(s str) str {
    r = []char

    i=0; for i < len(s) {
        c = s[i]
        if c == '+' {
            r[len(r)] = ' '
        } else if c == '%' {
            hexStr = []char{s[i+1], s[i+2], null}
            c = <char>strtol(cArr(hexStr), null, 16)
            r[len(r)] = c
            i = i + 2
        } else {
            r[len(r)] = c
        }
        i = i + 1
    }

    return arrToStr(r)
}


http_broken_pipe(signo int) {
    println("http: warning, trying to send data to a closed socket.")
}

//To send a str through the specified socket.
//This is depreacted, use http_socket instead.
http_send(connfd int, s str) {
    send(connfd, s, strlen(s), 0)
}


//HTTP code 200 means everything is ok
const HTTP_OK = 200
//HTTP code 404 means file not found
const HTTP_NOT_FOUND = 404
//HTTP code 400 means that you deny access to this request
const HTTP_FORBIDDEN = 400
//HTTP code 500 means that the server encountered an internal error
const HTTP_ERROR = 500
//HTTP code 301 means a permanent redirection
const HTTP_REDIRECT = 301
//HTTP code 206 means content can be seeked up in a range
const HTTP_PARTIAL_CONTENT = 206


//This is the skeletton for http_request and http_response.
//It represents a bear bone request.
struct http_transport {
    socket: http_socket
    headers: []string*
    code: int = HTTP_OK
    body: string*
    file: []char
    url: http_url*
    method: str = ""
    path: str = ""

    //To set a header by name.
    setHeader(name str, value str) {
        h = new string
        ln = toLower(string(name))
        h.set(ln.str()+": "+value)
        this.headers[len(this.headers)] = h
    }

    //To get the value of a header by name.
    getHeader(name str) str {
        headerName = string(name)
        headerName = toLower(headerName)
        headerName.append(":")
        i=0;for i < len(this.headers) {
            currentHeader = this.headers[i]
            if currentHeader.hasPrefix(headerName.str()) {
                header = string(currentHeader.str())
                space = 0
                c = header.charAt(headerName.length)
                if isSpace(c) {
                    space = 1
                }
                header.trimLeft(headerName.length+space)
                return header.str()
            }
            i=i+1
        }

        return ""

    }

    //To append to the body of the response.
    write(content str) {
        body = this.body
        body.append(content)
    }

}


//A wrapper for HTTP responses. You will be able to set/retreive the headers sent/receive.
//You will encounter this when doing a request or sending a response to the client.
struct http_response extend http_transport {
    headersSent: bool = false
    //Send the response.
    //*Use it only when sending response to the client from a http_server*.
    send() {
        if this.headersSent == false {
            s = string("HTTP/1.0 ")
            if this.code == HTTP_OK {
                s.append("200 OK")
            } else if this.code == HTTP_NOT_FOUND {
                s.append("404 Not Found")
            } else if this.code == HTTP_FORBIDDEN {
                s.append("400 Bad Request")
            } else if this.code == HTTP_ERROR {
                s.append("500 Internal Server Error")
            } else if this.code == HTTP_REDIRECT {
                s.append("301 Moved Permanently")
            } else if this.code == HTTP_PARTIAL_CONTENT {
                s.append("206 Partial Content")
            } else {
                s.append(intToStr(this.code))
            }
            s.append("\r\n")
            
            i = 0
            
            for i < len(this.headers) {
                e = this.headers[i]
                s.append(e.str())
                s.append("\r\n")
                i = i + 1
            }
            
            s.append("\r\n")

            
            s.append(this.body.str())
            this.body.set("")
            if this.socket.send(s.str()) == false {
                this.socket.close()
            }
            headersSent = true
        } else {
            if this.socket.send(this.body.str()) == false {
                this.socket.close()
            }
            this.body.set("")
        }

    }

    //Used for flushing content rather than sending it fully.
    //Useful for sending large files, websockets, SSE, etc...
    flush(bytes []char) bool {
        if this.socket.sendBytes(bytes) == false {
            this.socket.close()
            return false
        }
        return true
    }

}

//To build a HTTP response.
//You will need to populate it before sending it to the client.
http_response(sock http_socket*) http_response* {
    resp = new http_response
    resp.socket = *sock

    iMode = 0
    ioctl(resp.socket.sockfd, noCheck(FIONBIO), &iMode)

    resp.setHeader("Server", "bah-http-framework")
    resp.setHeader("Connection", "close")

    body = new string
    body.set("")
    resp.body = body

    return resp
}

//Parses the HTTP request from a response buffer and returns a http_response.
//This is an internal function.
makeRespFromBody(response response_buffer) http_response* {
    if response.len == 0 {
        return null
    }


    resp = new http_response
    resp.file = []char
    resp.body = new string

    arr = response.arr()
    str = response.str()

    tmp = ""

    //HTTP version
    i=0; for i < len(arr), i++ {
        c = arr[i]
        if c == ' ' {
            tmp = str[:i]
            i++
            break
        }
    }
    
    if strHasPrefix(tmp, "HTTP/") == false {
        return null
    }

    //HTTP code
    offset = i
    tmp = ""
    for i < len(arr), i++ {
        c = arr[i]
        if c == ' ' {
            tmp = str[offset:i]            
            i++
            break
        }
    }
    resp.code = strToInt(tmp)

    //Skip Text version of the code
    for i < len(arr), i++ {
        if arr[i-1] == <char>13 && arr[i] == <char>10 {
            i++
            break
        }
    }

    //Headers
    for i < len(arr), i++ {
        
        headerName = ""
        headerCont = ""
        //Read header name until ':'
        start = i
        for i < len(arr), i++ {
            c = arr[i]
            if c == ':' {
                headerName = str[start:i]
                i++
                break
            } else if c == <char>13 || c == <char>10 {
                i = start
                break
            }
        }

        if i == start {
            break
        }

        for i < len(arr), i++ {
            if isSpace(arr[i]) == false {
                break
            }
        }

        //Read header content until "\r\n"
        start = i
        for i < len(arr), i++ {
            c = arr[i]
            if c == <char>13 {
                if i+1 < len(arr) && arr[i+1] == <char>10 {
                    headerCont = str[start:i]
                    i += 2
                    break
                }
            }
        }

        resp.setHeader(headerName, headerCont)

        //If "\r\n", end of headers, beggining of body
        if arr[i] == <char>13 {
            // println("found")
            if i+1 < len(arr) {
                if arr[i+1] == <char>10 {
                    i+= 2
                    break
                }
            }
        }
        i--
    }

    //Reading body to file array
    resp.file = arr[i:]

    //Setting body to content of file array + null character.
    resp.body.set(str[i:])

    return resp
}


//Used for making TLS requests.
//*This is an internal function, you should know what you're doing if you decide to use it.*
makeRawHttpsRequest(host str, message str, timeout int) response_buffer {
    ssl ptr

    ctx = SSL_CTX_new(TLSv1_2_client_method())
    if timeout > 0 {
        SSL_CTX_set_timeout(ctx, timeout)
    }

    resp = response_buffer{}
    if ctx == null {
        println("http: cannot initialize ssl context")
        SSL_CTX_free(ctx)
        return resp
    }

    bio = BIO_new_ssl_connect(ctx)

    BIO_get_ssl(bio, &ssl)
    SSL_set_mode(ssl, 4)

    if BIO_set_conn_hostname(bio, host) != 1 {
        println("http: error finding host '"+host+"'.")
        SSL_CTX_free(ctx)
        BIO_free_all(bio)
        return resp
    }

    SSL_set_tlsext_host_name(ssl, splitStringBefore(string(host), ":"))

    if BIO_do_connect(bio) <= 0 {
        println("http: error connecting through ssl to '"+host+"'.")
        SSL_CTX_free(ctx)
        BIO_free_all(bio)
        return resp
    }

    if BIO_do_handshake(bio) != 1 {
        println("http: error during ssl handshake with host '"+host+"'.")
    }

    success = BIO_write(bio, message, strlen(message))

    if success <= 0 {
        if BIO_should_retry(bio) == 0 {
            println("http: failed sending request.")
            BIO_free_all(bio)
            SSL_CTX_free(ctx)
            return resp
        }
    }

    buff = buffer 1025
    for true == true {
        size = BIO_read(bio, <char*>buff, 1025)
        if size <= 0 {
            break
        }
        resp.append(<char*>buff, size)
    }
    SSL_CTX_free(ctx)
    BIO_free_all(bio)
    return resp

}

#define! getpeername(connfd int, addr sockaddr_in*, s int*) int

struct http_form_file {
    name: str
    fileName: str
    type: str
    body: str
}

//A wrapper for requests.
//When receiving a connection, you will be able to retreive the passed headers, path... from the client.
struct http_request extend http_transport {
    request: str
    form: []string
    files: []http_form_file
    timeout: int = 0
    sizeLimit: uint = 0
    
    //Sends the response.
    //Dont forget to calling after writting to it.
    send() http_response* {
        socketWasOpenned = true
        isTLS = false
        host = ""
        if isSocket(this.socket) == false {
            this.socket = http_socket{}
            socketWasOpenned = false
            this.socket.open()
            this.socket.timeout = this.timeout
            this.socket.sizeLimit = this.sizeLimit
            if this.url != null {
                if strlen(this.path) == 0 {
                    this.path = this.url.path.str()
                }
                if this.url.proto.compare("https") {
                    isTLS = true
                    if this.url.port.length == 0 {
                        this.url.port.set("443")
                    }
                    host = this.url.host.str()+":"+this.url.port.str()
                } else {
                    if this.url.port.length == 0 {
                        this.url.port.set("80")
                    }
                    if this.socket.reach(this.url.host.str(), strToInt(this.url.port.str())) == false {
                        this.socket.close()
                        return null
                    }
                }
                    this.setHeader("host", this.url.host.str())
            } else {
                this.socket.close()
                return null
            }            
        }


        method = this.method
        if strlen(method) == 0 {
            method = "GET"
        }


        path = this.path
        if strlen(path) == 0 {
            path = "/"
        }
        message = method +" "+ path + " HTTP/1.0\r\n"
        i=0; for i < len(this.headers) {
            h = this.headers[i]
            message = message + h.str() + "\r\n"
            i = i + 1
        }
        message = message + "\r\n"

        if this.body != null {
            message = message + this.body.str()
        }

        resp response_buffer

        if isTLS == true {
            resp = makeRawHttpsRequest(host, message, this.timeout)
        } else {
            if this.socket.send(message) == false {
                if socketWasOpenned == false {
                    this.socket.close()
                }
                return null
            }

            resp = this.socket.receiveBuff()
        }

        if socketWasOpenned == false {
            this.socket.close()
        }

        return makeRespFromBody(resp)
    }

    //Call this to parse the post data form.
    //This will return false if anything goes wrong while parsing the form.
    parseForm() bool {
        if this.method != "POST" {
            return false
        }

        contentType = this.getHeader("Content-Type")
        contentTypeS = string(contentType)
        if contentType == "application/x-www-form-urlencoded" {
            body = this.body
            tmpBdy = *body
            if tmpBdy.length > 2 && tmpBdy.charAt(tmpBdy.length-1) == <char>10 && tmpBdy.charAt(tmpBdy.length-2) == <char>13 {
                tmpBdy.trimRight(2)
            }
            this.form = splitString(tmpBdy, "&")
        } else if contentTypeS.hasPrefix("multipart/form-data") {
            if contentTypeS.countChar('=') == 0 {
                return false
            }
            boundary = splitString(contentTypeS, "=")[1].str()
            if boundary[0] == '"' {
                boundary = boundary[1:len(boundary)-1]
            }
            
            body = this.body
            values = splitString(*body, "--"+boundary)
            j=0; for j < len(values), j++ {
                file = http_form_file{}

                req = values[j].str()
                i=0; for i < len(req), i++ {
                    headerName = ""
                    headerCont = ""
                    //Read header name until ':'
                    start = i
                    for i < len(req), i++ {
                        c = req[i]
                        if c == ':' {
                            headerName = req[start:i]
                            i++
                            break
                        }
                    }

                    for i < len(req), i++ {
                        if isSpace(req[i]) == false {
                            break
                        }
                    }

                    //Read header content until "\r\n"
                    start = i
                    for i < len(req), i++ {
                        c = req[i]
                        if c == <char>13 {
                            if i+1 < len(req) && req[i+1] == <char>10 {
                                headerCont = req[start:i]
                                i += 2
                                break
                            }
                        }
                    }

                    headerNameS = toLower(string(headerName))

                    if headerNameS.count("content-disposition") {
                        k=0; for k < len(headerCont), k++ {
                            if isSpace(headerCont[k]) == false {
                                break
                            }
                        }
                        
                        attrNameInd = [k,0]
                        attrContInd = [0,0]; cont = ""
                        isName = true
                        headerCont += ";"
                        for k < len(headerCont), k++ {
                            if isSpace(headerCont[k]) {
                                continue
                            }

                            if headerCont[k] == ';' {
                                if isName == false {
                                    if len(cont) == 0 {
                                        cont = headerCont[attrContInd[0]:attrContInd[1]]
                                    }
                                    name = headerCont[attrNameInd[0]:attrNameInd[1]]
                                    if name == "name" {
                                        file.name = cont
                                    } else if name == "filename" {
                                        file.fileName = cont
                                    }
                                }
                                cont = ""
                                isName = true
                                k++
                                for k < len(headerCont), k++ {
                                    if isSpace(headerCont[k]) == false {
                                        break
                                    }
                                }
                                attrNameInd[0] = k
                                continue
                            }

                            if isName && headerCont[k] == '=' {
                                    attrNameInd[1] = k
                                    k++
                                    for k < len(headerCont), k++ {
                                        if isSpace(headerCont[k]) == false {
                                            break
                                        }
                                    }
                                    if headerCont[k] == '"' {
                                        contb = strBuilder{}
                                        k++
                                        for k < len(headerCont), k++ {
                                            if headerCont[k] == '\' {
                                                i++
                                                contb.append(headerCont[k])
                                                continue
                                            }
                                            if headerCont[k] == '"' {
                                                break
                                            }
                                            contb.append(headerCont[k])
                                        }
                                        cont = contb.str()
                                    } else {
                                        attrContInd[0] = k
                                    }
                                    isName = false
                                    continue
                            }
                        }

                    } else if headerNameS.count("content-type") {
                        file.type = headerCont
                    }

                    //If "\r\n", end of headers, beggining of body
                    if req[i] == <char>13 {
                        if i+1 < len(req) {
                            if req[i+1] == <char>10 {
                                i+= 2
                                break
                            }
                        }
                    }
                    i--
                }
                
                end = len(req)

                if end >= 2 && req[end-1] == <char>10  && req[end-2] == <char>13 {
                    end -= 2
                }

                formVal = req[i:end]

                if len(file.fileName) != 0 {
                    file.body = formVal
                    this.files[len(this.files)] = file
                } else {
                    this.form[len(this.form)] = string(file.name+"="+urlEncode(formVal))
                }

            }

        }

        return true
    }

    //Used for getting the value of a form's input.
    getFormValue(name str) str {
        rName = string(name)
        rName = toLower(rName)
        i=0; for i < len(this.form) {
            f = this.form[i]
            if f.hasPrefix(rName.str() + "=") {
                f.trimLeft(rName.length + 1)
                f.trim()

                return urlDecode(f.str())
            }
            i = i + 1
        }
        return ""
    }

    //Used for getting the value of a cookie.
    getCookie(name str) str {
        encoded = string(this.getHeader("cookie"))
        cookies = splitString(encoded, ";")
        r = []char

        i=0; for i < len(cookies) {
            c = cookies[i]
            parts = splitString(c, "=")
            n = parts[0]
            n.trim()
            v = parts[1]

            if urlDecode(n.str()) == name {
                return urlDecode(v.str())
            }

            i = i + 1
        }
        return ""
    }

    //Returns the client IP address.
    getIP() str {
        addr sockaddr_in
        addrSize int = sizeof(sockaddr_in)
        getpeername(this.socket.sockfd, &addr, &addrSize)
        return __STR(inet_ntoa(addr.sin_addr))
    }

}

//Used for parsing the request (with limited size)
http_requestSizeLimited(sock http_socket*, size int) http_request* {
    r = new http_request
    r.socket = http_socket{
        sizeLimit: size
    }
    r.socket = *sock
    req = r.socket.receive()
    if req == null {
        return r
    }
    l = len(req)
    i = 0
    //parse method (GET, POST, PUT, DELETE...)
    method = strBuilder{}
    for i < l, i++ {
        c = req[i]
        if c == ' ' {
            break
        }
        method.append(c)
    }
    r.method = method.str()

    //parse path (/)
    path = strBuilder{}
    i++
    for i < l, i++ {
        c = req[i]
        if c == ' ' {
            break
        }
        path.append(c)
    }
    r.path = path.str()

    //trim rest of request (HTTP/1.1)
    for i < l, i++ {
        if req[i] == <char>10 {
            i++
            break
        }
    }
    
    for i < len(req), i++ {
        
        headerName = ""
        headerCont = ""
        //Read header name until ':'
        start = i
        for i < len(req), i++ {
            c = req[i]
            if c == ':' {
                headerName = req[start:i]
                i++
                break
            }
        }

        for i < len(req), i++ {
            if isSpace(req[i]) == false {
                break
            }
        }

        //Read header content until "\r\n"
        start = i
        for i < len(req), i++ {
            c = req[i]
            if c == <char>13 {
                if i+1 < len(req) && req[i+1] == <char>10 {
                    headerCont = req[start:i]
                    i += 2
                    break
                }
            }
        }

        r.setHeader(headerName, headerCont)

        //If "\r\n", end of headers, beggining of body
        if req[i] == <char>13 {
            if i+1 < len(req) {
                if req[i+1] == <char>10 {
                    i+= 2
                    break
                }
            }
        }
        i--
    }

    r.body = new string
    if i < len(req) {
        r.body.set(req[i:])
    } 

    r.request = req

    //parse get parameters
    i=0; for i < len(r.path), i++ {
        if r.path[i] == '?' {
            r.form = splitString(string(r.path[i+1:]), "&")
            r.path = r.path[:i]
            break
        }
    }

    return r
}

//Used for parsing the request
http_request(sock http_socket*) http_request* {
return http_requestSizeLimited(sock, 0)
}



//web server

#linux {
    sigchld_handler(signo int) {
        status int
        pid int
        pid = waitpid(-1, &status, 1)
        for pid > 0 {
            pid = waitpid(-1, &status, 1)
        }
    }
}

//A type difinning http server erros.
#define http_serverError int

const HTTP_SERVER_NO_ERROR = <http_serverError>0
const HTTP_SERVER_SOCKET_ERROR = <http_serverError>1
const HTTP_SERVER_BIND_ERROR = <http_serverError>2
const HTTP_SERVER_LISTEN_ERROR = <http_serverError>3
const HTTP_SERVER_SSL_INIT_ERROR = <http_serverError>4
const HTTP_SERVER_SSL_LOCATION_ERROR = <http_serverError>5
const HTTP_SERVER_SSL_CERT_ERROR = <http_serverError>6
const HTTP_SERVER_SSL_KEY_ERROR = <http_serverError>7

globalHTTPsockets = []http_socket

//Internal function that is ran at exit to make sure that every sockets are closed.
http_quit_handler(signo int) {
    i=0; for i < len(globalHTTPsockets), i++ {
        s = globalHTTPsockets[i]
        s.close()
    }
    exit(0)
}

//A wrapper for a http web server.
struct http_server {
    port: int
    portTLS: int
    running: bool
    socket: http_socket
    socketTLS: http_socket
    error: http_serverError = HTTP_SERVER_NO_ERROR

    // cliChan: chan:http_socket*
    // nbThreads: uint = 50

    // setNbThreads(nb uint) {
    //     if this.running {
    //         panic("http: cannot change number of http.server worker threads while running.")
    //     }
    //     this.nbThreads = nb
    // }

    linux_interface: str = ""

    //Event lisstener for when receiving connections.
    handle: function(http_server*, http_request*, http_response*)
    
    //Event listener for when server started successfully.
    done: function(http_server*)

    //To stop the server.
    stop() {
        if this.socket.isOpened() == false {
            println("cannot stop http_server, not running")
            return
        }
        this.running = false
        this.socket.close()
    }

    threadWorker(sock http_socket*) {
        if sock.ssl != null {
            resp = SSL_accept(sock.ssl)
            if SSL_accept(sock.ssl) <= 0 {
                sock.close()
                return
            }
        }

        req = http_request(sock)
        resp = http_response(sock)
        this.handle(req, resp)
        sock.close()
    }

    //To start the server.
    listenAndServe() {
        this.error = HTTP_SERVER_NO_ERROR
        this.socket = http_socket{}

        this.socket.open()

        if strlen(this.linux_interface) > 0 && this.socket.setInterface(this.linux_interface) == false {
            panic("http: error setting server's linux interface")
        } 


        if this.socket.isOpened() == false {
            println("http: error opening socket")
            this.error = HTTP_SERVER_SOCKET_ERROR
            return
        }

        if this.socket.listen(this.port) == false {
            this.socket.close()
            println("http: failed to start listening")
            this.error = HTTP_SERVER_LISTEN_ERROR
            return
        }

        globalHTTPsockets[len(globalHTTPsockets)] = this.socket

        #linux {
            sa sigaction
            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = sigchld_handler
            sigaction(17, &sa, null)

            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = http_quit_handler
            sigaction(2, &sa, null)

            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = http_broken_pipe
            sigaction(noCheck(SIGPIPE), &sa, null)
        }

        this.running = true


        // i=0; for i < this.nbThreads, i++ {
        //     async this.threadWorker()
        // }

        if this.done != null {
            async this.done()
        }

        for this.running {
            cli = this.socket.accept()

            if cli <= 0 {
                continue
            }

            sock = new http_socket {
                sockfd: cli
            }

            async this.threadWorker(sock)
        }

        this.stop()

    }

    listenAndServeTLS(certFile str, keyFile str) {
        this.error = HTTP_SERVER_NO_ERROR

        //Initialize SSL context
        OpenSSL_add_all_algorithms()        
        ctx = SSL_CTX_new(TLSv1_2_server_method())
        if ctx == null {
            this.error = HTTP_SERVER_SSL_INIT_ERROR
            return
        }
        SSL_CTX_set_cipher_list(ctx, "ALL:eNULL")

        //Load SSL certs
        if SSL_CTX_load_verify_locations(ctx, certFile, keyFile) != 1 {
            this.error = HTTP_SERVER_SSL_LOCATION_ERROR
            return
        }
        if SSL_CTX_set_default_verify_paths(ctx) != 1 {
            this.error = HTTP_SERVER_SSL_LOCATION_ERROR
            return
        }
        if SSL_CTX_use_certificate_file(ctx, certFile, noCheck(SSL_FILETYPE_PEM)) <= 0 {
            this.error = HTTP_SERVER_SSL_CERT_ERROR
            return
        }
        SSL_CTX_set_default_passwd_cb_userdata(ctx, "__BAH_TODO_pss123567890")
        if SSL_CTX_use_PrivateKey_file(ctx, keyFile, noCheck(SSL_FILETYPE_PEM)) <= 0 || SSL_CTX_check_private_key(ctx) == 0 {
            this.error = HTTP_SERVER_SSL_KEY_ERROR
            return
        }

        this.socketTLS = http_socket{}

        this.socketTLS.open()

        if strlen(this.linux_interface) > 0 && this.socket.setInterface(this.linux_interface) == false {
            panic("http: error setting server's linux interface")
        } 


        if this.socketTLS.isOpened() == false {
            println("http: error opening socket")
            this.error = HTTP_SERVER_SOCKET_ERROR
            return
        }

        if this.socketTLS.listen(this.portTLS) == false {
            this.socketTLS.close()
            println("http: failed to start listening")
            this.error = HTTP_SERVER_LISTEN_ERROR
            return
        }

        globalHTTPsockets[len(globalHTTPsockets)] = this.socketTLS

        #linux {
            sa sigaction
            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = sigchld_handler
            sigaction(17, &sa, null)

            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = http_quit_handler
            sigaction(2, &sa, null)    

            memset(<ptr>&sa, 0, 152)
            sa.sa_handler = http_broken_pipe
            sigaction(noCheck(SIGPIPE), &sa, null)        
        }

        this.running = true


        // i=0; for i < this.nbThreads, i++ {
        //     async this.threadWorker()
        // }

        if this.done != null {
            async this.done()
        }

        for this.running {
            cli = this.socketTLS.accept()

            if cli <= 0 {
                continue
            }

            sock = new http_socket {
                sockfd: cli
                ssl: SSL_new(ctx)
            }
            SSL_set_fd(sock.ssl, sock.sockfd)

            async this.threadWorker(sock)
        }

        SSL_CTX_free(ctx)
        this.stop()

    }

}





//Used for making simple get request.
get(url str) http_response {
    panic("Deprecated get() call")
    r = http_response{}
    return r
}

//Used for making simple post request with variables (args) formatted as name=value.
post(url str, args []str) http_response {
    panic("Deprecated post() call")
    r = http_response{}
    return r
}

//Checks if a port is available.
//*Note: this command is very slow and may only work on unix systems with netstat and grep installed.*
isPortAvailable(port int) int {
    cmdS = intToString(port)
    cmdS.prepend("netstat -antu | grep :")
    cmd = command(cmdS.str())
    cmd.error = false
    s = cmd.run()
    if strlen(s) > 0 {
        return 0
    }
    return 1
}

//Example
// #include "http.bah"
//
//
// server(serv http_server*, connfd int) {
//
//     request = http_request(connfd)
//     response = http_response(connfd)
//
//     response.setHeader("Content-Type", "text/html")
//
//     response.write("Current path:")
//     response.write(request.path)
//
//     response.write("\nIt works!")
//     response.send()
//
// }
//
// main() {
//  
//     s = http_server{}
//     s.port = 8080
//     s.handle = server
//     s.listenAndServe()
//
// }