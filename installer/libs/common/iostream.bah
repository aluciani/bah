#include "<stdlib.h>"
#include "<stdio.h>"
#include "<dirent.h>"

#include "cBinds.bah"

#define! FILE ptr

__Bah_iostream_stdinputBuffer = ""
__Bah_iostream_stdinputBufferLength = 0

//Returns the text inputed by the user inside the terminal.
stdinput() str {
    response = ""
    nDataLength = 0
    if __Bah_iostream_stdinputBufferLength > 0 {
        response = __Bah_iostream_stdinputBuffer
        nDataLength = __Bah_iostream_stdinputBufferLength
    } else {
        buff = buffer 1025
        nDataLength = read(<ptr>0,<ptr>buff,1024)
        if nDataLength < 1024 {
            tmp = memoryAllocSTR(nDataLength+1)
            memcpy(<ptr>(<uint>tmp + strLenSize), <char*>buff, nDataLength)
            response += tmp
        } else {
            for nDataLength > 0 {
                tmp = memoryAllocSTR(nDataLength+1)
                memcpy(<ptr>(<uint>tmp + strLenSize), <char*>buff, nDataLength)
                response += tmp
                if nDataLength < 1024 {
                    trimAmm = 1024 - nDataLength
                    response = response[:len(response) - trimAmm]
                    break
                } else {
                    nDataLength = read(<ptr>0,<ptr>buff,1024)
                }
            }
        }
    }
    if response[nDataLength-1] == <char>10 {
        response = response[:len(response) - 1]
    }

    i=0; for i < nDataLength, i++ {
        if response[i] == <char>10 {
            __Bah_iostream_stdinputBuffer = response[i+1:]
            __Bah_iostream_stdinputBufferLength = nDataLength - i
            return response[:i]
        }
    }

    __Bah_iostream_stdinputBuffer = ""
    __Bah_iostream_stdinputBufferLength = 0

    return response
}

//Prints text to the terminal and adds a line return at the end.
println(s str) {
    write(<ptr>1, s+"\n", len(s)+1)
}

#define! fwrite(w ptr, s uint, f uint, hndl FILE*)
#define! fread(w ptr, s uint, f uint, hndl FILE*) int
#define! ftell(hndl FILE*) int
#define! fseek(hndl FILE*, offset uint, from uint)
#define! fputc(c char, hndl FILE*)

//A wrapper that makes file manipulation easier.
//*Note: after openning a file, you will need to close it.*
//**Warning:** fileStream can be many, many times slower than fileMap.
//So it is recommended to **use fileMap as much as possible**.
struct fileStream {
    handle: FILE*
    name: str

    //Checks if the current opened file is valid or not.
    isValid() bool {
        return this.handle != null
    }

    //Opens a file by its name.
    //The differents modes can be found [here](https://koor.fr/C/cstdio/fopen.wp).
    open(path str, mode str) {
        this.name = path
        #windows {
            if mode == "r" {
                mode = "rb"
            } else if mode == "r+" {
                mode = "rb+"
            }
        }
        this.handle = fopen(path, mode)
    }

    //Closes an opennend connection to a file.
    close() {
        if this.isValid() == false {
            return
        }
        fclose(this.handle)
        this.handle = null
    }

    //Returns the position of the file reader.
    getPos() int {
        if this.isValid() == false {
            return 0
        }
        return ftell(this.handle)
    }

    //Set the position of the file reader.
    setPos(i int) {
        if this.isValid() == false {
            return
        }
        fseek(this.handle, i, 0)
    }

    //Returns the size of a file in bytes.
    getSize() int {
        if this.isValid() == false {
            return -1
        }
        oldPos = this.getPos()
        fseek(this.handle, 0, 2)
        size int = ftell(this.handle)
        this.setPos(oldPos)
        return size
    }

    //Sets the reading cursor to the beginning of the file.
    rewind() {
        rewind(this.handle)
    }

    //Returns a char at the current reading cursor in the file and moves the reading cursor to the next char.
    getChar() char {
        c = getc(this.handle)
        return c
    }

    //Adds a character to the file.
    setChar(c char) {
        fputc(c, this.handle)
    }

    //Creates a file by name.
    createFile(path str) {
        this.open(path, "w")
        this.close()
    }

    //Writes the opened file with the specified content.
    writeFile(content str) int {
        if this.isValid() == false {
            return -1
        }

        fwrite(content, len(content), 1, this.handle)

        return 1
    }

    //Serialize a pointer and write it to a file.
    //a: the pointer to serialize
    //s: sizeof() the pointer's content
    writePtr(a ptr, s uint) {
        fwrite(a, s, 1, this.handle)
    }

    //Read a file and unserialize its content to a pointer.
    //a: the pointer to unserialize
    //s: sizeof() the pointer's content.
    readPtr(a ptr, s uint) int {
        return fread(a, s, 1, this.handle)
    }

    //Returns the content of the opened file.
    readContent() str {
        if this.isValid() == false {
            return "invalid"
        }

        sz = this.getSize()
        r str = memoryAllocSTR(sz + 1)
        fread(r, 1, sz, this.handle)
        return r
    }

    //Returns the file's content as an array of bytes (char).
    readBytes() []char {
        r = []char
        allocateArray(r, this.getSize())
        this.readPtr(cArr(r), len(r))
        return r
    }

    //Write an array of bytes (char) to a file.
    writeBytes(d []char) {
        this.writePtr(cArr(d), len(d))
    }

    _end() {
        if this.isValid() {
            println("iostream: warning, auto-closing file: '"+this.name+"'.")
            this.close()
        }
    }

}

#define! open(fn str, flags int, mode int) int
#define! close(fd int) int
#define! fstat(fd int, fs stat*)
#linux {
    #define! munmap(p ptr, l int)
}
#darwin {
    #define! munmap(p ptr, l int)
}

//A wrapper to make file direct operation, wihtout needing to write file on changes.
//**This is way faster than the fileStream** but every modification made to the returned string will be directly made to the file.
struct fileMap {
    handle: int = -1
    size:int
    p: ptr

    //To open a file inside the fileMap.
    //It returns the content of the file as str.
    open(fileName str) []char {
        #linux {
            this.handle = open(fileName, noCheck(O_RDWR), noCheck(S_IRUSR | S_IWUSR))
            sb = stat{}
            fstat(this.handle, &sb)
            this.size = sb.st_size
            this.p = mmap(0, sb.st_size, noCheck(PROT_READ | PROT_WRITE), noCheck(MAP_SHARED), this.handle, 0)
            arr = []char
            noCheck(arr->length = this->size)
            noCheck(arr->data = this->p)
            return arr
        }
        #darwin {
            this.handle = open(fileName, noCheck(O_RDWR), noCheck(S_IRUSR | S_IWUSR))
            sb = stat{}
            fstat(this.handle, &sb)
            this.size = sb.st_size
            this.p = mmap(0, sb.st_size, noCheck(PROT_READ | PROT_WRITE), noCheck(MAP_SHARED), this.handle, 0)
            arr = []char
            noCheck(arr->length = this->size)
            noCheck(arr->data = this->p)
            return arr
        }

        #windows {
            fs = fileStream{}
            fs.open(fileName, "r+")
            iv = fs.isValid()
            if iv == 1 {
                this.handle = 0
            } else {
                this.handle = -1
            }
            file = fs.readBytes()
            fs.close()
            //file str = mmap(0, sb.st_size, noCheck(PROT_READ | PROT_WRITE), noCheck(MAP_SHARED), this.handle, 0)
            return file
        }

    }

    //Check if file is valid or not.
    isValid() bool {
        return this.handle >= 0
    }

    //To close a file after you are done working on it.
    close() {
        #linux {
            if this.handle == -1 {
                return
            }
            munmap(this.p, this.size)
            close(this.handle)
        }
        #darwin {
            if this.handle == -1 {
                return
            }
            munmap(this.p, this.size)
            close(this.handle)
        }
    }
}

struct! dirent {
    d_name: char*
}

#define! opendir(path str) ptr
#define! closedir(d ptr)
#define! readdir(d ptr) dirent*

//Returns a list of all files found inside the specified directory.
listFiles(dir str) []str {
    d = opendir(dir)
    if d == null {
        return null
    }
    files = []str
    file = readdir(d)
    for file != null {
        lf = len(files)
        name = cStrToBah(file.d_name)
        if name != "." && name != ".." {
            files[lf] = name
        }
        file = readdir(d)
    }
    closedir(d)
    return files
}

#define! access(fn str, m int) int

//Checks if a file exists.
fileExists(path str) bool {
    buf stat
    return stat(path, &buf) == 0
}

isFolder(path str) bool {
    s stat
    if stat(path, &s) != 0 {
        return false
    }
    if s.st_mode & <int>noCheck(S_IFDIR) {
        return true
    }
    return false
}

#define! remove(fn str) int

//Removes a file. 'name' should be the file name, returns true if the file was deleted.
removeFile(name str) bool {
    if remove(name) == 0 {
        return true
    }
    return false
}

//Get the timestamp of the last modification of a file.
getLastModified(name str) int {
    attr stat
    stat(name, &attr)
    return attr.st_ctime
}

#define! getenv(s str) str
#define! mkdir(s str, m int) int
#define! rename(o str, n str)


#windows {
    __windows_mkdir(s str, m int) int {
        return noCheck(mkdir(s))
    }
    const mkdir = __windows_mkdir
}

//Example
// #include "iostream.bah"
// main() {
// fs = fileStream{}
// fs.open("./myFile.txt", "r")
// fileContent = fs.readContent()
// println(fileContent)
// fs.close()
// }
