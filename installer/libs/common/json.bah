#include "string.bah"
#include "iostream.bah"
#include "reflect.bah"
#include "rope.bah"


const JSON_TYPE_STRING = 0
const JSON_TYPE_INT = 1
const JSON_TYPE_FLOAT = 2
const JSON_TYPE_ARRAY = 3
const JSON_TYPE_MAP = 4

#define toJson(e reflectElement) cpstring

#define json_scan_inner(this ptr, e reflectElement, isMember bool)

//A single element of a json document.
//This can be a map, an array, an int, a float or a string.
//If the element is of type array (or map), all of its children will be contained in an array, the .children field.
struct jsonElement {
    type: int
    key: cpstring
    content: cpstring
    children: []jsonElement*

    contentFinal: bool = false
    from: int
    to: int

    //If the current element is of type map, this method is used to get a children element mapped to this key.
    get(key cpstring) jsonElement* {
        l = len(this.children)
        i=0; for i < l {
            elem = this.children[i]
            if len(elem.key) == 0 {
                i++
                continue
            }
            fc = elem.key[0]
            if fc == <char>34 {
                nk = []char
                lk = len(elem.key)
                j=1; for j < lk - 1 {
                    c = cpstringCharAt(elem.key, j)
                    nk[j-1] = c
                    j = j + 1
                }
                if arrToStr(nk) == key {
                    return elem
                }
            } else {
                if elem.key == key {
                    return elem
                }
            }
            i = i + 1
        }
        z = <ptr>0
        return z
    }

    //To get the current element as a cpstring no matter its type.
    str() cpstring {
        if this.contentFinal == false {
            this.content = this.content[this.from : this.to]
        }
        return this.content
    }


    //Used for scanning the JSON element in a var.
    scan(e reflectElement) {
        json_scan_inner(this, e, false)
    }

}
//Internal function.
json_scan_inner(thisp ptr, e reflectElement, isMember bool) {
    this jsonElement* = thisp
    if e.isStruct == true {
            i=0; for i < len(e.structLayout) {
                m = e.structLayout[i]
                m.value = m.calculateOffset(e.value)
                ov = this.get(m.name)
                if ov != null {
                    json_scan_inner(ov, m, true)
                }
                i = i + 1
            }
        } else if e.type == "int" {
            ep int* = e.value
            *ep = strToInt(this.str())
        } else if e.type == "cpstring" {
            ep cpstring* = e.value
            *ep = this.str()
        } else if e.type == "float" {
            ep float* = e.value
            *ep = strToFloat(this.str())
        } else if e.type == "bool" {
            ep bool* = e.value
            if this.str() == "1" || this.str() == "true" {
                *ep = true
            } else {
                *ep = false
            }
        } else if e.isArray == true {
            if len(this.children) == 0 {
                return
            }
            
            ae = e.arrayElem
            if ae.type == "int" {
                arr = []int
                arrPtr ptr* = e.value
                if isMember == true {
                    *arrPtr = arr
                } else {
                    arr = *arrPtr
                }
                i=0; for i < len(this.children) {
                    c = this.children[i]
                    arr[i] = strToInt(c.str())
                    i = i + 1
                }
            } else if ae.type == "float" {
                arr = []float
                arrPtr ptr* = e.value
                if isMember == true {
                    *arrPtr = arr
                } else {
                    arr = *arrPtr
                }
                i=0; for i < len(this.children) {
                    c = this.children[i]
                    arr[i] = strToFloat(c.str())
                    i = i + 1
                }
            } else if ae.type == "cpstring" {
                arr = []cpstring
                arrPtr ptr* = e.value
                if isMember == true {
                    *arrPtr = arr
                } else {
                    arr = *arrPtr
                }
                i=0; for i < len(this.children) {
                    c = this.children[i]
                    arr[i] = c.str()
                    i = i + 1
                }
            } else if ae.isStruct == true {
                arr = []ptr
                arrPtr ptr* = e.value
                if isMember == true {
                    *arrPtr = arr
                } else {
                    arr = *arrPtr
                }
                i=0; for i < len(this.children) {
                    c = this.children[i]
                    ne ptr = memoryAlloc(ae.size)
                    j=0; for j < len(ae.structLayout) {
                        m = ae.structLayout[j]
                        m.value = m.calculateOffset(ne)
                        ov = c.get(m.name)
                        if ov != null {
                            json_scan_inner(ov, m, true)
                        }
                        j = j + 1
                    }
                    arr[i] = ne
                    i = i + 1
                }
            }
        } else if strHasPrefix(e.type, "map:") {
            p mapWrapper** = e.value
            i=0; for i < len(this.children), i++ {
                c = this.children[i]
                ae = e.arrayElem
                v ptr = memoryAlloc(ae.size)
                ae.value = &v
                j=0; for j < len(ae.structLayout), j++ {
                    m = ae.structLayout[j]
                    m.value = m.calculateOffset(&v)
                    ae.structLayout[j] = m
                }
                json_scan_inner(c, *ae, true)
                k = string(c.key)
                k.trimLeft(1)
                k.trimRight(1)
                if strCount(ae.type, "*") || ae.type == "ptr" || ae.type == "cpstring" || strHasPrefix(ae.type, "[]") || strHasPrefix(ae.type, "map:") {
                    m = *p
                    m.set(k.str(), v)
                } else {
                    m = *p
                    m.set(k.str(), &v)
                }
            }
        }
}

jError = "" //Inner variable containing the last parsing error.

//Internal function called by parseJson().
parseJson_inner(s cpstring, ip int*, l int) jsonElement* {
    jError = ""
    i = *ip

    for i < l, i++ {
        if isSpace(s[i]) == false {
            break
        }
    }
    
    j = new jsonElement {
        content: s
        from: i
        to: l
    }

    if s[i] == '[' {
        j.type = JSON_TYPE_ARRAY
        i++
        for i < l, i++ {
            if isSpace(s[i]) == false {
                break
            }
        }
        if s[i] != ']' {
            for i < l, i++ {
                child = parseJson_inner(s, &i, l)
                if child == null {
                    return null
                }
                j.children[len(j.children)] = child
                for i < l, i++ {
                    if isSpace(s[i]) == false {
                        break
                    }
                }

                if s[i] != ',' {
                    if s[i] != ']' {
                        jError = "json: expected array separator (got: "+charToString(s[i])+") (pos: "+intToStr(i)+")"
                        return null
                    }
                    i++
                    break
                }

                for i < l, i++ {
                    if isSpace(s[i]) == false {
                        break
                    }
                }

            }
        } else {
            i++
        }
        j.to = i
    } else if s[i] == '{' {
        j.type = JSON_TYPE_MAP
        i++
        for i < l, i++ {
            if isSpace(s[i]) == false {
                break
            }
        }
        if s[i] != '}' {
            for i < l, i++ {
                for i < l, i++ {
                    if isSpace(s[i]) == false {
                        break
                    }
                }
                if s[i] != '"' {
                    jError = "json: expected string as map key (pos: "+intToStr(i)+")"
                    return null
                }
                i++
                ns = i
                for i < l, i++ {
                    if s[i] == '"' && s[i-1] != <char>92 {
                        break
                    }
                }
                name = s[ns:i]
                i++

                for i < l, i++ {
                    if isSpace(s[i]) == false {
                        break
                    }
                }

                if s[i] != ':' {
                    jError = "json: expected : between key and value (got: "+intToStr(<int>s[i])+") (pos: "+intToStr(i)+")"
                    return null
                }

                i++

                child = parseJson_inner(s, &i, l)
                if child == null {
                    return null
                }
                child.key = name
                j.children[len(j.children)] = child
                
                for i < l, i++ {
                    if isSpace(s[i]) == false {
                        break
                    }
                }

                if s[i] != ',' {
                    if s[i] != '}' {
                        jError = "json: expected map separator (pos: "+intToStr(i)+")"
                        return null
                    }
                    i++
                    break
                }
            }
        } else {
            i++
        }
        j.to = i
    } else if s[i] == '"' {
        j.type = JSON_TYPE_STRING
        i++
        j.from = i
        mem = []char
        for i < l, i++ {
            if s[i] == '"' {
                break
            }
            if s[i] == <char>92 {
                j.contentFinal = true
                if len(mem) == 0 {
                    mem = strToArr(s[j.from:i])
                    if s[i+1] == 'r' {
                        mem[len(mem)] = <char>13
                    } else if s[i+1] == 'n' {
                        mem[len(mem)] = <char>10
                    } else {
                        mem[len(mem)] = s[i+1]
                    }
                }
                i++
                continue
            }
            if len(mem) != 0 {
                mem[len(mem)] = s[i]
            }
        }
        if len(mem) != 0 {
            j.content = arrToStr(mem)
        }
        j.to = i
        i++
    } else if isNumber(s[i]) || s[i] == '-' {
        j.type = JSON_TYPE_INT
        i++
        for i < l, i++ {
            if isNumber(s[i]) == false {
                break
            }
            if s[i] == '.' {
                j.type = JSON_TYPE_FLOAT
            }
        }
        j.to = i
    } else {
        si = i
        for i < l, i++ {
            if isLetter(s[i]) == false {
                break
            }
        }
        s = s[si:i]
        if s == "true" || s == "false" || s == "null" {
            j.type = JSON_TYPE_INT
            j.content = s
            j.contentFinal = true
        }
    }

    *ip = i
    return j
}

//To parse a json document.
//This will return a pointer to the main element.
//This new version of parseJson() uses lazy parsing.
parseJson(s cpstring) jsonElement* {
    l = len(s)
    i = 0
    return parseJson_inner(s, &i, l)
}

//Returns weither a char is a valid string json char.
json_isPrintable(c uint32) bool {
    if c < 32 || c > 255 {
        return false
    }
    return c != 127 && c != 129 && c != 141 && c != 143 && c != 144 && c != 157
}

//Used for escaping strings for json marshalling.
jsonEscapeStr(s cpstring) cpstring {
    if s == null {
        return ""
    }
    r = strBuilder{}
    l = len(s)

    i=0; for i < l, i++ {
        c = s[i]
        if c == <char>34 {
            r.append(<char>92)
        } else if c == <char>10 {
                r.append(<char>92)
                r.append('n')
                continue
        } else if c == <char>13 {
                r.append(<char>92)
                r.append('r')
                continue
        }
        if json_isPrintable(<uint32>c) == false {
            if <byte>c == <byte>195 {
                r.append(c)
                r.append(s[i+1])
                i++
            }
            continue
        }
        r.append(c)
    }

    return r.str()
}

//Function used by oldToJson() to convert a var to json string.
//*Note: this is an internal function*
oldToJson__inner(e reflectElement, isMember bool, tabs int) cpstring {
    v ptr* = e.value
    if e.value == null {
        if e.type == "int" || e.type == "float" {
            return "0"
        }
        if e.type == "bool" {
            return "false"
        }
        if e.type == "ptr" || e.type == "cpstring" || strCount(e.type, "*") != 0 {
            return "null"
        }
    }
    if e.isStruct == true {
        tabs = tabs + 1
        tabsStr = ""
        i=0; for i < tabs {
            tabsStr = tabsStr + "\t"
            i = i + 1
        }
        s = "{\n"
        i=0; for i < len(e.structLayout) {
            m = e.structLayout[i]
            i = i + 1
            m.value = m.calculateOffset(e.value)
            if i < len(e.structLayout) {
                s = s + tabsStr+"\""+m.name+"\": "+oldToJson__inner(m, true, tabs)+",\n"
            } else {
                s = s + tabsStr+"\""+m.name+"\": "+oldToJson__inner(m, true, tabs)+"\n"
            }
        }
        tabs = tabs - 1
        tabsStr = ""
        i=0; for i < tabs {
            tabsStr = tabsStr + "\t"
            i = i + 1
        }
        s = s + tabsStr+"}"
        return s
    } else if e.type == "int" {
        ip int* = e.value
        return intToStr(*ip)
    } else if e.type == "float" {
        fp float* = e.value
        return floatToStr(*fp)
    } else if e.type == "cpstring" {
        if isMember == false {
            s = e.value
            return "\""+jsonEscapeStr(s)+"\""
        } else {
            sp cpstring* = e.value
            s cpstring = *sp
            return "\""+jsonEscapeStr(s)+"\""
        }
    } else if e.type == "bool" {
        bp bool* = e.value
        if *bp == true {
            return "true"
        }
        return "false"
    } else if e.isArray == true {
        s = "["
        ae = e.arrayElem
        if e.value == null {
            return "null"
        }
        if ae.type == "int" {
            arr = []int
            arrPtr ptr* = e.value
            arr = *arrPtr
            i=0; for i < len(arr) {
                s = s + intToStr(arr[i])
                i = i + 1
                if i < len(arr) {
                    s = s + ","
                }
            }
        } else if ae.type == "float" {
            arr = []float
            arrPtr ptr* = e.value
            arr = *arrPtr
            i=0; for i < len(arr) {
                s = s + floatToStr(arr[i])
                i = i + 1
                if i < len(arr) {
                    s = s + ","
                }
            }
        } else if ae.type == "cpstring" {
            arr = []cpstring
            arrPtr ptr* = e.value
            arr = *arrPtr
            s = s + "\n"
            i=0; for i < len(arr) {
                s = s + "\""+jsonEscapeStr(arr[i])+"\""
                i = i + 1
                if i < len(arr) {
                    s = s + ",\n"
                } else {
                    s = s + "\n"
                }
            }
        } else if ae.isStruct == true {
            arr = []ptr
            if isMember == false {
                arr = e.value
            } else {
                ev ptr* = e.value
                arr = *ev
            }
            
            i=0; for i < len(arr) {
                arrElem = arr[i]
                ae.value = arrElem
                j=0; for j < len(ae.structLayout) {
                    m = ae.structLayout[j]
                    m.value = m.calculateOffset(ae.value)
                    ae.structLayout[j] = m
                    j = j + 1
                }
                s = s + oldToJson__inner(*ae, false, tabs)
                i = i + 1
                if i < len(arr) {
                    s = s + ",\n"
                } else {
                    s = s + "\n"
                }
            }
        }
        s = s + "]"
        return s
    }
    return "0"
}

//Old algorithm to convert a var into json.
//This function does things the wrong way.
oldToJson(e reflectElement) cpstring {
    return oldToJson__inner(e, false, 0)
}

//Converting a var into json.
//Note that you need to pass a pointer to the var that you want to convert to json:
// s cpstring = "test"
// toJson(&s)
// If the type is already a pointer, this step is not needed.
toJsonRope(e reflectElement) rope* {
    l = len(e.type)

    if e.isArray == false {
        ol = l
        for l >= 2 && e.type[l-1] == '*' && e.type[l-2] == '*', l-- {
            if e.value == null {
                return rope("0")
            }
            v ptr* = e.value
            e.value = *v
        }
        if l != ol {
            e.type = e.type[:l]
        }
    }

    if e.value == null {
        return rope("0")
    }

    if e.isStruct == true {
        s = rope("{")
        i=0; for i < len(e.structLayout), i++ {
            m = e.structLayout[i]
            v ptr = e.value
            if m.isArray == true {
                nae = new reflectElement
                naep = m.arrayElem
                *nae = *naep
                nae.type += "*"
                m.arrayElem = nae
            } else if m.type[len(m.type)-1] != '*' {
                m.type += "*"
            }
            m.value = m.calculateOffset(e.value)
            s += rope("\""+m.name+"\": ") + toJsonRope(m)
            if i+1 < len(e.structLayout) {
                s += rope(", ")
            }
        }
        s += rope("}")
        return s
    }
    
    if e.isArray == true {
        s = rope("[")
        arrp ptr* = e.value
        arr = <[]ptr>*arrp
        if arr == null {
            return rope("[]")
        }
        base = cArr(arr)
        l = len(arr)
        es int = noCheck(arr->elemSize)
        aep = e.arrayElem
        ae = *aep

        if ae.type[len(ae.type)-1] != '*' && ae.isArray == false {
            ae.type += "*"
        }
        i=0; for i < l, i++ {
            m = ae
            m.value = <ptr>(<int>base + es * i)
            s += toJsonRope(m)
            if i+1 < l {
                s += rope(", ")
            }
        }
        s += rope("]")
        return s
    }
    
    if e.type == "int*" || e.type == "int32*" {
        j int* = e.value
        return rope(intToStr(*j))
    }

    if e.type == "cpstring*" {
        s cpstring* = e.value
        if s == null {
            return rope("\"\"")
        }
        return rope("\""+jsonEscapeStr(*s)+"\"")
    }

    if e.type == "float*" || e.type == "float32*" {
        f float* = e.value
        return rope(floatToStr(*f))
    }
    
    if e.type == "uint*" || e.type == "uint32*" {
        uj uint* = e.value
        return rope(intToStr(*uj))
    }

    if e.type == "char*" {
        c char* = e.value
        return rope("\""+charToString(*c)+"\"")
    }

    if e.type == "bool*" {
        b bool* = e.value
        if *b == true {
            return rope("true")
        }
        return rope("false")
    }

    return rope("null")
}

toJson(e reflectElement) cpstring {
    if e.isArray == false && e.type[len(e.type)-1] != '*' {
        panic("toJson("+e.name+") of type "+e.type+" but a pointer is required, try: toJson(&"+e.name+").")
    }
    return toJsonRope(e).toStr()
}