#include "string.bah"
#include "iostream.bah"
#include "reflect.bah"


const JSON_TYPE_STRING = 0
const JSON_TYPE_INT = 1
const JSON_TYPE_FLOAT = 2
const JSON_TYPE_ARRAY = 3
const JSON_TYPE_MAP = 4

    #define toJson(e reflectElement) cpstring


//A single element of a json document.
//This can be a map, an array, an int, a float or a string.
//If the element is of type array (or map), all of its children will be contained in an array, the .children field.
struct jsonElement {
    type: int
    key: cpstring
    content: cpstring
    children: []jsonElement*

    //If the current element is of type map, this method is used to get a children element mapped to this key.
    map(key cpstring) jsonElement* {
        l = len(this.children)
        i=0; for i < l {
            elem = this.children[i]
            fc = cpstringCharAt(elem.key,0)
            if fc == <char>34 {
                nk = []char
                lk = strlen(elem.key)
                j=1; for j < lk - 1 {
                    c = cpstringCharAt(elem.key, j)
                    nk[j-1] = c
                    j = j + 1
                }
                if arrAsStr(nk) == key {
                    return elem
                }
            } else {
                if elem.key == key {
                    return elem
                }
            }
            i = i + 1
        }
        z = <ptr>0
        return z
    }

    //To get the current element as a cpstring no matter its type.
    str() cpstring {
        ctn = this.content
        return ctn
    }


    //Used for scanning the JSON element in a var.
    scan(e reflectElement) {
        if e.isStruct == true {
            i=0; for i < len(e.structLayout) {
                m = e.structLayout[i]
                ov = this.map(m.name)
                if ov != null {
                    ov.scan(m)
                }
                i = i + 1
            }
        } else if e.type == "int" {
            ep int* = e.value
            *ep = strToInt(this.content)
        } else if e.type == "cpstring" {
            ep cpstring* = e.value
            *ep = memoryAlloc(strlen(this.content))
            strcpy(*ep, this.content)
        } else if e.type == "float" {
            ep float* = e.value
            *ep = strToFloat(this.content)
        } else if e.type == "bool" {
            ep bool* = e.value
            if this.content == "1" || this.content == "true" {
                *ep = true
            } else {
                *ep = false
            }
        } else if e.isArray == true {
            ae = e.arrayElem
            if ae.type == "int" {
                arr = []int
                arrPtr ptr* = e.value
                arr = *arrPtr
                i=0; for i < len(this.children) {
                    c = this.children[i]
                    arr[i] = strToInt(c.content)
                    i = i + 1
                }
            } else if ae.type == "float" {
                arr = []float
                arrPtr ptr* = e.value
                arr = *arrPtr
                i=0; for i < len(this.children) {
                    c = this.children[i]
                    arr[i] = strToFloat(c.content)
                    i = i + 1
                }
            } else if ae.type == "cpstring" {
                arr = []cpstring
                arrPtr ptr* = e.value
                arr = *arrPtr
                i=0; for i < len(this.children) {
                    c = this.children[i]
                    arr[i] = memoryAlloc(strlen(c.content))
                    strcpy(arr[i], c.content)
                    i = i + 1
                }
            } else if ae.isStruct == true {
                arr = []ptr
                arrPtr ptr* = e.value
                arr = *arrPtr
                i=0; for i < len(this.children) {
                    c = this.children[i]
                    ne ptr = memoryAlloc(ae.size)
                    j=0; for j < len(ae.structLayout) {
                        m = ae.structLayout[j]
                        m.value = m.calculateOffset(ne)
                        ov = c.map(m.name)
                        if ov != null {
                            ov.scan(m)
                        }
                        j = j + 1
                    }
                    arr[i] = ne
                    i = i + 1
                }
            }
        }

    }

}

//To parse a json document.
//This will return a pointer to the main element.
parseJson(s cpstring) jsonElement* {
    jsonElem = new jsonElement
    lenS = strlen(s)

    i=0; for i < lenS {
        if isSpace(cpstringCharAt(s, i)) == 0 {
            break
        }
        i = i + 1
    }

    fc = cpstringCharAt(s, i)
    if fc == '[' {
        jsonElem.type = JSON_TYPE_ARRAY
    } else if fc == '{' {
        jsonElem.type = JSON_TYPE_MAP
    } else if fc == <char>34 {
        jsonElem.type = JSON_TYPE_STRING
        ns = []char
        i = i + 1
        for i < lenS - 1 {
            ns[len(ns)] = cpstringCharAt(s,i)
            i = i + 1
        }
        jsonElem.content = arrToStr(ns)
    } else if isNumber(fc) {
        isFloat = false
        for i < lenS {
            if cpstringCharAt(s,i) == '.' {
                isFloat = true
                break
            }
            i = i + 1
        }

        if isFloat == true {
            jsonElem.type = JSON_TYPE_FLOAT
        } else {
            jsonElem.type = JSON_TYPE_INT
        }
        jsonElem.content = s
    } else {
        jsonElem.type = JSON_TYPE_STRING
        jsonElem.content = s
    }

    if jsonElem.type == JSON_TYPE_ARRAY {
        i = i + 1

        trim = 1
        j=lenS-1; for j >= 0 {
            c = cpstringCharAt(s, j)
            if isSpace(c) {
                trim = trim + 1
            } else {
                break
            }
            j = j - 1
        }

        for i < lenS - 1 {
            c = cpstringCharAt(s, i)
            if isSpace(c) == 0 {
                break
            }
            i = i + 1
        }
        currentElem = []char
        currentBracks = 0
        currentBraces = 0
        currentQuotes = 0
        elemIndex = 0
        for i < lenS - trim {
            c = cpstringCharAt(s, i)
            if c == <char>34 {
                if currentQuotes == 0 {
                    currentQuotes = 1
                } else {
                    currentQuotes = 0
                }
            }else if c == '[' {
                currentBracks = currentBracks + 1
            } else if c == ']' {
                currentBracks = currentBracks - 1
            } else if c == '{' {
                currentBraces = currentBraces + 1
            } else if c == '}' {
                currentBraces = currentBraces - 1
            }
            total = currentBracks + currentBraces + currentQuotes
            if total > 0 {
                currentElem[len(currentElem)] = c
                i = i + 1
                continue
            }
            if c == ',' {
                jsonElem.children[elemIndex] = parseJson(arrToStr(currentElem))
                clear(currentElem)
                elemIndex = elemIndex + 1
            } else {
                if isSpace(c) {
                    i = i + 1
                    continue
                }
                currentElem[len(currentElem)] = c
            }
            i = i + 1
        }
        jsonElem.children[elemIndex] = parseJson(arrToStr(currentElem))

    } else if jsonElem.type == JSON_TYPE_MAP {
        i = i + 1
        trim = 1
        j=lenS-1; for j >= 0 {
            c = cpstringCharAt(s, j)
            if isSpace(c) {
                trim = trim + 1
            } else {
                break
            }
            j = j - 1
        }
        for i < lenS - 1 {
            c = cpstringCharAt(s, i)
            if isSpace(c) == 0 {
                break
            }
            i = i + 1
        }
        currentElem = []char
        currentKey = []char
        isVal = 0
        currentBracks = 0
        currentBraces = 0
        currentQuotes = 0
        elemIndex = 0
        for i < lenS-trim {
            c = cpstringCharAt(s,i)
            if c == <char>34 {
                if currentQuotes == 0 {
                    currentQuotes = 1
                } else {
                    currentQuotes = 0
                }
            }else if c == '[' {
                currentBracks = currentBracks + 1
            } else if c == ']' {
                currentBracks = currentBracks - 1
            } else if c == '{' {
                currentBraces = currentBraces + 1
            } else if c == '}' {
                currentBraces = currentBraces - 1
            }
            total = currentBracks + currentBraces + currentQuotes
            if total > 0 {
                if isVal == 1 {
                    currentElem[len(currentElem)] = c
                } else {
                    currentKey[len(currentKey)] = c
                }
                i = i + 1
                continue
            }
            if c == ':' {
                isVal = 1
            }else if c == ',' {
                elem = parseJson(arrToStr(currentElem))
                elem.key = arrToStr(currentKey)
                clear(currentElem)
                clear(currentKey)
                isVal = 0
                jsonElem.children[elemIndex] = elem
                elemIndex = elemIndex + 1
            } else {
                if isSpace(c) {
                    i = i + 1
                    continue
                }
                if isVal == 1 {
                    currentElem[len(currentElem)] = c
                } else {
                    currentKey[len(currentKey)] = c
                }
            }
            i = i + 1
        }
        elem = parseJson(arrToStr(currentElem))
        elem.key = arrToStr(currentKey)
        jsonElem.children[elemIndex] = elem
    }

    return jsonElem
}

//Function used by toJson() to convert a var to json string.
//*Note: this is an internal function*
toJson__inner(e reflectElement, isMember bool, tabs int) cpstring {
    v ptr* = e.value
    if *v == null {
        return "null"
    }
    if e.isStruct == true {
        tabs = tabs + 1
        tabsStr = ""
        i=0; for i < tabs {
            tabsStr = tabsStr + "\t"
            i = i + 1
        }
        s = "{\n"
        i=0; for i < len(e.structLayout) {
            m = e.structLayout[i]
            i = i + 1
            if i < len(e.structLayout) {
                s = s + tabsStr+"\""+m.name+"\": "+toJson__inner(m, true, tabs)+",\n"
            } else {
                s = s + tabsStr+"\""+m.name+"\": "+toJson__inner(m, true, tabs)+"\n"
            }
        }
        tabs = tabs - 1
        tabsStr = ""
        i=0; for i < tabs {
            tabsStr = tabsStr + "\t"
            i = i + 1
        }
        s = s + tabsStr+"}"
        return s
    } else if e.type == "int" {
        ip int* = e.value
        return intToStr(*ip)
    } else if e.type == "float" {
        fp float* = e.value
        return floatToStr(*fp)
    } else if e.type == "cpstring" {
        if isMember == false {
            s = string(e.value)
            s.replace("\"", "\\\"")
            s.replace("\n", "\\\n")
            return "\""+s.str()+"\""
        } else {
            sp cpstring* = e.value
            s = string(*sp)
            s.replace("\"", "\\\"")
            s.replace("\n", "\\\n")
            return "\""+s.str()+"\""
        }
    } else if e.isArray == true {
        s = "["
        ae = e.arrayElem
        if ae.type == "int" {
            arr = []int
            arrPtr ptr* = e.value
            arr = *arrPtr
            i=0; for i < len(arr) {
                s = s + intToStr(arr[i])
                i = i + 1
                if i < len(arr) {
                    s = s + ","
                }
            }
        } else if ae.type == "float" {
            arr = []float
            arrPtr ptr* = e.value
            arr = *arrPtr
            i=0; for i < len(arr) {
                s = s + floatToStr(arr[i])
                i = i + 1
                if i < len(arr) {
                    s = s + ","
                }
            }
        } else if ae.type == "cpstring" {
            arr = []cpstring
            arrPtr ptr* = e.value
            arr = *arrPtr
            s = s + "\n"
            i=0; for i < len(arr) {
                s = s + arr[i]
                i = i + 1
                if i < len(arr) {
                    s = s + ",\n"
                } else {
                    s = s + "\n"
                }
            }
        } else if ae.isStruct == true {
            arr = []ptr
            arrPtr ptr* = e.value
            arr = *arrPtr
            i=0; for i < len(arr) {
                arrElem = arr[i]
                ae.value = arrElem
                j=0; for j < len(ae.structLayout) {
                    m = ae.structLayout[j]
                    m.value = m.calculateOffset(ae.value)
                    ae.structLayout[j] = m
                    j = j + 1
                }
                s = s + toJson__inner(*ae, false, tabs)
                i = i + 1
                if i < len(arr) {
                    s = s + ",\n"
                } else {
                    s = s + "\n"
                }
            }
        }
        s = s + "]"
        return s
    }
    return ""
}

//Converting a var into json.
toJson(e reflectElement) cpstring {
    return toJson__inner(e, false, 0)
}

//Example
// #include "iostream.bah"
// #include "json.bah"
// struct user {
//     name: cpstring
//     id: int
//     avatar: cpstring
//     password: cpstring
// }
// struct post {
//     title: cpstring
//     content: cpstring
//     author: user
//     score: float
//     identified: []int
// }
// main(args []cpstring) int {
//     //Our JSON test string
//     doc = "
//     {
//         \"title\": \"Test\",
//         \"content\": \"This is a test post\",
//         \"author\": {
//             \"name\": \"Alois\",
//             \"id\": 543,
//             \"avatar\": \"cdn.example.com/avatar.jpeg\",
//         },
//         \"identified\": [324, 456, 875],
//         \"score\": 43.65
//     }"
//     //parsing out test string
//     root = parseJson(doc)
//     //sacanning it to the post1 structure
//     post1 = new post
//     root.scan(post1)
//     //converting our post1 structure into json
//     postStr = toJson(post1)
//     //parsing the json of out test1 structure
//     post2Json = parseJson(postStr)
//     //scanning it to our post2 structure
//     post2 = new post
//     post2Json.scan(post2)
//     //converting our post2 structure into json and printting it
//     println(toJson(post2))
//     //fetching post title
//     titleElem = root.map("title")
//     //printing the title
//     println("The post is titled: "+titleElem.content)
//     return 0
// }