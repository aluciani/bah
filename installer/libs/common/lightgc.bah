#include "nativeMem.bah"

#include "memhelper.c"
#define! stackbase int

#define! pthread_mutex_t int
#define! pthread_t int
#define! pthread_cond_t int
#define! pthread_cond_init(cond pthread_cond_t*, attr int) int
#define! pthread_cond_signal(cond pthread_cond_t*) int
#define! pthread_cond_destroy(cond pthread_cond_t*) int
#define! pthread_cond_wait(cond pthread_cond_t*, mut pthread_mutex_t*) int
#define! pthread_mutex_init(lock pthread_mutex_t*, m int)
#define! pthread_mutex_lock(lock pthread_mutex_t*)
#define! pthread_mutex_unlock(lock pthread_mutex_t*)
#define! pthread_mutex_destroy(lock pthread_mutex_t*)
#define! pthread_cond_init(cond pthread_cond_t*, attr int) int
#define! pthread_cond_signal(cond pthread_cond_t*) int
#define! pthread_cond_destroy(cond pthread_cond_t*) int
#define! pthread_cond_wait(cond pthread_cond_t*, mut pthread_mutex_t*) int

#define! __builtin_frame_address(n int) int
#define! stack_pointer() int
#define! getBSSend() int
#define! getBSSbeg() int

struct memgcPtr {
    size: uint
    marked: bool = false
    noScan: bool = false
    left: memgcPtr*
    right: memgcPtr*
    parent: memgcPtr*
}

#define! memcpy(dest ptr, src ptr, s int)

#define removeNotMarked(p memgcPtr*)

struct memgcPtrWrapper {
    len: uint = 0
    base: memgcPtr
    lock: pthread_mutex_t
    scanCond: pthread_cond_t

    heapMax: int
    heapMin: int
    
    stackBase: ptr
    stackEnd: ptr

    bssBase: ptr
    bssEnd: ptr

    add(p memgcPtr*) {
        p.marked = true
        this.len++
        rp int = <int>p + sizeof(memgcPtr)

        if rp > this.heapMax {
            this.heapMax = rp
        }

        e = &this.base
        for e != null {
            if p > e {
                if e.right == null {
                    p.parent = e
                    e.right = p
                    break
                }
                e = e.right
            }
            if p < e {
                if e.left == null {
                    p.parent = e
                    e.left = p
                    break
                }
                e = e.left
            }
        }
        
    }

    update(op memgcPtr*, p memgcPtr*) {
        if op == p {
            return
        }
        p.marked = true
        if p.parent.right == p {
            p.parent.right = null
        } else if p.parent.left == p {
            p.parent.left = null
        }

        if p.left != null {
            this.add(p.left)
            p.left = null
        }
        if p.right != null {
            this.add(p.right)
            p.right = null
        }

        this.len--
        this.add(p)
    }

    remove(p memgcPtr*) {
        this.len--
        if p.parent.left == p {
            p.parent.left = null
        } else if p.parent.right == p {
            p.parent.right = null
        }
        if p.left != null {
            this.len--
            this.add(p.left)
        }
        if p.right != null {
            this.len--
            this.add(p.right)
        }
    }

    exists(p memgcPtr*) bool {
        e = &this.base
        for e != null {
            if p > e {
                if e.right == p {
                    return true
                }
                e = e.right
            }
            if p < e {
                if e.left == p {
                    return true
                }
                e = e.left
            }
        }
        return false
    }

    scanHeap(p memgcPtr*) {
        if this.exists(p) == false {
            return
        }
        if p.noScan {
            tmp ptr = <int>p + sizeof(memgcPtr)
            p.marked = true
            return
        }
        
        tmp ptr = <int>p + sizeof(memgcPtr)
        p.marked = true
        to ptr = <int>p + p.size + sizeof(memgcPtr)
        sp char* = <int>p + sizeof(memgcPtr)
        for <int>sp < <int>to, sp++ {
            pl int* = sp
            v = *pl
            if v != 0 && v >= <int>this.heapMin && v <= this.heapMax {
                this.scanHeap(<memgcPtr*>(<int>v - sizeof(memgcPtr)))
            }
        }

    }

    processPtrs(ptrs ptr*, l int) {
        //scan heap (from pointers ptrs[])
        i=0; for i < l, i++ {
            pl = <memgcPtr**>(<int>ptrs + i * sizeof(ptr))
            pi = *pl
            p = <memgcPtr*>(<int>pi - sizeof(memgcPtr))
            this.scanHeap(p)
        }

    }

    scanBSS() {
        to ptr = this.bssEnd
        sp char* = this.bssBase
        for <int>sp < <int>to, sp++ {
            pl int* = sp
            v = *pl
            if v != 0 && v >= <int>this.heapMin && v <= this.heapMax {
                this.scanHeap(<memgcPtr*>(<int>v - sizeof(memgcPtr)))
            }
        }
    }

    scan() {
        this.bssBase = getBSSbeg() - 8
        this.bssEnd = getBSSend() + sizeof(memgcPtr)
        buff = malloc(200 * sizeof(ptr))
        for 1==1 {
            usleep(10000)
            pthread_mutex_lock(&this.lock)
            pthread_cond_wait(&this.scanCond, &this.lock)
            //scan BSS
            this.scanBSS()

            ind = 0
            sp int = this.stackBase
            end = <int>this.stackEnd
            //scan stack
            for sp < end, sp++ {
                p int* = sp
                v = *p
                if v != 0 && v >= <int>this.heapMin && v <= this.heapMax {
                    if ind == 200 {
                        this.processPtrs(buff, ind)
                        ind = 0
                    }
                    place = <ptr*>(<int>buff + ind * sizeof(ptr))
                    *place = v
                    ind++
                }
            }
            this.processPtrs(buff, ind)

            this.base.marked = true
            removeNotMarked(&this.base)
            pthread_mutex_unlock(&this.lock)
        }
    }

}


memgcPtrs = memgcPtrWrapper{}

removeNotMarked(p memgcPtr*) {
    if p.left != null {
        removeNotMarked(p.left)
    }
    if p.right != null {
        removeNotMarked(p.right)
    }
    if p.marked == false {
        memgcPtrs.remove(p)
        tmp = <int>p + sizeof(memgcPtr)
        free(p)
    } else {
        p.marked = false
    }
}


#define! __BAH__main(args []cpstring) int

mainWrapper(args []cpstring) {
    memgcPtrs.stackEnd = stack_pointer()
    r =__BAH__main(args)
    this = &memgcPtrs    
    exit(r)
}

#define! __BAH_init()


initiateMemory(args []cpstring) {
    memgcPtrs.heapMax = memgcPtrs.heapMin
    noCheck(setvbuf(stdout, NULL, _IONBF, 0))

    sc pthread_cond_t
    pthread_cond_init(&sc, 0)
    memgcPtrs.scanCond = sc

    mut pthread_mutex_t
    pthread_mutex_init(&mut, 0)
    memgcPtrs.lock = mut

    __BAH_init()
    min = malloc(1)
    if memgcPtrs.heapMin == 0 {
        memgcPtrs.heapMin = min
    }
    free(min)

    mt pthread_t
    pthread_create(&mt, null, memgcPtrs.scan, &memgcPtrs)

    mainWrapper(args)

}

memoryAlloc(s int) ptr {
    this = &memgcPtrs
    pthread_mutex_lock(&this.lock)
    memgcPtrs.stackBase = stack_pointer()
    p memgcPtr* = malloc(s + sizeof(memgcPtr))
    memset(p, 0, s + sizeof(memgcPtr))
    p.size = s
    p.noScan = false
    memgcPtrs.add(p)
    rp = <ptr>(<int>p + sizeof(memgcPtr))
    pthread_mutex_unlock(&this.lock)
    pthread_cond_signal(&this.scanCond)
    return rp
}

memoryAllocSTR(s int) cpstring {
    this = &memgcPtrs
    pthread_mutex_lock(&this.lock)
    memgcPtrs.stackBase = stack_pointer()
    p memgcPtr* = malloc(s + sizeof(memgcPtr) + 4)
    memset(p, 0, sizeof(memgcPtr))
    b = <char*>(<int>p + sizeof(memgcPtr) + s - 1)
    *b = null
    p.size = s + 4
    p.noScan = true
    memgcPtrs.add(p)
    st = <cpstring>(<int>p + sizeof(memgcPtr))
    l uint32* = st
    *l = s-1
    pthread_mutex_unlock(&this.lock)
    pthread_cond_signal(&this.scanCond)
    return st
}



memoryRealloc(o ptr, s int) ptr {
    this = &memgcPtrs
    pthread_mutex_lock(&this.lock)
    memgcPtrs.stackBase = stack_pointer()
    if o == null {
        pthread_mutex_unlock(&this.lock)
        return memoryAlloc(s)
    }
    p = <memgcPtr*>(<int>o - sizeof(memgcPtr))
    memgcPtrs.remove(p)
    os = p.size
    p.size = s
    np memgcPtr* = realloc(p, s + sizeof(memgcPtr))
    np.left = null
    np.right = null
    memgcPtrs.add(np)
    memset(<ptr>(<int>np + os + sizeof(memgcPtr)), null, s - os - 1)
    pthread_mutex_unlock(&this.lock)
    pthread_cond_signal(&this.scanCond)
    return <ptr>(<int>np + sizeof(memgcPtr))
} 
