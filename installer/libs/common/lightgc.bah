#include "nativeMem.bah"

#include "<sys/types.h>"
#include "<unistd.h>"
#include "<sys/syscall.h>"

//include once, not in imports

#main {
    #include "memhelper.c"
}

#define! stackbase int

#cLib "O0"

#warning "lightGC is still very experimental! (with -noImports for now)"

#define! pthread_mutex_t int
#define! pthread_t int
#define! pthread_cond_t int
#define! pthread_attr_t int
#define! pthread_cond_init(cond pthread_cond_t*, attr pthread_attr_t*) int
#define! pthread_cond_signal(cond pthread_cond_t*) int
#define! pthread_cond_destroy(cond pthread_cond_t*) int
#define! pthread_cond_wait(cond pthread_cond_t*, mut pthread_mutex_t*) int
#define! pthread_mutex_init(lock pthread_mutex_t*, m int)
#define! pthread_mutex_lock(lock pthread_mutex_t*)
#define! pthread_mutex_unlock(lock pthread_mutex_t*)
#define! pthread_mutex_destroy(lock pthread_mutex_t*)
#define! pthread_cond_init(cond pthread_cond_t*, attr pthread_attr_t*) int
#define! pthread_cond_signal(cond pthread_cond_t*) int
#define! pthread_cond_destroy(cond pthread_cond_t*) int
#define! pthread_cond_wait(cond pthread_cond_t*, mut pthread_mutex_t*) int
#define! pthread_attr_init(attr pthread_attr_t *) int
#define! pthread_attr_setstack(attr pthread_attr_t*, stck ptr, size int)
#define! pthread_getthreadid_np() int

#define! qsort(arr ptr, elementCount uint, elementSize uint, fn ptr)
#define! bsearch(key ptr, base ptr, elementCount uint, elementSize uint, fn ptr) ptr

#define! __builtin_frame_address(n int) int
#define! stack_pointer() int
#define! getBSSend() int
#define! getBSSbeg() int

struct lightGCptr {
    size: int
    tracked: bool
    p: ptr
    rooted: char
}

_lgc_sort_lightGCptr(ap ptr, bp ptr) int {
    if <uint>(<lightGCptr*>ap).p < <uint>(<lightGCptr*>bp).p {
        return 1
    }

    return -1
}

struct lightGC {
    bssStart: uint
    bssEnd: uint

    stackStart: uint
    lastStackEnd: uint

    stopInterval: int

    maxPtr: uint
    minPtr: uint
    memUsed: uint

    currentPass: int
    numberPass: int

    mainThread: int

    list: lightGCptr*
    listLength: uint
    listRealLength: uint
    mut: pthread_mutex_t

    allocSinceCheck: int = 0

    updateBounds(p ptr) {
        if <uint>p < this.minPtr || this.minPtr == 0 {
            this.minPtr = <uint>p
        }

        if <uint>p > this.maxPtr {
            this.maxPtr = <uint>p
        }
    }

    //will allocate and track pointer
    allocate(s uint, tracked bool, rooted bool) ptr {
        p = malloc(s)
        this.memUsed += s
        this.updateBounds(p)
        

        // noCheck(printf("allocating: %p (%u, elem: %d)\n"+4, p, s, this->listLength))

        i = 0
        if this.listLength == this.listRealLength {
            // noCheck(printf("growing %d -> %d\n"+4, this->listRealLength, this->listRealLength * 2))
            this.listRealLength *= 2
            i = this.listLength
            this.list = realloc(this.list, sizeof(lightGCptr) * this.listRealLength)
            memset(<ptr>(<uint>this.list + sizeof(lightGCptr) * (this.listRealLength / 2)), 0, (this.listRealLength / 2) * sizeof(lightGCptr))
        }

        index lightGCptr*
        for i < this.listRealLength, i++ {
            index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
            if index.p == null {
                break
            }
        }

        this.listLength++
        if rooted {
            index.rooted = <char>2
        } else {
            index.rooted = <char>0
        }
        index.size = s
        index.tracked = tracked        
        index.p = p

        return p
    }

    find(addr uint) lightGCptr* {
        min = 0
        l = this.listLength

        i = min + l / 2
        curr = l / 4

        lastAdd = true
        atomic = false

        for i >= min && i < l {
            index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))

            if curr == 0 {
                curr = 1
                atomic = true
            }

            if <uint>index.p > addr {
                if atomic && lastAdd == false {
                    break
                }
                i += curr
                lastAdd = true
            } else if <uint>index.p < addr {
                if atomic && lastAdd == true {
                    break
                }
                i -= curr
                lastAdd = false
            } else {
                return index
            }

            curr /= 2
        }

        return null
    }

    scanRegion(from uint, to uint, alignement uint) {
        k = from; for k < (<uint>to), k += alignement {
            p = *(<uint*>k)
            if p >= this.minPtr && p <= this.maxPtr {
                index = this.find(p)
                if index == null {
                    continue
                }
                if index.rooted != <char>1 {
                    if index.rooted != <char>2 {
                        index.rooted = <char>1
                    }
                    if index.tracked {
                        this.scanRegion(index.p, <uint>index.p + index.size, sizeof(ptr))
                    }
                }
            }
        }
    }

    check() {
        stckEnd = __builtin_frame_address(0)
        this.lastStackEnd = <uint>stckEnd
        
        if this.mainThread != noCheck(syscall(__NR_gettid)) {
            // noCheck(printf("other thread!!!\n"+4))
            return
        }

        // noCheck(printf("pausing world: %d (heap: %d)\n"+4, this->listLength, this->memUsed))

        qsort(this.list, this.listRealLength, sizeof(lightGCptr), _lgc_sort_lightGCptr)

        // noCheck(printf("BSS %p, stack %p\n"+4, this->bssStart, stckEnd))
        this.scanRegion(this.bssStart, this.bssEnd, 1)
        this.scanRegion(stckEnd, this.stackStart, sizeof(ptr))

        i=0; for i < this.listLength, i++ {
            index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
            if index.rooted == <char>2 && index.p != null {
                this.scanRegion(index.p, <uint>index.p + index.size, sizeof(ptr))
            }
        }


        if this.currentPass == this.numberPass {
            // noCheck(printf("freeing :\n"+4))
            i=0; for i < this.listLength, i++ {
                index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
                if index.p == null {
                    continue
                }
                if index.rooted == <char>0 {
                    // noCheck(printf("%p , "+4, index->p))
                    free(index.p)
                    index.p = null
                    this.memUsed -= index.size
                    this.listLength--
                } else if index.rooted != <char>2 {
                    index.rooted = <char>0
                }
            }
            this.currentPass = 0
        } else {
            i=0; for i < this.listLength, i++ {
                index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
                if index.p == null {
                    continue
                }
                if index.rooted == <char>1 {
                    index.rooted = <char>3
                }
            }
            this.currentPass++
        }


        this.stopInterval = this.memUsed * 2
        // noCheck(printf("finished cleanup %d\n"+4, this->stopInterval))

        // noCheck(printf("stack %u %u = %u\n"+4, this->stackStart, stckEnd, (int)this->stackStart - (int)stckEnd))
        
    }
}

_lgc lightGC

isAddrInStack(addr ptr) bool {
    k = _lgc.stackStart; for k >= _lgc.lastStackEnd, k -= sizeof(ptr) {
        if *(<ptr*>k) == <uint>addr {
            return true
        }
    }
    return false
}

isAddrInBSS(addr ptr) bool {
    k = _lgc.bssStart; for k < _lgc.bssEnd, k++ {
        if *(<ptr*>k) == <uint>addr {
            return true
        }
    }
    return false
}

isAddrInRange(addr ptr, from uint, len uint, alignement uint) bool {
    to = from + len
    k = from; for k < to, k += alignement {
        if *(<ptr*>k) == <uint>addr {
            return true
        }
    }
    return false
}

isAddrMarked(addr ptr) char {
    i=0; for i < _lgc.listRealLength, i++ {
        index = <lightGCptr*>(<uint>_lgc.list + (i * sizeof(lightGCptr)))
        if index.p == addr {
            return index.rooted
        }
    }
    return <char>4
}

lightGC_thread_wrapper(args ptr*) {
    stck = *args
    fnArgs = *(<ptr*>(<uint>args + sizeof(ptr)))
    fn function(ptr) = *(<ptr*>(<uint>args + 2 * sizeof(ptr)))

    fn(fnArgs)
    // noCheck(printf("freeing stack %p\n"+4, stck))

    free(args)
    pthread_mutex_lock(&_lgc.mut)
    i=0; for i < _lgc.listRealLength, i++ {
        index = <lightGCptr*>(<uint>_lgc.list + (i * sizeof(lightGCptr)))
        if index.p == stck {
            // noCheck(printf("freeing thread stack\n"+4))
            free(index.p)
            index.p = null
            index.rooted = <char>0
            _lgc.memUsed -= index.size
            _lgc.listLength--
            break
        }
    }
    pthread_mutex_unlock(&_lgc.mut)
}

lightGC_create_thread(id pthread_t*, attr pthread_attr_t*, func ptr, args ptr) int32 {
    noAttr = attr == null
    rattr pthread_attr_t
    if noAttr {
        attr = &rattr
        pthread_attr_init(attr)
    }
    
    pthread_mutex_lock(&_lgc.mut)
    stck = _lgc.allocate(4096, true, true)
    pthread_mutex_unlock(&_lgc.mut)

    wrapArgs = <ptr*>malloc(sizeof(ptr) * 3)
    waa = (<ptr*>(<uint>wrapArgs + sizeof(ptr)))
    fna = (<ptr*>(<uint>wrapArgs + 2 * sizeof(ptr)))
    *wrapArgs = stck
    *waa = args
    *fna = func

    pthread_attr_setstack(attr, stck, 4096)
    pthread_create(id, attr, lightGC_thread_wrapper, wrapArgs)
    
    if noAttr {
        pthread_attr_destroy(attr)
    }
    return 0
}

lightGC_join_thread(id pthread_t, ret ptr) {
    // noCheck(printf("trying to thread\n"))
    exit(1)
    return
}

const __thread_create = lightGC_create_thread
const __thread_join = lightGC_join_thread


initiateMemory(args []cpstring) {
    _lgc.stackStart = __builtin_frame_address(1)

    _lgc.bssStart = getBSSbeg()
    _lgc.bssEnd = getBSSend()

    _lgc.stopInterval = 1000000
    _lgc.currentPass = 0
    _lgc.numberPass = 2

    _lgc.mainThread = noCheck(syscall(__NR_gettid))

    pthread_mutex_init(&_lgc.mut, 0)

    noCheck(setvbuf(stdout, NULL, _IONBF, 0))

    _lgc.listLength = 0
    _lgc.listRealLength = 4096
    s = _lgc.listRealLength * sizeof(lightGCptr)
    _lgc.list = malloc(s)
    memset(_lgc.list, 0, s)
    // noCheck(printf("zeroed\n"+4))

    // noCheck(printf("bss: %u - %u, len: %u\n"+4, _lgc.bssStart, _lgc.bssEnd, _lgc.bssEnd - _lgc.bssStart))
    // exit(0)
}

memoryAlloc(s int) ptr {
    pthread_mutex_lock(&_lgc.mut)
    if _lgc.memUsed >= _lgc.stopInterval {
        _lgc.check()
    }
    p = _lgc.allocate(s, true, false)
    memset(p, 0, s)
    pthread_mutex_unlock(&_lgc.mut)
    return p
}

memoryAllocSTR(s int) cpstring {
    pthread_mutex_lock(&_lgc.mut)
    if _lgc.memUsed >= _lgc.stopInterval {
        _lgc.check()
    }

    p = _lgc.allocate(s + 4, false, false)
    l uint32* = p
    *l = s-1
    memset(<ptr>(<uint>p + 4), 0, s)
    pthread_mutex_unlock(&_lgc.mut)
    return p
}



memoryRealloc(o ptr, s int) ptr {
    if o == null {
        return memoryAlloc(s)
    }
    pthread_mutex_lock(&_lgc.mut)
    oldIndex lightGCptr* = null
    i=0; for i < _lgc.listRealLength, i++ {
        index = <lightGCptr*>(<uint>_lgc.list + (i * sizeof(lightGCptr)))
        if index.p == o {
            oldIndex = index
            break
        }
    }

    oldSize = oldIndex.size
    p = realloc(o, s)
    _lgc.updateBounds(p)
    oldIndex.size = s
    oldIndex.p = p
    _lgc.memUsed += s - oldSize

    memset(<ptr>(<uint>p + oldSize), 0, s - oldSize)
    pthread_mutex_unlock(&_lgc.mut)
    return p
}