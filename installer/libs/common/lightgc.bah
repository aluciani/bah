#include "nativeMem.bah"

#include "<sys/types.h>"
#include "<unistd.h>"
#include "<sys/syscall.h>"
#include "<setjmp.h>"

#warning "lightGC is still very experimental! May cause random crashes + slowing down"

#define! pthread_mutex_t int
#define! pthread_t int
#define! pthread_cond_t int
#define! pthread_attr_t int
#define! pthread_mutex_init(lock pthread_mutex_t*, m int)
#define! pthread_mutex_lock(lock pthread_mutex_t*)
#define! pthread_mutex_unlock(lock pthread_mutex_t*)
#define! pthread_mutex_destroy(lock pthread_mutex_t*)
#define! pthread_cond_init(cond pthread_cond_t*, attr pthread_attr_t*) int
#define! pthread_cond_signal(cond pthread_cond_t*) int
#define! pthread_cond_destroy(cond pthread_cond_t*) int
#define! pthread_cond_wait(cond pthread_cond_t*, mut pthread_mutex_t*) int
#define! pthread_attr_init(attr pthread_attr_t *) int
#define! pthread_attr_setstack(attr pthread_attr_t*, stck ptr, size int)
#define! pthread_getthreadid_np() int

#define! qsort(arr ptr, elementCount uint, elementSize uint, fn ptr)
#define! bsearch(key ptr, base ptr, elementCount uint, elementSize uint, fn ptr) ptr

#define! __builtin_frame_address(n int) int

#define! jmp_buf ptr
#define! setjmp(e jmp_buf)

getBSSend() uint {
    noCheck(extern char end)
    return noCheck(&end)
}

getBSSbeg() uint {
    noCheck(extern char etext)
    return noCheck(&etext)
}


struct lightGCptr {
    size: int
    p: ptr
    rooted: char
}

struct lightGCthread {
    stack: ptr
    t: pthread_t*
    next: lightGCthread*
    aid: bool
    sysid: uint
    regs: ptr
    regsSize: uint

    clean() {
        if this.aid {
            free(this.t)
        }
        free(this.stack)
        free(this)
    }

}

_lgc_sort_lightGCptr(ap ptr, bp ptr) int {
    if <uint>(<lightGCptr*>ap).p < <uint>(<lightGCptr*>bp).p {
        return 1
    }

    return -1
}

_lgc_tid() uint {
    return noCheck(syscall(__NR_gettid))
}

struct lightGC {
    bssStart: uint
    bssEnd: uint

    stackStart: uint
    lastStackEnd: uint

    stopInterval: int

    maxPtr: uint
    minPtr: uint
    memUsed: uint

    currentPass: int
    numberPass: int
    minHeapSize: int

    mainThread: int

    list: lightGCptr*
    listLength: uint
    listRealLength: uint
    mut: pthread_mutex_t
    cond: pthread_cond_t

    threads: lightGCthread*

    allocSinceCheck: int = 0

    updateBounds(p ptr) {
        if <uint>p < this.minPtr || this.minPtr == 0 {
            this.minPtr = <uint>p
        }

        if <uint>p > this.maxPtr {
            this.maxPtr = <uint>p
        }
    }

    //will allocate and track pointer
    allocate(s uint, tracked bool, rooted bool) ptr {
        p = malloc(s)
        this.memUsed += s
        this.updateBounds(p)
        

        // noCheck(printf("allocating: %p (%u, elem: %d)\n"+4, p, s, this->listLength))

        if this.listLength == this.listRealLength {
            this.listRealLength *= 2
            this.list = realloc(this.list, sizeof(lightGCptr) * this.listRealLength)
            memset(<ptr>(<uint>this.list + sizeof(lightGCptr) * (this.listRealLength / 2)), 0, (this.listRealLength / 2) * sizeof(lightGCptr))
        }

        index lightGCptr*
        i = this.listLength; for i < this.listRealLength, i++ {
            index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
            if index.p == null {
                break
            }
        }


        if i == this.listRealLength {
            i = this.listLength - 1; for i != -1, i-- {
                index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
                if index.p == null {
                    break
                }
            }
        }

        this.listLength++
        if rooted {
            index.rooted = <char>2
        } else {
            index.rooted = <char>0
        }
        index.size = s
        
        if tracked == false {
            index.size = 0 - index.size
        }

        index.p = p

        return p
    }

    find(addr uint) lightGCptr* {
        min = 0
        l = this.listLength

        i = min + l / 2
        curr = l / 4

        lastAdd = true
        atomic = false

        for i >= min && i < l {
            index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))

            if curr == 0 {
                curr = 1
                atomic = true
            }

            if <uint>index.p > addr {
                if atomic && lastAdd == false {
                    break
                }
                i += curr
                lastAdd = true
            } else if <uint>index.p < addr {
                if atomic && lastAdd == true {
                    break
                }
                i -= curr
                lastAdd = false
            } else {
                return index
            }

            curr /= 2
        }

        return null
    }

    scanRegion(from uint, to uint, alignement uint) {
        k = from; for k < (<uint>to), k += alignement {
            p = *(<uint*>k)
            if p >= this.minPtr && p <= this.maxPtr && p % sizeof(ptr) == 0 {
                index = this.find(p)
                if index == null {
                    continue
                }

                if index.rooted != <char>1 {
                    if index.rooted != <char>2 {
                        index.rooted = <char>1
                    }
                    if index.size > 0 {
                        this.scanRegion(index.p, <uint>index.p + index.size, sizeof(ptr))
                    }
                }
            }
        }
    }

    check() {
        if this.mainThread != _lgc_tid() {
            // noCheck(printf("other thread!!!\n"+4))
            return
        }
        stckEnd = __builtin_frame_address(0)
        this.lastStackEnd = <uint>stckEnd

        // noCheck(printf("pausing world: %d (heap: %d)\n"+4, this->listLength, this->memUsed))

        ct = this.threads; for ct != null, ct = ct.next {
            sigqueue(ct.sysid, noCheck(SIGUSR1), noCheck((union sigval){ .sival_ptr = 0 }))
        }

        qsort(this.list, this.listRealLength, sizeof(lightGCptr), _lgc_sort_lightGCptr)

        // noCheck(printf("BSS %p, stack %p\n"+4, this->bssStart, stckEnd))
        this.scanRegion(this.bssStart, this.bssEnd, 1)
        this.scanRegion(stckEnd, this.stackStart, sizeof(ptr))

        i=0; for i < this.listLength, i++ {
            index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
            if index.rooted == <char>2 && index.p != null {
                this.scanRegion(index.p, <uint>index.p + index.size, sizeof(ptr))
            }
        }

        
        ct = this.threads; for ct != null, ct = ct.next {
            if ct.regs != null {
                // noCheck(printf("checking regs %p\n"+4, ct->regs))
                this.scanRegion(ct.regs, <uint>ct.regs + 200 - sizeof(ptr), 1)
            }
            this.scanRegion(ct.stack, <uint>ct.stack + 4096, sizeof(ptr))
        }


        if this.currentPass == this.numberPass {
            n = 0
            ol = this.listLength
            i=0; for i < ol, i++ {
                index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
                if index.p == null {
                    continue
                }
                
                if index.rooted == <char>0 {
                    // noCheck(printf("%p , "+4, index->p))
                    n++
                    free(index.p)
                    index.p = null
                    s = index.size
                    if s < 0 {
                        s = 0 - s
                    }
                    this.memUsed -= s

                    this.listLength--
                } else if index.rooted != <char>2 {
                    index.rooted = <char>0
                }
            }
            qsort(this.list, this.listRealLength, sizeof(lightGCptr), _lgc_sort_lightGCptr)
            // noCheck(printf("frees: %d (allive: %d) \n"+4, n, this->listLength))
            this.currentPass = 0
            this.stopInterval = this.memUsed * 2
        } else {
            i=0; for i < this.listLength, i++ {
                index = <lightGCptr*>(<uint>this.list + (i * sizeof(lightGCptr)))
                if index.p == null {
                    continue
                }
                if index.rooted == <char>1 {
                    index.rooted = <char>3
                }
            }
            this.currentPass++
            this.stopInterval = <int>(<float>this.memUsed * 1.5)
        }

        if this.stopInterval < this.minHeapSize {
            this.stopInterval = this.minHeapSize
        }

        // noCheck(printf("\theap size: %d MB (%d allocs, next cycle: %d B)\n"+4, this->memUsed / 1000000, this->listLength, this->stopInterval))
    }
}

_lgc lightGC

isAddrInStack(addr ptr) bool {
    k = _lgc.stackStart; for k >= _lgc.lastStackEnd, k -= sizeof(ptr) {
        if *(<ptr*>k) == <uint>addr {
            return true
        }
    }
    return false
}

isAddrInBSS(addr ptr) bool {
    k = _lgc.bssStart; for k < _lgc.bssEnd, k++ {
        if *(<ptr*>k) == <uint>addr {
            return true
        }
    }
    return false
}

isAddrInRange(addr ptr, from uint, len uint, alignement uint) bool {
    to = from + len
    k = from; for k < to, k += alignement {
        if *(<ptr*>k) == <uint>addr {
            return true
        }
    }
    return false
}

isAddrMarked(addr ptr) char {
    i=0; for i < _lgc.listRealLength, i++ {
        index = <lightGCptr*>(<uint>_lgc.list + (i * sizeof(lightGCptr)))
        if index.p == addr {
            return index.rooted
        }
    }
    return <char>4
}

lightGC_thread_sig_handler(sig int) {
    envJmp jmp_buf
    setjmp(envJmp)

    
    sid = _lgc_tid()
    ct = _lgc.threads
    for ct != null, ct = ct.next {
        if ct.sysid == sid {
            ct.regs = &envJmp
            ct.regsSize = sizeof(envJmp)
            break
        }
    }

    pthread_mutex_lock(&_lgc.mut)
    pthread_mutex_unlock(&_lgc.mut)
}

lightGC_thread_wrapper(args ptr*) {
    t lightGCthread* = *args
    t.sysid = _lgc_tid()
    fnArgs = *(<ptr*>(<uint>args + sizeof(ptr)))
    fn function(ptr) = *(<ptr*>(<uint>args + 2 * sizeof(ptr)))

    fn(fnArgs)

    free(args)
    pthread_mutex_lock(&_lgc.mut)
    
    if t == _lgc.threads {
        _lgc.threads = t.next
        t.clean()
    } else {
        ct = _lgc.threads
        for ct != null, ct = ct.next {
            if ct.next == t {
                ct.next = t.next
                t.clean()
                break
            }
        }
    }

    
    pthread_mutex_unlock(&_lgc.mut)
}

lightGC_create_thread(id pthread_t*, attr pthread_attr_t*, func ptr, args ptr) int32 {
    noAttr = attr == null
    rattr pthread_attr_t
    if noAttr {
        attr = &rattr
        pthread_attr_init(attr)
    }
    
    pthread_mutex_lock(&_lgc.mut)
    stck = malloc(4096)
    
    t = <lightGCthread*>malloc(sizeof(lightGCthread))
    if id == null {
        t.t = malloc(sizeof(pthread_t))
        id = t.t
        t.aid = true
    } else {
        t.aid = false
    }

    t.stack = stck
    t.regs = 0
    t.regsSize = 0

    t.next = _lgc.threads
    _lgc.threads = t
    pthread_mutex_unlock(&_lgc.mut)

    wrapArgs = <ptr*>malloc(sizeof(ptr) * 3)
    waa = (<ptr*>(<uint>wrapArgs + sizeof(ptr)))
    fna = (<ptr*>(<uint>wrapArgs + 2 * sizeof(ptr)))
    *wrapArgs = t
    *waa = args
    *fna = func

    pthread_attr_setstack(attr, stck, 4096)
    pthread_create(id, attr, lightGC_thread_wrapper, wrapArgs)
    
    if noAttr {
        pthread_attr_destroy(attr)
    }
    return 0
}

lightGC_join_thread(id pthread_t, ret ptr) {
    // noCheck(printf("trying to thread\n"))
    exit(1)
    return
}

const __thread_create = lightGC_create_thread
const __thread_join = lightGC_join_thread


initiateMemory(args []cpstring) {
    _lgc.stackStart = __builtin_frame_address(1)

    _lgc.bssStart = getBSSbeg()
    _lgc.bssEnd = getBSSend()

    _lgc.stopInterval = 10000000
    _lgc.minHeapSize =  10000000
    _lgc.currentPass = 0
    _lgc.numberPass = 2


    _lgc.threads = null
    _lgc.mainThread = noCheck(syscall(__NR_gettid))

    action sigaction
    action.sa_flags = noCheck(SA_SIGINFO);
    action.sa_handler = lightGC_thread_sig_handler
    sigaction(noCheck(SIGUSR1), &action, null)

    pthread_mutex_init(&_lgc.mut, 0)
    pthread_cond_init(&_lgc.cond, null)

    // tid pthread_t
    // pthread_create(&tid, null, _lgc.scanWorker, &_lgc)


    noCheck(setvbuf(stdout, NULL, _IONBF, 0))

    _lgc.listLength = 0
    _lgc.listRealLength = 4096
    s = _lgc.listRealLength * sizeof(lightGCptr)
    _lgc.list = malloc(s)
    memset(_lgc.list, 0, s)
    // noCheck(printf("zeroed\n"+4))

    // noCheck(printf("bss: %u - %u, len: %u\n"+4, _lgc.bssStart, _lgc.bssEnd, _lgc.bssEnd - _lgc.bssStart))
    // exit(0)
}

memoryAlloc(s int) ptr {
    pthread_mutex_lock(&_lgc.mut)
    if _lgc.memUsed >= _lgc.stopInterval {
        envJmp jmp_buf
        setjmp(envJmp)
        _lgc.check()
    }
    p = _lgc.allocate(s, true, false)
    memset(p, 0, s)
    pthread_mutex_unlock(&_lgc.mut)
    return p
}

memoryAllocSTR(s int) cpstring {
    pthread_mutex_lock(&_lgc.mut)
    if _lgc.memUsed >= _lgc.stopInterval {
        envJmp jmp_buf
        setjmp(envJmp)
        _lgc.check()
    }

    p = _lgc.allocate(s + 4, false, false)
    l uint32* = p
    *l = s-1
    memset(<ptr>(<uint>p + 4), 0, s)
    pthread_mutex_unlock(&_lgc.mut)
    return p
}



memoryRealloc(o ptr, s int) ptr {
    if o == null {
        return memoryAlloc(s)
    }
    pthread_mutex_lock(&_lgc.mut)
    if _lgc.memUsed >= _lgc.stopInterval {
        envJmp jmp_buf
        setjmp(envJmp)
        _lgc.check()
    }
    
    oldIndex lightGCptr* = null

    i=_lgc.listLength-1; for i != -1, i-- {
        index = <lightGCptr*>(<uint>_lgc.list + (i * sizeof(lightGCptr)))
        if index.p == o {
            oldIndex = index
            break
        }
    }

    if oldIndex == null {
        i=_lgc.listLength; for i < _lgc.listRealLength, i++ {
            index = <lightGCptr*>(<uint>_lgc.list + (i * sizeof(lightGCptr)))
            if index.p == o {
                oldIndex = index
                break
            }
        }
    }
    
    oldSize = oldIndex.size
    tracked = true
    if oldSize < 0 {
        tracked = false
        oldSize = 0 - oldSize
    }
    p = realloc(o, s)
    _lgc.updateBounds(p)
    oldIndex.size = s
    if tracked == false {
        oldIndex.size = 0 - oldIndex.size
    }
    oldIndex.p = p
    _lgc.memUsed += s - oldSize

    memset(<ptr>(<uint>p + oldSize), 0, s - oldSize)
    pthread_mutex_unlock(&_lgc.mut)
    return p
}