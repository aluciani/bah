#linux {
    #include "<sys/mman.h>"
}

#darwin {
    #include "<sys/mman.h>"
}

#windows {
    #include "<windows.h>"
    #include "<stdio.h>"
    #include "<conio.h>"
    #include "<tchar.h>"
}


#define! void ptr

const SIZE_OF_INT = 8
const SIZE_OF_CHAR = 1
const SIZE_OF_INT32 = 4
const SIZE_OF_FLOAT32 = 4
const SIZE_OF_FLOAT = 8


//Will return the length of an array.
//This only works on arrays.
len(a ptr) int {
    if a == null {
        return 0
    }
    i = 0
    noCheck(array(void*) * arr = a)
    noCheck(i = arr->length)
    return i
}

#define! memmove(dest ptr, src ptr, size int)

#define! memset(p ptr, v int, s int)

#include "BAH_MEM_COLLECTOR"


//Append will add the array b to the array a.
//Note: doesn't work with []char.
append(a ptr, b ptr) {
    noCheck(array(void*) * arrA = a)
    noCheck(array(void*) * arrB = b)
    lenA = 0
    lenB = 0
    realSizeA = 0
    realSizeB = 0
    noCheck(lenA = len(arrA))
    noCheck(lenB = len(arrB))

    if lenB == 0 {
        return
    }

    if lenA == 0 {
        noCheck(arrA->data = arrB->data)
        noCheck(arrA->length = arrB->length)
        return
    }

    noCheck(realSizeA = lenA * arrA->elemSize)
    noCheck(realSizeB = lenB * arrB->elemSize)


    buff = memoryAlloc(realSizeA + realSizeB+32)
    noCheck(memcpy(buff, arrA->data, realSizeA))
    noCheck(memcpy(buff+lenA, arrB->data, realSizeB))
    noCheck(arrA->length = lenA + lenB)
    noCheck(arrA->data = buff)
}

copy(a ptr, b ptr) {
    noCheck(array(void*) * arrA = a)
    noCheck(array(void*) * arrB = b)
    lenB = 0
    realSizeB = 0
    noCheck(lenB = len(arrB))
    noCheck(realSizeB = lenB * arrB->elemSize)
    noCheck(arrA->data = memoryAlloc(realSizeB))
    noCheck(memcpy(arrA->data, arrB->data, realSizeB))
    noCheck(arrA->length = arrB->length)
}

#windows {
    #define! CreateFileMapping(ihv ptr, sec int, rw int, mos int, bs int, fn cpstring) ptr
    #define! MapViewOfFile(f ptr, sec int, mi1 int, mi2 int, bs int) ptr
    #define! CloseHandle(mf ptr)

    #define! printf(s cpstring)
    #define! exit(code int)

    const PROT_READ = 2
    const PROT_READWRITE = 4

    GLOBAL_MAPPED_MEMORY_FILE ptr
}

#linux {
    #define! mmap(addr int, ps int, prot int, flags int, fd int, offset int) ptr
    const PROT_READ = 1
    const PROT_WRITE = 2
    const PROT_READWRITE = 3
    const MAP_SHARED = 1
    const MAP_ANONYMOUS = 32
}

#darwin {
    #define! mmap(addr int, ps int, prot int, flags int, fd int, offset int) ptr
    const PROT_READ = 1
    const PROT_WRITE = 2
    const PROT_READWRITE = 3
    const MAP_SHARED = 1
    const MAP_ANONYMOUS = 32
}



//Will allocate a page of shared memory and returns a pointer to it.
//The size should be an multiple of 4096. A size of 0 will set the page size to the default (4096).
//Shared memory can be shared between two processes (after the use of fork()).
sharedMemory(size int) ptr {
    if size == 0 {
        size = 4096
    }
    #linux {
        r = mmap(0, size, PROT_READ + PROT_WRITE, MAP_SHARED + MAP_ANONYMOUS, -1, 0)
    }
    #darwin {
        r = mmap(0, size, PROT_READ + PROT_WRITE, MAP_SHARED + MAP_ANONYMOUS, -1, 0)
    }
    #windows {
        if GLOBAL_MAPPED_MEMORY_FILE == null {
            GLOBAL_MAPPED_MEMORY_FILE = CreateFileMapping(-1, 0, PROT_READWRITE, 0, size, "Global\\BahFileMap")
        }
        if GLOBAL_MAPPED_MEMORY_FILE == null {
            printf("sharedMemory: could not make map file.")
            exit(1)
        }
        r = MapViewOfFile(GLOBAL_MAPPED_MEMORY_FILE, noCheck(FILE_MAP_ALL_ACCESS), 0, 0, size)
    }
    return r
}

#windows {
    //On windows, you will need to close the mapped file.
    //*This is a windows only thing.*
    closeSharedMemory() {
        CloseHandle(GLOBAL_MAPPED_MEMORY_FILE)
    }
}

//Used for pre-allocating a number of element to an array.
//The content of the array is not initialized, it may contain garbage.
allocateArray(arr ptr, nbElems int) {
    noCheck(array(void*) * a = arr)
    noCheck(a->length = nbElems)
    noCheck(a->data = memoryAlloc(nbElems * a->elemSize))
}


//Example
// #include "string.bah"
// #include "memory.bah"
// main() {
//     a cpstring = memoryAlloc(30)
//     strcpy(a, "Hi!")
// }

#define! memcpy(det ptr, src ptr, s int)

#define ser(a ptr) []char

//Internal function used to serialize a pointer.
__serialize(a ptr, s int) []char {
    r cpstring = memoryAlloc(s + 9)
    memcpy(r, &s, 8)
    memcpy(noCheck(r+8), a, s)
    l = s+1
    arr = []char
    noCheck(arr->length = s+8)
    noCheck(arr->elemSize = 1)
    noCheck(arr->data = r)
    return arr
}

//Function used to get the size of the serialized pointer.
serlen(data []char) int {
    sarr = []char{data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]}
    return noCheck(*sarr->data)
}

//Function used to unserialize the content of a struct.
unser(data []char) ptr {
    sptr = serlen(data)
    r = memoryAlloc(sptr)
    memcpy(r, noCheck(data->data + 8), sptr)
    return r
}

#gc {
    #define! GC_malloc_atomic(s int) ptr
    memoryAllocSTR(s int) cpstring {
        r cpstring = GC_malloc_atomic(s)
        noCheck(r[s-1] = 0)
        // memset(r, 0, s)
        return r
    }
}
#rcp {
    memoryAllocSTR(s int) cpstring {
        return memoryAlloc(s)
    }
}


//Used for deleting an element from an array by its index.
//This will keep the order of the elements.
delete(a ptr, i int) {
    arr = []ptr
    arr = a
    length = len(arr)
    if i >= length || i < 0 {
        return
    }
	if length == 1 {
		noCheck(arr->length = 0)
		return
	}
    elemSize int = noCheck(arr->elemSize)
    data char* = noCheck(arr->data)
    destOffset ptr = elemSize * i
    i++
    offset ptr = elemSize * i
    src char* = <int>data + <int>offset
    dest char* = <int>data + <int>destOffset
    rightNB = length - (i-1)
    memmove(dest, src, rightNB * elemSize)
    noCheck(arr->length = length - 1)
}

//Used to convert an array of characters to a cpstring.
arrToStr(arr []char) cpstring {
    strLen = len(arr)
    str cpstring = memoryAllocSTR(strLen+1)
    noCheck(memcpy(str, arr->data, strLen))
    return str
}

//Used to convert a cpstring into an array of characters.
strToArr(str cpstring) []char {
    strLen = strlen(str)
    arr = []char
    noCheck(arr->data = memoryAlloc(strLen+1))
    noCheck(memcpy(arr->data, str, strLen))
    noCheck(arr->length = strLen)
    
    return arr
}

//Used to get a pointer to an array data as a cpstring.
//Unlike arrToStr, this does not copy the content of the array to a cpstring.
//This is faster but changing the content of the returnend cpstring will change the content of the array.
//You can see this operation as linkning the same data through two different interfaces, the only difference between these two interfaces are their type.
arrAsStr(arr []char) cpstring {
    #rcp {
        RCP_incr(noCheck(arr->data))
    }
    return noCheck(arr->data)
}

//Used to get a cpstring as an array of chars.
//This is faster than strToArr() but changing the content of the array will change the content of the cpstring.
//This could lead to memory corruption if the cpstring is not heap allocated.
//Make sure that the array is null terminated if editting it.
strAsArr(str cpstring) []char {
    #rcp {
        RCP_incr(str)
    }
    l = strlen(str)
    arr = []char
    noCheck(arr->length = l)
    noCheck(arr->data = str)
    return arr
}


strTrimLeft(s cpstring*, i int) {
    ls = strlen(*s)
    ns cpstring = memoryAlloc(ls - i + 1)
    memcpy(ns, noCheck(*s+i), ls - i)
    *s = ns
}

strTrimRight(s cpstring*, i int) {
    ls = strlen(*s)
    ns cpstring = memoryAlloc(ls - i + 1)
    memcpy(ns, *s, ls - i)
    *s = ns
}

const __bah_memory_realloc = memoryRealloc
const __bah_memory_str = memoryAllocSTR