#include "<stdio.h>"
#include "<stdlib.h>"
#include "<unistd.h>"
#include "<pthread.h>"


#cLib "lpthread"

#define! malloc(s int) ptr
#define! realloc(p ptr, s int) ptr
#define! free(a ptr)

#define! pthread_mutex_t int

#define! pthread_mutex_init(lock pthread_mutex_t*, m int)
#define! pthread_mutex_lock(lock pthread_mutex_t*)
#define! pthread_mutex_unlock(lock pthread_mutex_t*)
#define! pthread_mutex_destroy(lock pthread_mutex_t*)

// #define! pthread_create(id int*, attr ptr, func ptr, args ptr)
// #define! pthread_join(id int, ret ptr)


#define RCP_register(p ptr, s uint)
#define RCP_remove(p ptr)
#define RCP_setNewPtr(o ptr, n ptr)

#define! sizeof(a ptr) int

//Destroy will force to free a pointer.
destroy(a ptr) {
    RCP_remove(a)
    free(a)
}

struct RCP {
    p: ptr = null
    c: uint32 = 0
    s: uint = 0
    e: ptr = null
    str: bool
}


cmp_rcp(a ptr, b ptr) int32 {
    ar RCP* = a
    br RCP* = b
    if ar.p < br.p {
        return -1
    } else if ar.p > br.p {
        return 1
    }
    return 0
}

#define! memcpy(dest ptr, src ptr, s int)
#define! qsort(arr ptr, l int, s int, cmp ptr)
#define! bsearch(key ptr, arr ptr, l int, s int, cmp ptr) ptr
#define! sbrk(i int) ptr

// struct RCP_threadSearch {
//     from: int
//     to: int
//     p: ptr
//     arr: RCP*
//     l: int
// }

// RCPthreadSearch(arg ptr) RCP* {
//     rts RCP_threadSearch* = arg
//     r = bsearch(&rts.p, noCheck(&rts.arr[rts.from]), rts.to - rts.from, sizeof(RCP), cmp_rcp)
//     free(arg)
//     return r
// }

struct RCPstate {
    RCPs: RCP* = null
    len: uint = 0
    size: uint = 0

    lock: pthread_mutex_t

    heapMax: ptr
    heapMin: ptr

    getSize(add uint) uint {
        l = this.len + add
        return l * sizeof(RCP)
    }

    grow(i uint) {
        rs = this.getSize(i+30)
        nr = realloc(this.RCPs, rs)
        if nr == null {
            return
        }
        this.size = rs
        this.RCPs = nr
        this.len = this.len + i
    }

    sort() {
        qsort(noCheck(&this->RCPs[0]), this.len, sizeof(RCP), cmp_rcp)
    }

    rcpToIndex(r RCP*) uint {
        i int = <int>r - <int>noCheck(&this->RCPs[0])
        i = i / sizeof(RCP)

        return i
    }


    add(r RCP*) {
        pthread_mutex_lock(&this.lock)
        rs = this.getSize(1)
        max = this.len - 1
        if this.size < rs {
            this.grow(1)
        } else {
            this.len = this.len + 1
        }

        done = false
        i = max; for i >= 0 {
            ar RCP* = noCheck(&this->RCPs[i])
            if ar.p < r.p {
                j=max; for j > i {
                    noCheck(this->RCPs[j+1] = this->RCPs[j])
                    j = j - 1
                }
                noCheck(this->RCPs[i+1] = *r)
                done = true
                break
            }
            i = i - 1
        }

        if done == false {
            j=max; for j >= 0 {
                noCheck(this->RCPs[j+1] = this->RCPs[j])
                j = j - 1
            }
            noCheck(this->RCPs[0] = *r)
        }
        pthread_mutex_unlock(&this.lock)
    }

    get(i uint) RCP* {
        if i >= this.len {
            return null
        }
        return noCheck(&this->RCPs[i])
    }

    set(i uint, r RCP*) {
        noCheck(this->RCPs[i] = *r)
        // this.sort()
    }

    // #define! pthread_create(id int*, attr ptr, func ptr, args ptr)
    // #define! pthread_join(id int, ret ptr)


    getByPtr(p ptr) RCP* {
        if p < this.heapMin || p > this.heapMax {
            return null
        }
        
        
        return bsearch(&p, noCheck(&this->RCPs[0]), this.len, sizeof(RCP), cmp_rcp)
    }

    resize(ns uint) {
        nr = realloc(this.RCPs, ns)
        if nr == null {
            return
        }
        this.RCPs = nr
        this.size = ns
    }

    remove(i uint) {
        this.len = this.len - 1
        
        for i < this.len {
            noCheck(this->RCPs[i] = this->RCPs[i+1])
            i = i + 1
        }
        s = this.getSize(30)
        if this.size - s >= this.size / 2 {
            this.resize(s)
        }
    }

    lockMut() {
        pthread_mutex_lock(&this.lock)
    }

    unlockMut() {
        pthread_mutex_unlock(&this.lock)
    }

}

RCPstate RCPstate

DEBUG_RCP = false

RCP_init() {
    RCPstate = RCPstate{}
    RCPstate.heapMin = -1
    RCPstate.heapMax = -1
    l = RCPstate.lock
    pthread_mutex_init(&l, 0)
}

#define! exit(e int)

RCP_shutdown() {
    l = RCPstate.lock
    pthread_mutex_destroy(&l)
    if RCPstate.len > 0 {
        // free(RCPstate.RCPs)
        if DEBUG_RCP == true {
            noCheck(printf("\n\n[RCP] Leak detected!\n Summary: %d leaks (including global variables that are not freed at the end of the program).\n If your program is using self-referenced object (such as ropes), recompile-it without the '-rcp' flag.\n", RCPstate.len))
            rcpStatep = &RCPstate
            i=0; for i < RCPstate.len, i++ {
                r RCP* = noCheck(&rcpStatep->RCPs[i])
                if r.p >= RCPstate.heapMin && r.p <= RCPstate.heapMax {
                    noCheck(printf("\t%p (%d reference(s))\n", r->p, r->c))
                }
            }
        }
    }
}

cleanShutDown() {
    RCP_shutdown()
    exit(1)
}

RCP_selfRef(a ptr, b ptr) bool {
    return a == b
}

RCP_register(p ptr, s uint) {
    if p == null {
        return
    }
    r = RCP{}
    r.c = 1
    r.s = s
    r.p = p
    r.str = false
    RCPstate.add(&r)
}

RCP_registerSTR(p ptr, s uint) {
    if p == null {
        return
    }
    r = RCP{}
    r.c = 1
    r.s = s
    r.p = p
    r.str = true
    RCPstate.add(&r)
}

RCP_setNewPtr(o ptr, n ptr) {
    if o == null || n == null || o == n {
        return
    }
    r = RCPstate.getByPtr(o)
    if r == null {
        return
    }
    r.p = n
}

RCP_remove(p ptr) {
    if p == null {
        return
    }
    r = RCPstate.getByPtr(p)
    if r == null {
        return
    }
    RCPstate.remove(RCPstate.rcpToIndex(r))
}

#define RCP_scanRegion(curr ptr*, end ptr*, decr bool)

RCP_incr(p ptr) {
    if p == null {
        return
    }
    r = RCPstate.getByPtr(p)
    if r == null {
        return
    }
    r.c = r.c + 1
    // if r.s >= sizeof(ptr) {
    //     end ptr* = <int>r.p + r.s
    //     RCP_scanRegion(r.p, end, false)
    // }
    // noCheck(printf("incr: %d (%d)\n", p, r.c))
}

RCP_getCount(p ptr) uint {
    if p == null {
        return 0
    }
    r = RCPstate.getByPtr(p)
    if r == null {
        return 0
    }

    return r.c

}

RCP_isAllocated(p ptr) bool {
    if p == null {
        return false
    }
    r = RCPstate.getByPtr(p)
    if r == null {
        return false
    }
    return true
}

#define RCP_decr(p ptr)
#define RCP_incr(p ptr)

RCP_scanRegion(curr ptr*, end ptr*, decr bool) {
    from = curr
    for <int>curr < <int>end {
        b = *curr
        if b <= RCPstate.heapMax && b >= RCPstate.heapMin {
            if decr == true {
                RCP_decr(b)
            } else {
                RCP_incr(b)
            }
        }
        curr = noCheck(curr + 1)
    }
}

RCP_decr(p ptr) {
    if p == null {
        return
    }
    r = RCPstate.getByPtr(p)
    if r == null {
        return
    }
    orc = r.c
    r.c = r.c - 1
    if r.c <= 0 {
        if r.e != null {
            changed = true
            fn function(ptr) = r.e
            fn(r.p)
        }
        tmpr = *r
        RCPstate.remove(RCPstate.rcpToIndex(r))
        if tmpr.str == false && tmpr.s >= sizeof(ptr) {
            end ptr* = <int>tmpr.p + tmpr.s
            RCP_scanRegion(tmpr.p, end, true)
        }
        free(tmpr.p)
    }
}

RCP_incrIL(p ptr*) ptr {
    RCP_incr(*p)
    return p
}

RCP_decrIL(p ptr*) ptr {
    RCP_decr(*p)
    return p
}

RCP_request(p ptr) RCP* {
    if p == null {
        return null
    }
    return RCPstate.getByPtr(p)
}

RCP_decrRCP(r RCP*) {
    if r == null {
        return
    }
    r = RCPstate.getByPtr(r.p)
    if r == null {
        return
    }
    r.c = r.c - 1
    if r.c <= 0 {
        if r.e != null {
            fn function(ptr) = r.e
            fn(r.p)
        }
        free(r.p)
        RCPstate.remove(RCPstate.rcpToIndex(r))
    }
}


RCP_scanStack(p ptr, s uint, decr bool) {
    if p == null {
        return
    }
    end ptr* = <int>p + s
    // noCheck(printf("scanning stack from: %d to: %d\n", p, end))
    RCP_scanRegion(p, end, decr)
}

RCP_scanHeap(p ptr) {
    if p == null {
        return
    }
    r = RCPstate.getByPtr(p)
    if r == null {
        return
    }
    if r.c == 1 {
        end ptr* = <int>p + r.s
        // noCheck(printf("scanning heap from: %d to: %d\n", p, end))
        RCP_scanRegion(p, end, true)
    }
    RCP_decrRCP(r)
}

//Used for allocating memory (malloc in c). You must specify the size of the block to allocate.
//Will return a pointer to the allocated block. The memory is garbage collected.
//**The given memory is initiated with zeros.**
//The allocated memory cannot be shared by multiple processes. Use the sharedMemory() function instead.
memoryAlloc(s uint) ptr {
    r = malloc(s)
    if r < RCPstate.heapMin || RCPstate.heapMin == -1 {
        RCPstate.heapMin = r
    }
    if r > RCPstate.heapMax {
        RCPstate.heapMax = r
    }
    memset(r, 0, s)
    RCP_register(r, s)
    return r
}


memoryAllocSTR(s uint) cpstring {
    r = malloc(s)
    if r < RCPstate.heapMin || RCPstate.heapMin == -1 {
        RCPstate.heapMin = r
    }
    if r > RCPstate.heapMax {
        RCPstate.heapMax = r
    }
    memset(r, 0, s)
    RCP_registerSTR(r, s)
    return r
}

//Will realloc memory to a specified pointer.
//*The data contained in the block of memory is not necessarly preserved.*
memoryRealloc(p ptr, s uint) ptr {
    // Cannot use the following because realloc needs to return a different pointer
    
    // or = RCP_request(p)
    // if or == null || or.c == 0 {
    //     return memoryAlloc(s)
    // }
    // r = realloc(p, s)
    // if r == p {
    //     or.s = s
    //     return r
    // } else {
    //     if r < RCPstate.heapMin || RCPstate.heapMin == -1 {
    //         RCPstate.heapMin = r
    //     }
    //     if r > RCPstate.heapMax {
    //         RCPstate.heapMax = r
    //     }
    //     ns = or.s
    //     if s < or.s {
    //         ns = s
    //     } else {
    //         off ptr = <int>r + ns
    //         memset(off, null, s - ns)
    //     }
    //     RCPstate.remove(RCPstate.rcpToIndex(or))
    //     RCP_register(r, s)
    // }

    or = RCP_request(p)
    if or == null || or.c == 0 {
        return memoryAlloc(s)
    }
    r = malloc(s)
    if r < RCPstate.heapMin || RCPstate.heapMin == -1 {
        RCPstate.heapMin = r
    }
    if r > RCPstate.heapMax {
        RCPstate.heapMax = r
    }
    ns = or.s
    if s < or.s {
        ns = s
    }
    memcpy(r, p, ns)
    RCP_decrRCP(or)
    RCP_register(r, s)
    return r
}


//Clear will remove the content of an array.
clear(a ptr) {
    if RCP_isAllocated(a) == false {
        return
    }
    noCheck(array(void*) * arr = a)
    noCheck(RCP_decr(arr->data))
    noCheck(arr->data = memoryAlloc(sizeof(0)))
    noCheck(arr->length = 0)
    noCheck(arr->realLength = 0)
}

memoryOnEnd(obj ptr, fn ptr) {
    if obj == null {
        return
    }
    r = RCPstate.getByPtr(obj)
    if r == null {
        return
    }
    r.e = fn
}