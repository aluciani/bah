#include "iostream.bah"
#include "string.bah"


//The reflection of an element (a var).
//A reflection is a wrapper for informations on the data-type of the element.
//This is used for getting compile-time informations at runtime.
//**Usage: **
//Simply put reflectElement as the type of a function argument.
//The argument will then be reflected inside the function.
struct reflectElement {
    //Var infos
    size: int
    type: str
    name: str

    //Array infos
    isArray: bool
    arrayElem: reflectElement*

    //Struct infos
    isStruct: bool
    structLayout: []reflectElement
    offset: int

    //Actual element
    value: ptr

    //Calculates the offset pointer from an origin pointer.
    //This is used to get a pointer to the element when it
    calculateOffset(origin ptr) ptr {
        base str = origin
        return noCheck(base + this->offset)
    }
}


//Internal function used for generating a reflected element.
__reflect(v ptr, s int, t str, n str, isArr bool, ae reflectElement*, isStruct bool, sl []reflectElement, offset int) reflectElement {
    re = reflectElement{}
    re.size = s
    re.type = t
    re.name = n
    re.isArray = isArr
    re.arrayElem = ae
    re.isStruct = isStruct
    re.structLayout = sl
    re.value = v
    re.offset = offset
    return re
}

#define reflectSymbols ptr

//Internal function called when dumpSymbols() is called.
//This returns every symbols (variables) available at the scope where its called.
//The symbols are returned as reflectElement.
__dumpSymbols(syms []reflectElement) []reflectElement {
    return syms
}

//Internal function used for getting a symbol by name from a symbol array.
__debug_get_sym(syms []reflectElement, a string) reflectElement {
    if a.count(".") > 0 {
        parts = splitString(a, ".")
        p1 = parts[0]
        p2 = parts[1]
        j=0; for j < len(syms), j++ {
            s = syms[j]
            if s.name == p1.str() {
                k=0; for k < len(s.structLayout), k++ {
                    m = s.structLayout[k]
                    if m.name == p2.str() {
                        m.value = m.calculateOffset(s.value)
                        return m
                    }
                }
                break
            }
        }
    } else {
        j=0; for j < len(syms), j++ {
            s = syms[j]
            if s.name == a.str() {
                return s
            }
        }
    }
    ns = reflectElement{}
    return ns
}

const __bah_reflect = __reflect
const __bah_dump_symbols = __dumpSymbols
const __bah_debug_get_sym = __debug_get_sym


//Example
// #include "iostream.bah"
// #include "reflect.bah"
// reflectedPrint(e reflectElement) {
//     if e.type == "int" {
//         ip int* = e.value
//         println(intToStr(*ip))
//     } else if e.type == "str" {
//         //WARNING: if the str is the member of a struct, it will return a pointer to the str.
//         sp str = e.value
//         println(sp)
//     }
// }
// main(args []str) int {
//     a = 54
//     b = "test"
//     reflectedPrint(&a)
//     reflectedPrint(&b)
//     return 0
// }
