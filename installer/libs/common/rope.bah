const ROPE_LEAF_LEN = 200

//A rope is a structure that represents text.
//Concatenation takes a constant time.
//This is usefull for large strings that are built using a lot of concatenations.
struct rope {
    left: rope*
    right: rope*
    str: cpstring
    lCount: int32
    len: int32 = 0
    totalLen: int32

    //Used to add the content of the node to a specified cpstring.
    //*Note: this is an internal function.*
    addStr(s cpstring, offset int*) {
        if this.left == null && this.right == null {
            off = *offset
            memcpy(noCheck(s+off), this.str, this.lCount+1)
            *offset += this.lCount+1
            return
        }
        l = *offset
        this.left.addStr(s, offset)
        this.right.addStr(s, offset)
    }

    //Used to get the rope as a cpstring.
    toStr() cpstring {
        if this.left == null && this.right == null {
            return this.str
        }
        s cpstring = memoryAlloc(this.totalLen + 1)
        offset = 0
        this.left.addStr(s, &offset)
        this.right.addStr(s, &offset)

        return s
    }

    //Used for concatenation.
    //This is the method that will be called when doing `a + b`.
    add(root2 rope*) rope* {
        n1 = this.len
        tmp = new rope
        // tmp.parent = null
        tmp.left = this
        tmp.right = root2
        // root2.parent = tmp
        // this.parent = root2.parent
        tmp.totalLen = this.totalLen + root2.totalLen
        tmp.str = null
        return tmp
    }
}

//This is used to initiate a new node.
//a: the content of the node
//l: the left offset
//r: the right offset
//*Note: this is an internal function.*
createRopeStructure(par rope*, a cpstring, l int, r int) rope* {
    tmp = new rope
    
    tmp.left = null
    tmp.right = null
    
    // tmp.parent = par

    if r - l > ROPE_LEAF_LEN {
        tmp.str = null
        tmp.lCount = r - l
        tmp.lCount = tmp.lCount / 2
        node = tmp
        m = l + r
        m = m / 2
        node.left = createRopeStructure(node, a, l, m)
        node.right = createRopeStructure(node, a, m+1, r)
    } else {
        node = tmp
        tmp.lCount = r - l
        j = 0
        i = l
        arr cpstring = memoryAlloc(r+1)
        for i <= r {
            noCheck(arr[j] = a[i])
            j++;i++
        }
        tmp.str = arr
    }
    return tmp
}

//Used for setting the content of a rope.
//Returns the difference of size between the new one and the old one.
//The return value needs to be added to the parent ropes.
ropeSet(r rope*, a cpstring) int {
    n1 = strlen(a)
    diff = n1 - r.totalLen
    nr = createRopeStructure(null, a, 0, n1-1)
    nr.totalLen = n1
    nr.len = n1
    *r = *nr
    return diff
}

//Old way of concatenating ropes by specifying in order the ropes to concatenate.
concatenateRopes(root1 rope*, root2 rope*) rope* {
    n1 = root1.len
    tmp = new rope
    tmp.left = root1
    tmp.right = root2
    tmp.totalLen = root1.totalLen + root2.totalLen
    tmp.str = null
    return tmp
}

//Used to initiate a rope with a cpstring.
rope(a cpstring) rope* {
    n1 = strlen(a)
    r = createRopeStructure(null, a, 0, n1-1)
    r.totalLen = n1
    r.len = n1
    return r
}


// Example
// main(args []cpstring) int {
//     a = rope("This is a test: ") //Initiates rope a
//     b = rope("I'm a substring.") //Initiates rope b
//     i=0; for i < 99999 { //Iterates from 0 to 99998 (executes the following code 99999 times)
//         a = a + b //Concatenates b to a
//         i = i + 1 //Increments i by 1
//     }
//     println(a.toStr()) //Converts a to a cpstring and prints it
// }
