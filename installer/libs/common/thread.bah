#include "<pthread.h>"

#cLib "lpthread"

#define! pthread_mutex_t int
#define! pthread_t int
#define! pthread_cond_t int

#gc {
    #linux {
        #define! GC_pthread_create(id pthread_t*, attr ptr, func ptr, args ptr)
        #define! GC_pthread_join(id pthread_t, ret ptr)
        const __thread_create = GC_pthread_create
        const __thread_join = GC_pthread_join
    }
    #darwin {
        #define! GC_pthread_create(id pthread_t*, attr ptr, func ptr, args ptr)
        #define! GC_pthread_join(id pthread_t, ret ptr)
        const __thread_create = GC_pthread_create
        const __thread_join = GC_pthread_join
    }
    #windows {
        #define! pthread_create(id pthread_t*, attr ptr, func ptr, args ptr)
        #define! pthread_join(id pthread_t, ret ptr)
        const __thread_create = pthread_create
        const __thread_join = pthread_join 
    }
}

#rcp {
    #define! pthread_create(id pthread_t*, attr ptr, func ptr, args ptr)
    #define! pthread_join(id pthread_t, ret ptr)
    const __thread_create = pthread_create
    const __thread_join = pthread_join
}


#define! pthread_mutex_init(lock pthread_mutex_t*, m int)
#define! pthread_mutex_lock(lock pthread_mutex_t*)
#define! pthread_mutex_unlock(lock pthread_mutex_t*)
#define! pthread_mutex_destroy(lock pthread_mutex_t*)

#define! pthread_cond_init(cond pthread_cond_t*, attr int) int
#define! pthread_cond_signal(cond pthread_cond_t*) int
#define! pthread_cond_destroy(cond pthread_cond_t*) int
#define! pthread_cond_wait(cond pthread_cond_t*, mut pthread_mutex_t*) int

#define! pthread_self() int

const currentThread = pthread_self

//This structure implements a mutex.
//A mutex is a thread safe lock.
//*Note: the mutex needs to be initiated ans destroyed when you finished using it.*
struct mutex {
    id: pthread_mutex_t*

    //This initiaties the mutex.
    //You do not need to initiate the mutex when creating it with mutex().
    init() {
        this.id = memoryAlloc(sizeof(pthread_mutex_t))
        pthread_mutex_init(this.id, 0)
    }

    //This locks the mutex.
    //Every other thread trying to lock it will need to wait for it to be unlocked.
    lock() {
        pthread_mutex_lock(this.id)
    }

    //This unlocks the mutex.
    unlock() {
        pthread_mutex_unlock(this.id)
    }

    //This destroyes the mutex.
    destroy() {
        pthread_mutex_destroy(this.id)
    }

}

//This is a condition that while not true blocks the calling thread.
struct mutexCondition {
    id: pthread_cond_t

    //To initiate a condition.
    //You do not need to initiate the condition when creating it with mutexCondition().
    init() {
        pthread_cond_init(&this.id, null)
    }

    //To wait for another thread to signal that the condition may be true.
    //Usage:
    //for condition {
    // mutexCond.wait()
    //}
    wait(m mutex) {
        mid = m.id
        pthread_cond_wait(&this.id, mid)
    }

    //To signal a single thread that the condition may be true.
    send() {
        pthread_cond_signal(&this.id)
    }

    //To destroy the condition.
    destroy() {
        pthread_cond_destroy(&this.id)
    }

}

//Generates a mutexCondition and initiates it.
mutexCondition() mutexCondition {
    m = mutexCondition{}
    m.init()
    return m
}

//A wrapper for a thread.
//Note that for less advanced operation, you can use the keyword async.
struct thread {
    id: pthread_t
    
    //This will need to ne set by the user.
    //The specified function will be the entry point for the thread.
    handle: function(ptr)

    //This will launch the thread.
    create() {
        __thread_create(&this.id, null, this.handle, null)   
    }

    //This will launch the thread by passing to its entry point funtion an argument.
    //The argument can only be a pointer.
    createWithArg(arg ptr) {
        __thread_create(&this.id, null, this.handle, arg) 
    }

    //This waits until the thread has finished executting.
    wait() {
        __thread_join(this.id, null)
    }
}

//This initiates a mutex and returns it.
mutex() mutex {
    m = mutex{}
    m.init()
    return m
}

//Example
// #include "iostream.bah"
// #include "thread.bah"
// printHello() {
// println("Hello")
// }
// main() {
// t = thread{}
// t.handle = &printHello
// t.create()
// t.wait()
// }
