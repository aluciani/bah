#include "<pthread.h>"

#cLib "lpthread"

#define! GC_pthread_create(id int*, attr ptr, func ptr, args ptr)
#define! GC_pthread_join(id int, ret ptr)

#define! pthread_mutex_t int

#define! pthread_mutex_init(lock pthread_mutex_t*, m int)
#define! pthread_mutex_lock(lock pthread_mutex_t*)
#define! pthread_mutex_unlock(lock pthread_mutex_t*)
#define! pthread_mutex_destroy(lock pthread_mutex_t*)

//This structure implements a mutex.
//A mutex is a thread safe lock.
//*Note: the mutex needs to be initiated ans destroyed when you finished using it.*
struct mutex {
    id: pthread_mutex_t

    //This initiaties the mutex.
    init() {
        pthread_mutex_init(&this.id, 0)
    }

    //This locks the mutex.
    //Every other thread trying to lock it will need to wait for it to be unlocked.
    lock() {
        pthread_mutex_lock(&this.id)
    }

    //This unlocks the mutex.
    unlock() {
        pthread_mutex_unlock(&this.id)
    }

    //This destroyes the mutex.
    destroy() {
        pthread_mutex_destroy(&this.id)
    }

}

//A wrapper for a thread.
struct thread {
    id: int = -1
    
    //This will need to ne set by the user.
    //The specified function will be the entry point for the thread.
    handle: function(ptr)

    //This will launch the thread.
    create() {
        GC_pthread_create(&this.id, null, this.handle, null)   
    }

    //This will launch the thread by passing to its entry point funtion an argument.
    //The argument can only be a pointer.
    createWithArg(arg ptr) {
        GC_pthread_create(&this.id, null, this.handle, arg)   
    }

    //This waits until the thread has finished executting.
    wait() {
        if this.id == -1 {
            return
        }
        GC_pthread_join(this.id, null)
    }
}

//This initiates a mutex and returns it.
mutex() mutex {
    m = mutex{}
    m.init()
    return m
}


fastZeroSetMT(p ptr, s int) {
    byte int = 0
    i=0; for i < s {
        if i+8 > s {
            memset(noCheck(p+i), 0, s - i)
            break
        }
        v int* = noCheck(p+i)
        *v = byte
        i = i + 8
    }
}

FZSfunc = fastZeroSetMT



//Example
// #include "iostream.bah"
// #include "thread.bah"
// printHello() {
// println("Hello")
// }
// main() {
// t = thread{}
// t.handle = &printHello
// t.create()
// t.wait()
// }
