#include "<pthread.h>"

#cLib "lpthread"

#gc {
    #define! GC_pthread_create(id int*, attr ptr, func ptr, args ptr)
    #define! GC_pthread_join(id int, ret ptr)
}

#rcp {
    #define! pthread_create(id int*, attr ptr, func ptr, args ptr)
    #define! pthread_join(id int, ret ptr)
}

#define! pthread_mutex_t int
#define! pthread_cond_t int

#define! pthread_mutex_init(lock pthread_mutex_t*, m int)
#define! pthread_mutex_lock(lock pthread_mutex_t*)
#define! pthread_mutex_unlock(lock pthread_mutex_t*)
#define! pthread_mutex_destroy(lock pthread_mutex_t*)

#define! pthread_cond_init(cond pthread_cond_t*, attr int) int
#define! pthread_cond_signal(cond pthread_cond_t*) int
#define! pthread_cond_destroy(cond pthread_cond_t*) int
#define! pthread_cond_wait(cond pthread_cond_t*, mut pthread_mutex_t*) int

//This structure implements a mutex.
//A mutex is a thread safe lock.
//*Note: the mutex needs to be initiated ans destroyed when you finished using it.*
struct mutex {
    id: pthread_mutex_t

    //This initiaties the mutex.
    init() {
        pthread_mutex_init(&this.id, 0)
    }

    //This locks the mutex.
    //Every other thread trying to lock it will need to wait for it to be unlocked.
    lock() {
        pthread_mutex_lock(&this.id)
    }

    //This unlocks the mutex.
    unlock() {
        pthread_mutex_unlock(&this.id)
    }

    //This destroyes the mutex.
    destroy() {
        pthread_mutex_destroy(&this.id)
    }

}

struct mutexCondition {
    id: pthread_cond_t

    init() {
        pthread_cond_init(&this.id, 0)
    }

    wait(m mutex) {
        mid = m.id
        pthread_cond_wait(&this.id, &mid)
    }

    send() {
        pthread_cond_signal(&this.id)
    }

    destroy() {
        pthread_cond_destroy(&this.id)
    }

}

mutexCondition() mutexCondition {
    m = mutexCondition{}
    m.init()
    return m
}

//A wrapper for a thread.
struct thread {
    id: int = -1
    
    //This will need to ne set by the user.
    //The specified function will be the entry point for the thread.
    handle: function(ptr)

    //This will launch the thread.
    create() {
        #gc {
            GC_pthread_create(&this.id, null, this.handle, null)   
        }
        #rcp {
            pthread_create(&this.id, null, this.handle, null)   
        }
    }

    //This will launch the thread by passing to its entry point funtion an argument.
    //The argument can only be a pointer.
    createWithArg(arg ptr) {
        #gc {
            GC_pthread_create(&this.id, null, this.handle, arg) 
        }  
        #rcp {
            pthread_create(&this.id, null, this.handle, arg) 
        }
    }

    //This waits until the thread has finished executting.
    wait() {
        if this.id == -1 {
            return
        }
        #gc {
            GC_pthread_join(this.id, null)
        }
        #rcp {
            pthread_join(this.id, null)
        }
    }
}

//This initiates a mutex and returns it.
mutex() mutex {
    m = mutex{}
    m.init()
    return m
}

//Example
// #include "iostream.bah"
// #include "thread.bah"
// printHello() {
// println("Hello")
// }
// main() {
// t = thread{}
// t.handle = &printHello
// t.create()
// t.wait()
// }
