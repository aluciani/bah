#include "<unistd.h>"
#include "<signal.h>"
#include "<sys/types.h>"
#include "<sys/socket.h>"
#include "<netinet/in.h>"
#include "<netdb.h>"
#include "<openssl/ssl.h>"
#include "<openssl/err.h>"
#include "<openssl/bio.h>"

#include "cBinds.bah"

#include "iostream.bah"
#include "string.bah"
#include "exec.bah"
#include "rope.bah"
#include "thread.bah"

#define! socklen_t uint
#define! pid_t int
#define! sigset_t int32

struct! in_addr {
    s_addr: uint
}

struct! hostent {
    h_name: cpstring
    h_aliases: cpstring
    h_addrtype: int32
    h_length: int32
    h_addr: uint*
    h_addr_list: cpstring
}

struct! sigaction {
    sa_handler: ptr
    sa_sigation: ptr
    sa_mask: sigset_t
    sa_flags: int32
    sa_restorer: ptr
}

struct! sockaddr_in {
    sin_family: int
    sin_port: uint
    sin_addr: in_addr
    sin_zero: []char
}

struct http_url {
    path: string
    host: string
    proto: string
    port: string
}

#define! socket(a int, b int, c int) int
#define! gethostbyname(h cpstring) hostent*
#define! htons(p int) uint
#define! connect(sockfd int, ser_addr sockaddr_in*, s int) int
#define! send(sockfd int, msg cpstring, msglen int, c int) int
#define! recv(sockfd int, buff cpstring, bufflen int, c int) int
#define! close(sockfd int)
#define! htonl(inaddrt int) uint
#define! bind(sockfd int, ser_addr sockaddr_in*, s int) int
#define! listen(sockfd int, s int) int
#define! memset(str ptr, w int, s int)
#define! accept(sockfd int, cliaddr sockaddr_in*, clilen int*) int
#define! shutdown(fd int, flags int)

//Used for parsing an URL.
parseUrl(cps cpstring) http_url* {    
    u = new http_url
    s = string(cps)
    
    //get protocol
    i = 0
    max = s.length - 1
    hasProto = 0
    for i<s.length {
        c = s.charAt(i)
        if c == ':' {
            hasProto = 1
            break
        }
        i = i + 1
    }
    if hasProto == 1 {
    proto = string("")
    i = 0
    for s.charAt(i) != ':' {
        c = s.charAt(i)
        proto.append(charToString(c))       
        i = i + 1
    }
    i = i + 1
    u.proto = proto
    } else {
        u.proto = string("http")
        i = 0
    }
    for s.charAt(i) == '/' {
        if i == max {
            break
        }
        i = i + 1
    }

    //get host
    hn = string("")
    for s.charAt(i) != '/' && s.charAt(i) != ':' {
        c = s.charAt(i)
        hn.append(charToString(c))
        if i == max {
            break
        }
        i = i + 1
    }
    u.host = hn


    if i == max {
        u.path = string("/")
        if u.proto.compare("https") {
            u.port = string("443")
        } else {
            u.port = string("80")
        }
        return u
    }
    
    port = string("")
    if s.charAt(i) == ':' {
        i = i + 1
        for i < s.length {
            c = s.charAt(i)
            if c == '/' {
                break
            }
            port.append(charToString(c))
            i = i + 1
        }
    }
    u.port = port

    if i == max {
        u.path = string("/")
        if u.proto.compare("https") {
            u.port = string("443")
        } else {
            u.port = string("80")
        }
        return u
    }

    path = string("")
    for i<=max {
        c = s.charAt(i)
        path.append(charToString(c))
        i = i + 1
    }
    u.path = path

    return u
}

//Used for decoding an url encoded string.
urlDecode(encoded cpstring) cpstring {
    s = strAsArr(encoded)
    r = []char

    i=0; for i < len(s) {
        c = s[i]
        if c == '+' {
            r[len(r)] = ' '
        } else if c == '%' {
            hexStr = []char{s[i+1], s[i+2]}
            c = <char>strtol(arrAsStr(hexStr), null, 16)
            r[len(r)] = c
            i = i + 2

        } else {
            r[len(r)] = c
        }
        i = i + 1
    }

    return arrToStr(r)
}



//Used for closing a socket.
closeSocket(sockfd int) {
    shutdown(sockfd, noCheck(SHUT_RDWR))
}

//web server

sigchld_handler(signo int) {
    status int
    pid int
    pid = waitpid(-1, &status, 1)
    for pid > 0 {
        pid = waitpid(-1, &status, 1)
    }
}

//A type difinning http server erros.
#define http_serverError int

const HTTP_SERVER_NO_ERROR = <http_serverError>0
const HTTP_SERVER_SOCKET_ERROR = <http_serverError>1
const HTTP_SERVER_BIND_ERROR = <http_serverError>2
const HTTP_SERVER_LISTEN_ERROR = <http_serverError>3



//A wrapper for a http web server.
struct http_server {
    port: int
    running: int = 1
    sockfd:int = -1
    error: http_serverError = HTTP_SERVER_NO_ERROR

    //Event lisstener for when receiving connections.
    handle: function(http_server*, int)
    
    //Event listener for when server started successfully.
    done: function(http_server*)

    //To stop the server.
    stop() {
        if this.sockfd == -1 {
            println("cannot stop http_server, not running")
            return
        }
        this.running = 0
        closeSocket(this.sockfd)
    }



    //To start the server.
    listenAndServe() {
        this.error = HTTP_SERVER_NO_ERROR
        port = this.port
        servaddr sockaddr_in
        cliaddr sockaddr_in
        sa sigaction

        sockfd int = socket(2, 1, 0)

        if sockfd < 0 {
            println("http: error opening socket")
            this.error = HTTP_SERVER_SOCKET_ERROR
            return
        }

        servaddr.sin_family = 2
        saddr = in_addr{}
        saddr.s_addr = htonl(0)
        servaddr.sin_addr = saddr
        servaddr.sin_port = htons(port)

        isBind = bind(sockfd, &servaddr, 16)
        if isBind != 0 {
            close(sockfd)
            println("http: failed to bind port: '"+intToStr(port)+"'")
            this.error = HTTP_SERVER_BIND_ERROR
            return
        }

        isListening = listen(sockfd,1024)
        this.sockfd = sockfd

        if isListening < 0 {
            close(sockfd)
            println("http: failed to start listening")
            this.error = HTTP_SERVER_LISTEN_ERROR
            return
        }
        memset(<ptr>&sa, 0, 152)
        sa.sa_handler = sigchld_handler
        sigaction(17, &sa, 0)
        if this.done != null {
            doneT = thread{}
            doneT.handle = <ptr>this.done
            doneT.createWithArg(this)
            
            //this.done()
        }
        for this.running == 1 {
            clilen = 16
            connfd = accept(sockfd, &cliaddr, &clilen)
            
            if connfd < 0 {
                continue
            }

            childpid = fork()
            if childpid < 0 {
                println("http: failed to fork client handler")
                close(connfd)
                continue
            }

            if childpid == 0 {
                close(sockfd)
                this.handle(connfd)
                exit(0)
            }

            close(connfd)

        }

            this.stop()

    }

}

//To send a cpstring through the specified socket.
http_send(connfd int, s cpstring) {
    send(connfd, s, strlen(s), 0)
}

//To receive from a specified socket.
http_receive(connfd int) cpstring {
    buffer cpstring = memoryAlloc(1025)
    response = string("")
    nDataLength = recv(connfd,buffer,1024,0)
    if nDataLength < 1024 {
        response.append(buffer)
    } else {
        for nDataLength > 0 {
            response.append(buffer)
            if nDataLength < 1024 {
                trimAmm = 1024 - nDataLength
                response.trimRight(trimAmm)
                break
            } else {
                nDataLength = recv(connfd,buffer,1024,0)
            }
        }
    }
    return response.str()
}


//HTTP code 200 means everything is ok
const HTTP_OK = 200
//HTTP code 404 means file not found
const HTTP_NOT_FOUND = 404
//HTTP code 400 means that you deny access to this request
const HTTP_FORBIDDEN = 400
//HTTP code 500 means that the server encountered an internal error
const HTTP_ERROR = 500
//HTTP code 301 means a permanent redirection
const HTTP_REDIRECT = 301
//HTTP code 206 means content can be seeked up in a range
const HTTP_PARTIAL_CONTENT = 206



struct http_transport {
    connfd: int = -1
    headers: []string*
    code: int = HTTP_OK
    body: string*
    url: http_url*
    method: cpstring = ""
    path: cpstring = ""

        //To set a header by name.
    setHeader(name cpstring, value cpstring) {
        
        h = new string
        ln = toLower(string(name))
        h.set(ln.str())
        h.append(": ")
        h.append(value)

        lhs = len(this.headers)
        this.headers[lhs] = h
    }

    //To get the value of a header by name.
    getHeader(name cpstring) cpstring {
        headerName = string(name)
        headerName = toLower(headerName)
        headerName.append(":")
        i=0;for i < len(this.headers) {
            currentHeader = this.headers[i]
            if currentHeader.hasPrefix(headerName.str()) {
                header = string(currentHeader.str())
                space = 0
                c = header.charAt(headerName.length)
                if isSpace(c) {
                    space = 1
                }
                header.trimLeft(headerName.length+space)
                return header.str()
            }
            i=i+1
        }

        return ""

    }

    //To append to the body of the response.
    write(content cpstring) {
        body = this.body
        body.append(content)
    }

}

openSocket(host cpstring, port int) int {
    serv_addr sockaddr_in
    sockfd = socket(2, 1, 0)
    if sockfd < 0 {
        panic("http: error opening socket")
    }

    server hostent* = gethostbyname(host)
    if server == null {
        panic("http: error resolving host")
    }

    serv_addr.sin_port = htons(port)
    serv_addr.sin_family = 2
    ha = server.h_addr
    saddr = in_addr{}
    saddr.s_addr = *ha
    serv_addr.sin_addr = saddr
        
        
    canConnect = connect(sockfd,&serv_addr,16)
    if canConnect < 0 {
        panic("error: error connecting socket")
    }
    return sockfd
}




//A wrapper for HTTP responses. You will be able to set/retreive the headers sent/receive.
//You will encounter this when doing a request or sending a response to the client.
struct http_response extend http_transport {
    headersSent: bool = false
    //Send the response.
    //*Use it only when sending response to the client from a http_server*.
    send() {
        if this.headersSent == false {
            s = string("HTTP/1.0 ")
            if this.code == HTTP_OK {
                s.append("200 OK")
            } else if this.code == HTTP_NOT_FOUND {
                s.append("404 Not Found")
            } else if this.code == HTTP_FORBIDDEN {
                s.append("400 Bad Request")
            } else if this.code == HTTP_ERROR {
                s.append("500 Internal Server Error")
            } else if this.code == HTTP_REDIRECT {
                s.append("301 Moved Permanently")
            } else if this.code == HTTP_PARTIAL_CONTENT {
                s.append("206 Partial Content")
            } else {
                s.append(intToStr(this.code))
            }
            s.append("\r\n")
            
            i = 0
            
            for i < len(this.headers) {
                e = this.headers[i]
                s.append(e.content)
                s.append("\r\n")
                i = i + 1
            }
            
            s.append("\r\n")

            
            s.append(this.body.content)
            this.body.set("")
            http_send(this.connfd, s.content)
            headersSent = true
        } else {
            http_send(this.connfd, this.body.str())
            this.body.set("")
        }

    }


}

//To build a HTTP response.
//You will need to populate it before sending it to the client.
http_response(connfd int) http_response {
    resp = http_response{}
    resp.connfd = connfd

    resp.setHeader("Server", "bah-http-framework")
    resp.setHeader("Connection", "close")

    body = new string
    body.set("")
    resp.body = body

    return resp
}






makeRespFromBody(response string) http_response* {

    resp = new http_response
    resp.body = new string

    lines = splitString(response, "\r\n")
    if len(lines) == 0 {
        return resp
    }


    i = 0 
    head = lines[0]
    for i < head.length {
        c = head.charAt(i)
        if c == ' ' {
            i = i + 1
            break
        }
        i = i + 1
    }

    httpCode = string("")
    for i < head.length {
        c = head.charAt(i)
        httpCode.append(charToString(c))
        if c == ' ' {
            break
        }
        i = i + 1
    }
    httpCodeInt = stringToInt(httpCode)
    resp.code = httpCodeInt
    
    isBody = 0
    
    max = len(lines) - 1
    body = string("")
    i = 1; for i < len(lines) {

        line = lines[i]
        if isBody == 1 {
            s = string(line.str())
            if i < max {
                s.append("\r\n")
            }
            body.append(s.str())
            i = i + 1
            continue
        }
        if i > 0 {
            pl = lines[i-1]
            if strlen(pl.str()) == 0 {
                isBody = 1
                line.trimLeft(2)
                continue
            }
        }

        header = new string
        headerName = string(splitStringBefore(line, ":"))
        if headerName.length > 0 {
            headerName = toLower(headerName)
            line.trimLeft(headerName.length)
            line.prepend(headerName.str())
        }
        header.set(line.str())
        lrh = len(resp.headers)
        resp.headers[lrh] = header

        i = i + 1
    }

    transferEncoding = resp.getHeader("Transfer-Encoding")
    if strcmp(transferEncoding, "chunked") == 0 {
        
        resp.body.set("")
        
        for true == true {
            chunkLen = splitStringBefore(body, "\r\n")
            if strcmp(chunkLen, "0") == 0 {
                break
            }
            l = strtol(chunkLen, noCheck(0), 16)
            l = l
            body.trimLeft(strlen(chunkLen)+2)
            chunk cpstring = memoryAlloc(l+1)
            memcpy(chunk, body.content, l)
            resp.body.append(chunk)
            body.trimLeft(l+2)
        }

    } else {
        resp.body.set(body.str())
    }
    return resp


}



//making requests

//SSL - TLS (https)

//#cLib "lssl" "lcrypto"
#cLib "w /opt/bah/libs/libssl.a" "w /opt/bah/libs/libcrypto.a"

#define! BIO int
#define! SSL int
#define! SSL_CTX int

#define! SSL_library_init()
#define! SSLv23_client_method() int
#define! SSL_CTX_new(m int) SSL_CTX*
#define! BIO_new_ssl_connect(ctx SSL_CTX*) BIO*
#define! BIO_set_conn_hostname(bio BIO*, h cpstring)
#define! BIO_do_connect(bio BIO*) int
#define! BIO_write(bio BIO*, cont cpstring, size int) int
#define! BIO_should_retry(bio BIO*) int
#define! BIO_read(bio BIO*, buff cpstring, size int) int
#define! BIO_free_all(bio BIO*)
#define! SSL_CTX_free(ctx SSL_CTX*)
#define! BIO_get_ssl(bio BIO*, ssl SSL**)
#define! SSL_set_mode(ssl SSL*, mode int)

//Used for making TLS requests.
//*This is an internal function, you should know what you're doing if you decide to use it.*
makeRawHttpsRequest(host cpstring, message cpstring) cpstring {
    
    SSL_library_init()
    ssl SSL*
    ctx = SSL_CTX_new(SSLv23_client_method())

    if ctx == null {
        panic("http: cannot initialize ssl context")
    }

    bio = BIO_new_ssl_connect(ctx)

    BIO_get_ssl(bio, &ssl)
    SSL_set_mode(ssl, 4)

    BIO_set_conn_hostname(bio, host)
    if BIO_do_connect(bio) <= 0 {
        panic("http: error connecting through ssl to '"+host+"'")
    }
    success = BIO_write(bio, message, strlen(message))

    if success <= 0 {
        if BIO_should_retry(bio) == 0 {
            panic("http: failed sending request")
        }
    }

    buff cpstring = memoryAlloc(1025)
    resp = string("")
    for true == true {
        memset(<ptr>buff, 0, 1025)
        size = BIO_read(bio, buff, 1025)
        if size <= 0 {
            break
        }
        resp.append(buff)
    }
    BIO_free_all(bio)
    SSL_CTX_free(ctx)
    return resp.str()

}




//A wrapper for requests.
//When receiving a connection, you will be able to retreive the passed headers, path... from the client.
struct http_request extend http_transport {
    request: cpstring
    form: []string

    send() http_response* {
        socketWasOpenned = true
        isTLS = false
        host = ""
        if this.connfd == -1 {
            if this.url != null {
                socketWasOpenned = false
                if strlen(this.path) == 0 {
                    this.path = this.url.path.str()
                }
                if this.url.proto.compare("https") {
                    isTLS = true
                    if this.url.port.length == 0 {
                        this.url.port.set("443")
                    }
                    host = this.url.host.str()+":"+this.url.port.str()
                } else {
                    if this.url.port.length == 0 {
                        this.url.port.set("80")
                    }
                    this.connfd = openSocket(this.url.host.str(), atoi(this.url.port.str()))
                }
                    this.setHeader("host", this.url.host.str()+":"+this.url.port.str())
            } else {
                return null
            }            
        }


        method = this.method
        if strlen(method) == 0 {
            method = "GET"
        }


        path = this.path
        if strlen(path) == 0 {
            path = "/"
        }
        message = rope(method +" "+ path + " HTTP/1.0\r\n")
        i=0; for i < len(this.headers) {
            h = this.headers[i]
            message = message + rope(h.str() + "\r\n")
            i = i + 1
        }
        message = message + rope("\r\n")

        if this.body != null {
            message = message + rope(this.body.str())
        }

        msg = message.toStr()

        response = string("")
        if isTLS == true {
            response.set(makeRawHttpsRequest(host, msg))
        } else {

            if send(this.connfd, msg, strlen(msg), 0) <= 0 {
                panic("http: error sending trought socket")
            }

            buffer cpstring = memoryAlloc(1025)
            nDataLength = recv(this.connfd,buffer,1024,0)
            for nDataLength > 0 {
                response.append(buffer)
                if nDataLength < 1024 {
                    trimAmm = 1024 - nDataLength
                    response.trimRight(trimAmm)
                }
                nDataLength = recv(this.connfd,buffer,1024,0)
            }

        }

        if socketWasOpenned == false {
            closeSocket(this.connfd)
        }

        return makeRespFromBody(response)
    }

    //Call this to parse the post data form.
    //This will return false if anything goes wrong while parsing the form.
    parseForm() bool {
        if this.method != "POST" {
            return false
        }

        contentType = this.getHeader("Content-Type")
        if strHasPrefix(contentType, "multipart/form-data") {
            //cannot handle multipart for now
            return false
        }

        if contentType == "application/x-www-form-urlencoded" {
            body = this.body
            tmpBdy = *body
            tmpBdy.trimRight(2)
            this.form = splitString(tmpBdy, "&")
        }


        return true
    }

    //Used for getting the value of a form's input.
    getFormValue(name cpstring) cpstring {
        rName = string(name)
        rName = toLower(rName)
        i=0; for i < len(this.form) {
            f = this.form[i]
            if f.hasPrefix(rName.str() + "=") {
                f.trimLeft(rName.length + 1)
                f.trim()

                return urlDecode(f.str())
            }
            i = i + 1
        }
        return ""
    }

    //Used for getting the value of a cookie.
    getCookie(name cpstring) cpstring {
        encoded = string(this.getHeader("cookie"))
        cookies = splitString(encoded, ";")
        r = []char

        i=0; for i < len(cookies) {
            c = cookies[i]
            parts = splitString(c, "=")
            n = parts[0]
            n.trim()
            v = parts[1]

            if urlDecode(n.str()) == name {
                return urlDecode(v.str())
            }

            i = i + 1
        }
        return ""
    }

}

//Used for parsing the request
http_request(connfd int) http_request {
    r = http_request{}
    r.connfd = connfd
    reqcps = http_receive(connfd)
    req = string(reqcps)
    i = 0
    //parse method (GET, POST, PUT, DELETE...)
    method = string("")
    for i < req.length {
        c = req.charAt(i)
        if c == ' ' {
            break
        }
        cs = charToString(c)
        method.append(cs)
        i = i + 1
    }
    r.method = method.str()

    //parse path (/)
    path = string("")
    i = i + 1
    for i < req.length {
        c = req.charAt(i)
        if c == ' ' {
            break
        }
        cs = charToString(c)
        path.append(cs)
        i = i + 1
    }
    r.path = path.str()

    //trim rest of request (HTTP/1.1)
    for i < req.length {
        c = req.charAt(i)
        if c == <char>10 {
            break
        }
        i = i + 1
    }
    
    req.trimLeft(i)
    lines = splitString(req, "\r\n")

    isBody = false
    r.body = new string
    i=0; for i < len(lines) {
        l = lines[i]
        if isBody == true {
            r.body.append(l.str() + "\r\n")
        } else if l.length == 0 {
            isBody = true
        } else {
            l.trim()
            headerName = splitStringBefore(l, ":")
            headerCont = string(l.str())
            headerCont.trimLeft(strlen(headerName) + 1)
            headerCont.trim()
            r.setHeader(headerName, headerCont.str())
        }
        
        i = i + 1
    }


    r.request = reqcps

    return r
}


//Used for making any request.
//Method is either http or https. The arguments (args) are the variables to pass (can be post or get variable) formatted as: name=value.
makeRawRequest(method cpstring, u http_url*, args []cpstring) http_response {
    proto = u.proto
    host = u.host
    path = u.path
    
    serv_addr sockaddr_in

    portno = 80
    if u.port.length > 0 {
        portno = atoi(u.port.content)
    }
    response = string("")
    
    message = string(" ")
    message.prepend(method)
    message.append(path.str())
    serialArgs = string("?")
    largs = len(args)
    max = largs - 1
    i = 0; for i < largs {
        serialArgs.append(args[i])
        if i < max {
            serialArgs.append("&")
        }
        i = i + 1
    }
    if largs > 0 {
        message.append(serialArgs.str())
    }
    message.append(" HTTP/1.0\r\nHost: ")
    
    if proto.compare("https") {
        host.append(":443")
    }
    
    message.append(host.str())
    message.append("\r\nConnection: close\r\n\r\n")
    

    if proto.compare("https") {
        resp = makeRawHttpsRequest(host.str(), message.str())
        response.set(resp)

    } else {

        sockfd = socket(2, 1, 0)
        if sockfd < 0 {
            panic("http: error opening socket")
        }

        server hostent* = gethostbyname(host.content)
        if server == null {
            panic("http: error resolving host")
        }

        serv_addr.sin_port = htons(portno)
        serv_addr.sin_family = 2
        ha = server.h_addr
        saddr = in_addr{}
        saddr.s_addr = *ha
        serv_addr.sin_addr = saddr
        
        
        canConnect = connect(sockfd,&serv_addr,16)
        if canConnect < 0 {
            panic("error: error connecting socket")
        }

        isSend = send(sockfd, message.content, message.length, 0)

        if isSend <= 0 {
            panic("http: error sending trought socket")
        }

        buffer cpstring = memoryAlloc(1025)
        nDataLength = recv(sockfd,buffer,1024,0)
        for nDataLength > 0 {
            response.append(buffer)
            if nDataLength < 1024 {
                trimAmm = 1024 - nDataLength
                response.trimRight(trimAmm)
            }
            nDataLength = recv(sockfd,buffer,1024,0)
        }

        close(sockfd)

    }

    resp = http_response{}
    resp.body = new string

    lines = splitString(response, "\r\n")
    if len(lines) == 0 {
        return resp
    }


    i = 0 
    head = lines[0]
    for i < head.length {
        c = head.charAt(i)
        if c == ' ' {
            i = i + 1
            break
        }
        i = i + 1
    }

    httpCode = string("")
    for i < head.length {
        c = head.charAt(i)
        httpCode.append(charToString(c))
        if c == ' ' {
            break
        }
        i = i + 1
    }
    httpCodeInt = stringToInt(httpCode)
    resp.code = httpCodeInt
    
    isBody = 0
    
    max = len(lines) - 1
    body = string("")
    i = 1; for i < len(lines) {

        line = lines[i]
        if isBody == 1 {
            s = string(line.str())
            if i < max {
                s.append("\r\n")
            }
            body.append(s.str())
            i = i + 1
            continue
        }
        if i > 0 {
            pl = lines[i-1]
            if strlen(pl.str()) == 0 {
                isBody = 1
                line.trimLeft(2)
                continue
            }
        }

        header = new string
        headerName = string(splitStringBefore(line, ":"))
        if headerName.length > 0 {
            headerName = toLower(headerName)
            line.trimLeft(headerName.length)
            line.prepend(headerName.str())
        }
        header.set(line.str())
        lrh = len(resp.headers)
        resp.headers[lrh] = header

        i = i + 1
    }

    transferEncoding = resp.getHeader("Transfer-Encoding")
    if strcmp(transferEncoding, "chunked") == 0 {
        
        resp.body.set("")
        
        for true == true {
            chunkLen = splitStringBefore(body, "\r\n")
            if strcmp(chunkLen, "0") == 0 {
                break
            }
            l = strtol(chunkLen, noCheck(0), 16)
            l = l
            body.trimLeft(strlen(chunkLen)+2)
            chunk cpstring = memoryAlloc(l+1)
            memcpy(chunk, body.content, l)
            resp.body.append(chunk)
            body.trimLeft(l+2)
        }

    } else {
        resp.body.set(body.str())
    }


    return resp

}

//Used for making simple get request.
get(url cpstring) http_response {
    args = []cpstring
    r = makeRawRequest("GET", parseUrl(url), args)
    return r
}

//Used for making simple post request with variables (args) formatted as name=value.
post(url cpstring, args []cpstring) http_response {
    r = makeRawRequest("POST", parseUrl(url), args)
    return r
}

//Checks if a port is available.
//*Note: this command is very slow.*
isPortAvailable(port int) int {
    cmdS = intToString(port)
    cmdS.prepend("netstat -antu | grep :")
    cmd = command(cmdS.str())
    cmd.error = false
    s = cmd.run()
    if strlen(s) > 0 {
        return 0
    }
    return 1
}

//Example
// #include "http.bah"
//
//
// server(serv http_server*, connfd int) {
//
//     request = http_request(connfd)
//     response = http_response(connfd)
//
//     response.setHeader("Content-Type", "text/html")
//
//     response.write("Current path:")
//     response.write(request.path)
//
//     response.write("\nIt works!")
//     response.send()
//
// }
//
// main() {
//  
//     s = http_server{}
//     s.port = 8080
//     s.handle = server
//     s.listenAndServe()
//
// }