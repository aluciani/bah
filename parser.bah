#include "iostream.bah"
#include "string.bah"

#include "./lexer.bah"
#include "./var.bah"

debugLine(line []Tok) {
    cont = ""
    i=0; for i < len(line) {
        t = line[i]
        cont = cont + " '" + t.cont + "'"
        i++
    }
    println(cont)
}


#define lineType int

const LINE_TYPE_INCLUDE = <lineType>0
const LINE_TYPE_DEFINE = <lineType>1
const LINE_TYPE_CONST = <lineType>2
const LINE_TYPE_VAR = <lineType>3
const LINE_TYPE_FN_DECL = <lineType>4
const LINE_TYPE_FN_CALL = <lineType>5
const LINE_TYPE_STRUCT = <lineType>6
const LINE_TYPE_CLIB = <lineType>7
const LINE_TYPE_RETURN = <lineType>8
const LINE_TYPE_IF = <lineType>9
const LINE_TYPE_ELSE = <lineType>10
const LINE_TYPE_MACRO = <lineType>11
const LINE_TYPE_FOR = <lineType>12

getLineType(line []Tok) lineType {
    ft = line[0]
    if ft.type == TOKEN_TYPE_KEYWORD {
        if ft.cont == "#include" {
            return LINE_TYPE_INCLUDE
        } else if ft.cont == "#define" {
            return LINE_TYPE_DEFINE
        } else if ft.cont == "const" {
            return LINE_TYPE_CONST
        } else if ft.cont == "struct" {
            return LINE_TYPE_STRUCT
        } else if ft.cont == "#cLib" {
            return LINE_TYPE_CLIB
        } else if ft.cont == "return" {
            return LINE_TYPE_RETURN
        } else if ft.cont == "if" {
            return LINE_TYPE_IF
        } else if ft.cont == "else" {
            return LINE_TYPE_ELSE
        } else if ft.cont == "#macro" {
            return LINE_TYPE_MACRO
        }
    } else if ft.type == TOKEN_TYPE_VAR {
        if len(line) == 1 {
            throwErr(&ft, "Cannot declare var {TOKEN} without a type.")
        }
        st = line[1]
        if st.type == TOKEN_TYPE_ENCL {
            if st.cont == "(" {
                lt = line[len(line)-1]
                if lt.type == TOKEN_TYPE_ENCL {
                    if lt.cont == "}" {
                        return LINE_TYPE_FN_DECL
                    }
                }
                return LINE_TYPE_FN_CALL
            }
        }
        return LINE_TYPE_VAR
    }
}


//Inline parsing
parseCast(line []Tok, elems Elems*) []Tok {
    nl = []Tok
    i=0; for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_SYNTAX {
            if t.cont == "<" {
                max = i + 3
                if max < len(line) {
                    nt = line[i+1]
                    nnt = line[i+2]
                    nnnt = line[i+3]
                    if nt.type == TOKEN_TYPE_VAR {
                        if nnt.type == TOKEN_TYPE_SYNTAX {
                            if nnt.cont == ">" {
                                
                                nnnt.bahType = nt.cont
                                cCast = getCType(nt.cont, elems)
                                cCastStr = cCast.str()
                                nnnt.cont = "("+cCastStr+")"+nnnt.cont
                                nl[len(nl)] = nnnt
                                i = i + 4
                                continue
                            }
                        }
                    }
                }
            }
        }

        nl[len(nl)] = t

        i++
    }
    return nl
}

#define parseLines(ts []Tok, elems Elems*)
includeFile(ccstr cpstring, elems Elems*) bool {
    includes = compilerState.includes
    i=0; for i < len(includes) {
        if includes[i] == ccstr {
            return true
        }
        i++
    }
    
    fm = fileMap{}
    fileName = BAH_DIR + ccstr
    f = fm.open(fileName)
    if fm.isValid() == 0 {
        fileName = ccstr
        f = fm.open(fileName)
        if fm.isValid() == 0 {
            return false
        }
    }
    oFile = compilerState.currentFile
    compilerState.currentFile = fileName
    includes[len(includes)] = ccstr
    tokens = lexer(f)
    fm.close()
    if len(tokens) == 0 {
        panic("File '"+ccstr+"' not recognized.")
    }
    parseLines(tokens, elems)
    compilerState.currentFile = oFile 
    return true
}

parseInclude(l []Tok, elems Elems*) {
    if len(l) > 2 {
        throwErr(&l[len(l)-1], "Invalid usage of include, ending by {TOKEN}.")
    }
    strt = l[1]
    if strt.type != TOKEN_TYPE_STR {
        throwErr(&strt, "Cannot use {TOKEN} as string in include.")
    }
    cc = string(strt.cont)
    cc.trimLeft(1)
    cc.trimRight(1)
    ccstr = cc.str()
    if cc.hasPrefix("<") {
        OUTPUT = OUTPUT + "#include "+ccstr+"\n"
    } else {
        if includeFile(ccstr, elems) == false {
            throwErr(&strt, "Could not find file {TOKEN}.")
        }
    }
}

parseOperations(line []Tok, elems Elems*) []Tok {
    signs = []cpstring{"|", "&", "%", "+", "-", "*", "/"}
    nl = []Tok{line[0]}
    i=1; for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_SYNTAX {
            if inArrayStr(t.cont, signs) {
                max = i + 1
                if max >= len(line) {
                    throwErr(&t, "Cannot use {TOKEN} on nothing.")
                }
                pt = nl[len(nl)-1]
                nt = line[i+1]
                if t.cont == "-" {
                    if nt.type == TOKEN_TYPE_INT {
                        if pt.isValue == false {
                            nt.cont = t.cont + nt.cont
                            nl[len(nl)] = nt
                            i = i + 2
                            continue
                        }
                    }
                }
                ptt = getTypeFromToken(&pt, true, elems)
                ntt = getTypeFromToken(&nt, true, elems)
                if ptt != ntt {
                    throwErr(&nt, "Cannot use {TOKEN} ("+ntt+") as "+ptt+".")
                }
                t.isValue = true
                if ptt == "cpstring" {
                    if t.cont != "+" {
                        throwErr(&t, "Can only do concatenation (+) on cpstrings, not {TOKEN}.")
                    }
                    t.cont = "concatCPSTRING("+pt.cont+","+nt.cont+")"
                } else {
                    t.cont = pt.cont + " " + t.cont + " " + nt.cont
                }
                t.type = TOKEN_TYPE_VAR
                t.bahType = ptt
                t.pos = pt.pos
                nl[len(nl)-1] = t
                i = i + 2
                continue
            }
        }
        nl[len(nl)] = t
        i++
    }
    return nl
}

parseStructType(line []Tok, elems Elems*) []Tok {
    nl = []Tok

    i=0; for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_VAR {
            ctbt = string(t.bahType)
            if ctbt.hasPrefix("[]") {
                nl[len(nl)] = t
                i++
                continue
            }
            i++
            if i < len(line) {
                nt = line[i]
                if nt.cont == "{" {
                    i++
                    s = searchStruct(t.cont, elems)
                    if s == null {
                        throwErr(&t, "Unknown struct name {TOKEN}.")
                    }
                    memory = ""
                    for i < len(line) {
                        t = line[i]
                        if t.cont == "}" {
                            break
                        }
                        memory = memory + t.cont + " "
                        //TODO: setting struct content inside braces
                        i++
                    }
                    t.bahType = s.name
                    t.cont = "{"+memory+"}"
                    t.isValue = true
                    nl[len(nl)] = t
                    i++
                    continue
                    
                } else {
                    i--
                }
            }
        }
        nl[len(nl)] = t
        i++
    }

    return nl
}

parseStructVars(line []Tok, elems Elems*) []Tok {
    nl = []Tok

    i=0; for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_VAR {
            i++
            for i < len(line) {
                it = line[i]
                if it.cont != "." {
                    break
                }
                    v = searchVar(t.cont, elems)
                    if v == null {
                        throwErr(&t, "Unknown var {TOKEN}.")
                    }
                    ct = string(v.type)
                    sep = "."
                    if ct.count("*") {
                        sep = "->"
                    }
                    s = searchStruct(v.type, elems)
                    i++
                    nt = line[i]
                    if nt.type != TOKEN_TYPE_VAR {
                        throwErr(&nt, "Cannot use {TOKEN} as struct member name.")
                    }
                    memb = searchStructMemb(nt.cont, s, elems)
                    if memb == null {
                        throwErr(&nt, "Unknown struct member {TOKEN}.")
                    }
                    t.cont = t.cont + sep + memb.name
                i++
            }
            nl[len(nl)] = t
            continue
        }

        nl[len(nl)] = t
        i++
    }

    return nl
}

parseArrayType(line []Tok, elems Elems*) []Tok {
    nl = []Tok

    i=0; for i < len(line) {
        t = line[i]
        if t.cont == "[" {
            i++
            if i < len(line) {
                t = line[i]
                if t.cont == "]" {
                    i++
                    if i < len(line) {
                        t = line[i]
                        if t.type != TOKEN_TYPE_VAR {
                            throwErr(&t, "Cannot use {TOKEN} as array type.")
                        }
                        arrElem = t.cont
                        t.bahType = "[]"+arrElem
                        t.cont = ""
                        t.isValue = true
                        nl[len(nl)] = t
                        i++
                        continue
                    }
                }
            }
        }

        nl[len(nl)] = t
        i++
    }
    return nl
}

parseBool(line []Tok, elems Elems*) []Tok {
    nl = []Tok

    comparators = []cpstring{"==", "!=", ">", "<", "<=", ">="}
    compSep = []cpstring{"||", "&&"}

    i=0; for i < len(line) {
        t = line[i]

        if inArrayStr(t.cont, comparators) {
            if i == 0 {
                throwErr(&t, "Cannot use {TOKEN} to compare with nothing.")
            }
            pt = nl[len(nl)-1]
            max = i + 1
            if max >= len(line) {
                throwErr(&t, "Cannot use {TOKEN} to compare with nothing.")
            }
            nt = line[i+1]
            ptt = getTypeFromToken(&pt, true, elems)
            ntt = getTypeFromToken(&nt, true, elems)
            if ptt != ntt {
                throwErr(&nt, "Cannot compare {TOKEN} ("+ntt+") to "+ptt+".")
            }
            if ptt == "cpstring" {
                if t.cont == "==" {
                    pt.cont = "(strcmp("+pt.cont+", "+nt.cont+") == 0)"
                } else if t.cont == "!=" {
                    pt.cont = "(strcmp("+pt.cont+", "+nt.cont+") != 0)"
                } else if t.cont == ">" {
                    pt.cont = "(strlen("+pt.cont+") > srtlen("+nt.cont+"))"
                } else if t.cont == "<" {
                    pt.cont = "(strlen("+pt.cont+") < srtlen("+nt.cont+"))"
                } else if t.cont == ">=" {
                    pt.cont = "(strlen("+pt.cont+") >= srtlen("+nt.cont+"))"
                } else if t.cont == "<=" {
                    pt.cont = "(strlen("+pt.cont+") <= srtlen("+nt.cont+"))"
                }
            } else {
                pt.cont = "(" + pt.cont + t.cont + nt.cont + ")"
            }
            pt.bahType = "bool"
            nl[len(nl)-1] = pt
            i = i + 2
            continue
        }

        nl[len(nl)] = t
        i++
    }


    copy(line, nl)
    clear(nl)
    i=0; for i < len(line) {
        t = line[i]
        if inArrayStr(t.cont, compSep) {
            if i == 0 {
                throwErr(&t, "Cannot use {TOKEN} to compare with nothing.")
            }
            pt = nl[len(nl)-1]
            max = i + 1
            if max >= len(line) {
                throwErr(&t, "Cannot use {TOKEN} to compare with nothing.")
            }
            nt = line[i+1]
            ptt = getTypeFromToken(&pt, true, elems)
            ntt = getTypeFromToken(&nt, true, elems)
            if ptt != "bool" {
                throwErr(&pt, "Cannot compare {TOKEN} that is not a bool.")
            }
            if ntt != "bool" {
                throwErr(&nt, "Cannot compare {TOKEN} that is not a bool.")
            }
            pt.cont = "(" + pt.cont + t.cont + nt.cont + ")"
            pt.bahType = "bool"
            nl[len(nl)-1] = pt
            i = i + 2
            continue

        }

        nl[len(nl)] = t
        i++
    }

    return nl
}

parsePointers(l []Tok) []Tok {
    nl = []Tok

    ptrOpers = []cpstring{"&", "*"}

    i=0; for i < len(l) {
        t = l[i]

        if t.cont == "*" {
            if i > 0 {
                pt = nl[len(nl)-1]
                if pt.type == TOKEN_TYPE_VAR {
                    max = i + 1
                    if max < len(l) {
                        nt = l[i+1]
                        if nt.isValue == false {
                            pt.cont = pt.cont + t.cont
                            nl[len(nl)-1] = pt
                            i++
                            continue
                        }
                    } else {
                        pt.cont = pt.cont + t.cont
                        nl[len(nl)-1] = pt
                        i++
                        continue
                    }
                }
            }
        }

        if inArrayStr(t.cont, ptrOpers) {
            if i > 0 {
                pt = nl[len(nl)-1]
                if pt.isValue {
                    nl[len(nl)] = t
                    i++
                    continue            
                }
            }
            i++
            if i < len(l) {
                nt = l[i]
                if nt.type == TOKEN_TYPE_VAR {
                    nt.cont = t.cont + nt.cont
                    nl[len(nl)] = nt
                    i++
                    continue
                }
            }
        }

        nl[len(nl)] = t
        i++
    }

    return nl
}

parseFnCall(l []Tok, elems Elems*) []Tok {
    nl = []Tok

    found = false
    i=0; for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_VAR {
            i++
            if i < len(l) {
                t = l[i]
                if t.cont == "(" {
                    found = true
                    break
                }
            }
        }
        i++
    }

    if found == false {
        return l
    }

    i=0; for i < len(l) {
        ot = l[i]

        if ot.type == TOKEN_TYPE_VAR {
            i++
            if i < len(l) {
                nt = l[i]
                if nt.cont == "(" {
                    nbPar = 1
                    i++
                    fnName = ot.cont
                    fn = searchFunc(fnName, elems)
                    if fn == null {
                        throwErr(&ot, "Unknown function {TOKEN}.")
                    }
                    varName = string("")
                    fnStr = string(fnName)
                    if hasStructSep(fnStr) {
                        varName = splitStructSepBefore(fnStr)
                        v = searchVar(varName, elems)
                        vct = string(v.type)
                        if vct.count("*") == 0 {
                            varName.prepend("&")
                        }
                    }
                    ot.cont = fnName+"("
                    fnArgs = fn.args
                    paramIndex = 0
                    memory = []Tok
                    if varName.length > 0 {
                        tk = Tok{}
                        tk.cont = varName.str()
                        tk.type = TOKEN_TYPE_VAR
                        tk.isValue = true
                        memory[len(memory)] = tk

                        nt = l[i]
                        if nt.cont != ")" {
                        tk = Tok{}
                        tk.cont = ","
                        tk.type = TOKEN_TYPE_SYNTAX
                        tk.isValue = false
                        memory[len(memory)] = tk
                        }
                    }
                    for i < len(l) {
                        t = l[i]
                        if t.cont == "(" {
                            nbPar++
                        } else if t.cont == ")" {
                            nbPar--
                        }
                        memory[len(memory)] = t
                        if nbPar == 0 {
                            i++
                            break
                        }
                        i++    
                    }

                    if fnName == "noCheck" {
                        j=0; for j < len(memory) {
                            t = memory[j]
                            ot.cont = ot.cont + " " + t.cont
                            j++
                        }
                        ot.cont = ot.cont
                        ot.type = TOKEN_TYPE_FUNC
                        ot.bahType = ""
                        nl[len(nl)] = ot
                        continue
                    }


                    memory = parseFnCall(memory, elems)
                    memory = parseArrayType(memory, elems)
                    memory = parseStructVars(memory, elems)
                    memory = parseCast(memory, elems)
                    memory = parseOperations(memory, elems)
                    memory = parseBool(memory, elems)

                    //debugLine(memory)

                    j=0;for j < len(memory) {
                        t = memory[j]
                        
                        if paramIndex >= len(fnArgs) {
                            throwErr(&t, "Too many arguments in function call.")
                        }
                        arg = fnArgs[paramIndex]
                        tt = getTypeFromToken(&t, true, elems)
                        if tt != arg.type {
                            throwErr(&t, "Cannot use {TOKEN} (" + tt + ") as " + arg.type + " in function call.")
                        }
                        ot.cont = ot.cont + t.cont
                        j++
                        t = memory[j]
                        if t.cont != "," {
                            if t.cont == ")" {
                                j++
                                paramIndex++
                                break
                            } else {
                                throwErr(&t, "Expected separator between values, not {TOKEN} in function call.")
                            }
                        } else {
                            paramIndex++
                            ot.cont += ","
                        }

                        j++
                    }
                    
                    if paramIndex < len(fnArgs) {
                        throwErr(&ot, "Not enough arguments in function call, ending by {TOKEN}.")
                    }
                    ot.cont += ")"
                    ot.type = TOKEN_TYPE_FUNC
                    ot.bahType = fn.returns.type
                    nl[len(nl)] = ot
                    continue
                }
            }
            i--
        }

        nl[len(nl)] = ot
        i++
    }

    return nl
}


//Parser for every line types

parseVar(l []Tok, elems Elems*) {
    ft = l[0]
    ftcontStr = string(ft.cont)
    if ftcontStr.count("(") {
        if len(l) > 1 {
            throwErr(&l[len(l)-1], "Not expecting {TOKEN} after function call.")
        }
        ft = l[0]
        parsed = true
        OUTPUT = OUTPUT + ft.cont + ";\n"
        return
    }
    l = parseStructType(l, elems)
    isEqual = false
    currentType = ""
    ft = l[0]
    v = searchVar(ft.cont, elems)
    exists = true
    if v == null {
        exists = false
        v = new variable
        v.name = ft.cont
        v.type = ""
    }
    if v.isConst {
        throwErr(&ft, "Cannot set the value of const {TOKEN}.")
    }
    code = ""
    arrayLength = 0
    i=1; for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_SYNTAX {
            if t.cont == "=" {
                if strlen(currentType) > 0 {
                    sct = string(currentType)
                    sct.replace(" ", "")
                    v.type = sct.str()
                }
                isEqual = true
                i++
                continue
            }
        }
        if isEqual == false {
            if t.type != TOKEN_TYPE_VAR {
                if t.cont != "*" {
                    throwErr(&t, "Cannot use {TOKEN} as type for a variable.")
                }
            }
            currentType = currentType + " " + t.cont
        } else {
            if t.cont == "new" {
                max = i + 1
                if max >= len(l) {
                    throwErr(&t, "Cannot initiate {TOKEN} struct without specifying struct name.")
                }
                max++
                if max < len(l) {
                    t = l[i+2]
                    throwErr(&t, "{TOKEN} not expected after initiating new struct.")
                }
                t = l[i+1]
                if t.type != TOKEN_TYPE_VAR {
                    throwErr(&t, "Cannot use {TOKEN} as a struct name.")
                }
                s = searchStruct(t.cont, elems)
                if s == null {
                    throwErr(&t, "Unknown struct {TOKEN}.")
                }
                vect = getCType(s.name, elems)
                vectStr = vect.content
                code = "memoryAlloc(sizeof("+vectStr+"))"
                v.type = s.name + "*"
                NEXT_LINE = declareStructMethods(v, s)
                break
            }
            if t.isValue == false {
                throwErr(&t, "Cannot use {TOKEN} as value in var declaration.")
            }
            tp = getTypeFromToken(&t, true, elems)
            if exists {
                if tp != v.type {
                    throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                }
            } else {
                if strlen(currentType) != 0 {
                    if tp != v.type {
                        //TODO: type warning not error
                        //throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                    }
                } else {
                    if strlen(v.type) == 0 {
                        v.type = tp
                    } else {
                        if tp != v.type {
                            throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                        }
                    }
                }
            }
            cvt = string(v.type)
            if cvt.hasPrefix("[]") {
                arrType = getCType(v.type, elems)
                arrType.trimRight(1)
                arrTypeStr = arrType.str()
                code = "memoryAlloc(sizeof("+arrTypeStr+"))"
                strArrayLength cpstring
                arrType.trimLeft(6)
                arrType.trimRight(1)
                elemTypeStr = arrType.str()

                max = i + 1
                if max != len(l) {
                    i++
                    nt = l[i]
                    if nt.cont != "{" {
                        throwErr(&l[i+1], "{TOKEN} not expected after array initialization.")
                    }
                    elemBahType = string(v.type)
                    elemBahType.trimLeft(2)
                    elemBahTypeStr = elemBahType.str()
                    i++
                    for i < len(l) {
                        t = l[i]
                        tt = getTypeFromToken(&t, true, elems)
                        if tt != elemBahTypeStr {
                            throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+elemBahTypeStr)
                        }
                        
                        strArrayLength = intToStr(arrayLength)
                        arrayLength++

                        NEXT_LINE = NEXT_LINE + v.name + "->data[" + strArrayLength + "] = " + t.cont + ";\n"
                        i++
                        t = l[i]
                        if t.cont != "," {
                            if t.cont == "}" {
                                allocLength = arrayLength
                                if allocLength > 50 {
                                    modAllocAmm = allocLength % 50
                                    allocLength = allocLength + modAllocAmm
                                } else {
                                    allocLength = 50
                                }
                                allocLengthStr = intToStr(allocLength)
                                NEXT_LINE = v.name + "->data = memoryAlloc(sizeof(" + elemTypeStr + ") * " + allocLengthStr + ");" + NEXT_LINE
                                break
                            } else {
                                throwErr(&t, "Expected ',' got {TOKEN}.")
                            }
                        }
                        i++
                    }
                }
                strArrayLength = intToStr(arrayLength)
                NEXT_LINE = "
                " + v.name + "->length = " + strArrayLength + ";
                " + v.name + "->elemSize = sizeof(" + elemTypeStr + ");
                " + NEXT_LINE

                break
            }
            ctc = string(t.cont)
            if ctc.hasPrefix("{") {
                max = i + 1
                if max != len(l) {
                    throwErr(&l[i+1], "{TOKEN} not expected after struct initialization.")
                }
                s = searchStruct(v.type, elems)
                NEXT_LINE = declareStructMethods(v, s)
            }
            code = code + " " + t.cont
        }

        i++
    }

    if exists {
        if strlen(code) == 0 {
            throwErr(&ft, "Cannot re-declare {TOKEN}.")
        }
        if strlen(currentType) > 0 {
            st = l[1]
            throwErr(&st, "Cannot change the type of already declared var '"+ft.cont+"' to {TOKEN}.")
        }
        code = v.name + " = " + code
    } else {
        if strlen(currentType) > 0 {
            v.type = currentType
        }

        vts = string(v.type)
        vts.replace(" ", "")
        v.type = vts.content
        if strlen(v.type) == 0 {
            throwErr(&ft, "Cannot declare {TOKEN} without a type.")
        }
        vct = setCType(v, elems)
        if strlen(code) > 0 {
            code = vct + " = " + code
        } else {
            code = vct
        }
    }
    OUTPUT = OUTPUT + code + ";\n"
    vars = elems.vars
    vars[len(vars)] = v
}


parseFnHeader(prev cpstring, l []Tok, i int*, fn func*, elems Elems*) cpstring {
    j = *i
    ft = l[j]
    if ft.type != TOKEN_TYPE_VAR {
        throwErr(&ft, "Cannot use {TOKEN} as function name.")
    }
    fn.name = prev + ft.cont

    arguments = []variable*

    code = fn.name + "("


    j = j + 2
    
    t = l[j]
    if t.cont != ")" {

        for j < len(l) {
            t = l[j]
            if t.type != TOKEN_TYPE_VAR {
                throwErr(&t, "Cannot use {TOKEN} as argument name.")
            }
            argName = t.cont

            j++
            if j >= len(l) {
                throwErr(&t, "Cannot declare argument {TOKEN} without a type.")
            }
            t = l[j]
            if t.type != TOKEN_TYPE_VAR {
                throwErr(&t, "Cannot use {TOKEN} as argument type.")
            }
            argType = t.cont

            j++
            t = l[j]
            if t.cont != "," {
                if t.cont == ")" {
                    argument = new variable
                    argument.name = argName
                    argument.type = argType
                    arguments[len(arguments)] = argument
                    
                    argCType = setCType(argument, elems)
                    code = code + argCType
                    code += ")"
                    break
                } else {
                    //throwErr(&t, "Need a coma before next argument {TOKEN}.")
                    argType = argType + t.cont
                }
            } else {
                code += ","
            }
            argument = new variable
            argument.name = argName
            argument.type = argType
            arguments[len(arguments)] = argument
            
            argCType = setCType(argument, elems)
            code = code + argCType

            j++
        }
    } else {
        code += ")"
    }

    j++

    returns = new variable
    returns.type = ""
    for j < len(l) {
        t = l[j]
        if t.cont == "{" {
            break
        }
        returns.type = returns.type + t.cont
        j++
    }
    if strlen(returns.type) {
        rts = string(returns.type)
        rts.replace(" ", "")
        returns.type = rts.content
    }
    *i = j
    returns.name = fn.name
    fn.returns = returns
    fn.args = arguments

    fnRetType = getCType(returns.type, elems)
    fnRetTypeStr = fnRetType.content
    code = fnRetTypeStr + " " + code

    return code
}


parseStruct(l []Tok, elems *Elems) {
    s = new cStruct
    structs = elems.structs
    structs[len(structs)] = s
    methds = s.methods
    if len(l) < 4 {
        throwErr(&l[len(l)-1], "Cannot declare struct has such, please do 'struct <name> { <memberName>:<memberType> }'.")
    }
    nameToken = l[1]
    if nameToken.type != TOKEN_TYPE_VAR {
        throwErr(&nameToken, "Cannot use {TOKEN} as struct name.")
    }
    os = searchStruct(nameToken.cont, elems)
    if os != null {
        throwErr(&nameToken, "Struct {TOKEN} already exists.")
    }
    s.name = nameToken.cont
    members = s.members
    currentCStruct = s
    allMembs = []cpstring
    i = 2
    st = l[i]
    if st.type == TOKEN_TYPE_KEYWORD {
        if st.cont == "extend" {
            i++
            extdSNameTk = l[i]
            i++
            if extdSNameTk.type != TOKEN_TYPE_VAR {
                throwErr(&extdSNameTk, "Cannot use {TOKEN} as struct name.")
            }
            extdS = searchStruct(extdSNameTk.cont, elems)
            if extdS == null {
                throwErr(&extdSNameTk, "Struct {TOKEN} does not exist.")
            }
            members = extdS.members
        } else {
            throwErr(&st, "Cannot use keyword {TOKEN} in struct declaration.")
        }
    }
    braceTk = l[i]
    i++
    if braceTk.cont != "{" {
        throwErr(&braceTk, "Cannot use {TOKEN} in struct declaration.")
    }
    for i < len(l) {
        t = l[i]
        max = i + 2
        if max >= len(l) {
            if t.type == TOKEN_TYPE_ENCL {
                if t.cont == "}" {
                    break
                }
            }
            throwErr(&l[len(l)-1], "Not enough argument in member declaration, ending by {TOKEN}.")
        }
        memb = new structMemb
        if t.type != TOKEN_TYPE_VAR {
            throwErr(&t, "Cannot use {TOKEN} as member name.")
        }
        memb.name = t.cont
        ii=0; for ii < len(members) {
            m = members[ii]
            if m.name == memb.name {
                throwErr(&t, "Member {TOKEN} has already been declared.")
            }
            ii++
        }
        i++
        t = l[i]
        if t.cont != ":" {
            if t.cont != "(" {
                throwErr(&t, "Member name should be followed by ':' not {TOKEN}.")
            } else {
                fnPrefix = s.name + "__"
                fn = new func
                nl = []Tok
                j=i-1; for j < len(l) {
                    t = l[j]
                    if t.cont == "{" {
                        break
                    }
                    nl[len(nl)] = t
                    if j == i {
                        t.type = TOKEN_TYPE_VAR
                        t.cont = "this"
                        t.isValue = true
                        nl[len(nl)] = t

                        t.type = TOKEN_TYPE_VAR
                        t.cont = s.name+"*"
                        t.isValue = true
                        nl[len(nl)] = t

                        nt = l[j+1]
                        if nt.cont != ")" {
                            t.type = TOKEN_TYPE_SYNTAX
                            t.cont = ","
                            t.isValue = false
                            nl[len(nl)] = t
                        }
                    }
                    j++
                }
                i--

                nli = 0

                code = parseFnHeader(fnPrefix, nl, &nli, fn, elems)
                i = i + nli
                i = i - 2

                returns = fn.returns
                arguments = fn.args
                fn.from = s.name
                code += "{\n"
                
                fnElems = new Elems
                append(fnElems.vars, elems.vars)
                append(fnElems.structs, elems.structs)
                append(fnElems.types, elems.types)
                append(fnElems.fns, elems.fns)
                vs = fnElems.vars
                j=0; for j < len(arguments) {
                    a = arguments[j]
                    vs[len(vs)] = a
                    j++
                }
                fnElems.vars = vs

                fns = elems.fns
                fns[len(fns)] = fn

                tokens = []Tok
                nbBraces = 1
                t = l[i]
                if t.cont == "{" {
                    i++
                }
                for i < len(l) {
                    t = l[i]
                    if t.cont == "{" {
                        nbBraces++
                    } else if t.cont == "}" {
                        nbBraces--
                    }
                    if nbBraces == 0 {
                        break
                    }
                    tokens[len(tokens)] = t
                    i++
                }

                if len(tokens) == 0 {
                    code += "};\n"
                } else {
                    OOUT = OUTPUT
                    OUTPUT = ""
                    currentFn = fn
                    parseLines(tokens, fnElems)
                    currentFn = null
                    if strlen(fn.returns.type) > 0 {
                        if fn.returned == false {
                            throwErr(&l[len(l)-1], "Function '"+fn.name+"' is not returned.")
                        }
                    }
                    code += OUTPUT
                    OUTPUT = OOUT
                    code += "};\n"
                }
                NEXT_LINE += code

                mfn = new func
                mfn.args = fn.args
                mfn.name = fn.name
                mfn.returns = fn.returns


                sfn = string(mfn.name)
                sfn.trimLeft(strlen(fnPrefix))
                mfn.name = sfn.content

                methds[len(methds)] = mfn
                mthdDecl = getCType(fn.returns.type, elems)
                mthdDecl.append("(*")
                mthdDecl.append(mfn.name)
                mthdDecl.append(")(")
                j=0; for j < len(arguments) {
                    a = arguments[j]
                    tp = getCType(a.type, elems)
                    tp.append(" ")
                    tp.append(a.name)
                    max = len(arguments) - 1
                    if j != max {
                        tp.append(",")
                    }
                    mthdDecl.append(tp)
                    j++
                }
                mthdDecl.append(")")
                mthdDeclStr = mthdDecl.content
                allMembs[len(allMembs)] = mthdDeclStr

                i++
                continue

            }
        }
        i++
        t = l[i]
        if t.type != TOKEN_TYPE_VAR {
            throwErr(&t, "Cannot use {TOKEN} as member type.")
        }
        memb.type = t.cont
        i++
        t = l[i]
        if i < len(l) {
            if t.cont == "=" {
                i++
                t = l[i]
                if t.isValue == false {
                    throwErr(&t, "Cannot use {TOKEN} as default value for member.")
                }
                tt = getTypeFromToken(&t, true, elems)
                if tt != memb.type {
                    throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+memb.type+" for member.")
                }
                memb.def = t.cont

            } else {
                i--
            }
        }
        members[len(members)] = memb
        membDecl = getCType(memb.type, elems)
        membDecl.append(" ")
        membDecl.append(memb.name)
        membDeclStr = membDecl.content
        allMembs[len(allMembs)] = membDeclStr
        i++
    }
    s.members = members

    code = "struct "+s.name+" {\n"
    i=0; for i < len(allMembs) {
        m = allMembs[i]
        code = code + m +";\n"
        i++
    }
    code += "};\n"
    OUTPUT += code

}

parseDefine(l []Tok, elems Elems*) {
    if len(l) < 3 {
        throwErr(&l[len(l)-1], "Invalid usage of define, cannot end on {TOKEN}.")
    }
    st = l[2]
    ft = l[1]
    if st.cont == "(" {
        
        fn = new func
        i = 1
        code = parseFnHeader("", l, &i, fn, elems)
        fns = elems.fns
        fn.isBinding = true
        fns[len(fns)] = fn
        // code = fnRetTypeStr + " " + code + ";\n"
        // OUTPUT += code

    } else {
        if st.type != TOKEN_TYPE_VAR {
            throwErr(&st, "Cannot use {TOKEN} as type.")
        }
        if ft.type != TOKEN_TYPE_VAR {
            throwErr(&ft, "Cannot use {TOKEN} as new type name.")
        }
        cTypeNewType = getCType(st.cont, elems)
        cTypeNewTypeStr = cTypeNewType.str()
        OUTPUT = OUTPUT + "typedef " + cTypeNewTypeStr + " " + ft.cont + ";\n"

        tps = elems.types
        tps[len(tps)] = ft.cont
    }
}

parseClib(line []Tok) {
    clibs = compilerState.cLibs
    
    i=1; for i < len(line) {
        t = line[i]
        if t.type != TOKEN_TYPE_STR {
            throwErr(&t, "Cannot use {TOKEN} as C library name.")
        }

        cc = string(t.cont)
        cc.trimLeft(1)
        cc.trimRight(1)
        ccstr = cc.str()

        found = false
        j=0; for j < len(clibs) {
            l = clibs[j]
            if l == ccstr {
                found = true
                break               
            }
            j++
        }
        if found {
            i++
            continue
        }
        clibs[len(clibs)] = ccstr

        i++
    }
}

parseConst(l []Tok, elems Elems*) {
    l = parseCast(l, elems)
    if len(l) != 4 {
        throwErr(&l[0], "Invalid usage of {TOKEN}, must be 'const <constName> = <constValue>'. ")
    }
    vart = l[1]
    equt = l[2]
    valt = l[3]
    if vart.type != TOKEN_TYPE_VAR {
        throwErr(&vart, "Cannot take {TOKEN} as const name.")
    }
    if equt.cont != "=" {
        throwErr(&equt, "Expected '=' not {TOKEN}.")
    }
    if valt.isValue == false {
        throwErr(&equt, "Must be a value, not {TOKEN}.")
    }
    v = new variable
    v.isConst = true
    v.name = vart.cont
    v.type = getTypeFromToken(&valt, true, elems)
    vars = elems.vars
    vars[len(vars)] = v

    OUTPUT = OUTPUT + "#define "+v.name+" "+valt.cont+"\n"
}

parseReturn(l []Tok, elems Elems*) {
    if len(l) > 2 {
        throwErr(&l[0], "Invalid usage of {TOKEN}, must be 'return <returnValue>'")
    }
    if currentFn == null {
        throwErr(&l[0], "Cannot return a value outside of a function.")
    }
    rv = ""
    if len(l) == 1 {
        if strlen(currentFn.returns.type) != 0 {
            throwErr(&l[0], "Cannot return nothing as "+currentFn.returns.type+".")
        }
    } else {
        rvt = l[1]
        if rvt.isValue == false {
            throwErr(&rvt, "Must be a value, not {TOKEN}.")
        }
        rv = rvt.cont
        tt = getTypeFromToken(&rvt, true, elems)
        if tt != currentFn.returns.type {
            throwErr(&rvt, "Cannot return {TOKEN} ("+tt+") as "+currentFn.returns.type+".")
        }
    }
    if compilerState.isBranch == false {
        currentFn.returned = true
    }
    OUTPUT = OUTPUT + "return "+rv+";\n"
}

parseIf(l []Tok, elems Elems*) {
    if len(l) < 4 {
        ft = l[0]
        throwErr(&ft, "Invalid usage of {TOKEN}, must be 'if <condition> {<code>}'")
    }
    condt = l[1]
    if condt.bahType != "bool" {
        if condt.bahType != "int" {
            throwErr(&condt, "Cannot use {TOKEN} as condition in if statement.")
        }
    }
    t = l[2]
    if t.cont != "{" {
        throwErr(&t, "Expected '{' not {TOKEN} after condtition in if statement.")
    }
    tokens = []Tok
    max = len(l) - 1
    i=3;for i < max {
        t = l[i]
        tokens[len(tokens)] = t
        i++
    }
    OUTPUT = OUTPUT + "if ("+condt.cont+") {\n"

    ifElems = new Elems
    append(ifElems.vars, elems.vars)
    append(ifElems.structs, elems.structs)
    append(ifElems.types, elems.types)
    append(ifElems.fns, elems.fns)

    compilerState.isBranch = true
    parseLines(tokens, ifElems)
    compilerState.isBranch = false
    OUTPUT = OUTPUT + "}\n"

    
}

prePross(line []Tok, elems Elems*) []Tok {
    line = parseStructVars(line, elems)
    line = parseFnCall(line, elems)
    line = parseArrayType(line, elems)
    line = parseCast(line, elems)
    line = parseOperations(line, elems)
    line = parseBool(line, elems)
    return line
}

parseFnDeclare(l []Tok, elems Elems*) {
    
    i = 0
    fn = new func
    ft = l[0]
    code = parseFnHeader("", l, &i, fn, elems)
    fn.line = ft.line
    fn.file = compilerState.currentFile
    ogFn = searchFunc(fn.name, elems)
    if ogFn != null {
        if ogFn.isBinding == false {
            lineStr = intToStr(ogFn.line)
            throwErr(&ft, "Cannot redeclare function {TOKEN}, previous declaration: "+ogFn.file+":"+lineStr+".")
        }
    }
    returns = fn.returns
    arguments = fn.args

    code += "{\n"
    OUTPUT += code

    fnElems = new Elems
    append(fnElems.vars, elems.vars)
    append(fnElems.structs, elems.structs)
    append(fnElems.types, elems.types)
    append(fnElems.fns, elems.fns)
    vs = fnElems.vars
    j=0; for j < len(arguments) {
        a = arguments[j]
        vs[len(vs)] = a
        j++
    }
    fnElems.vars = vs
    
    j=0; for j < len(vs) {
        v = vs[j]
        j++
    }


    if ogFn != null {
        ogFn.isBinding = false
        ogFn = fn
    } else {
        fns = elems.fns
        fns[len(fns)] = fn
    }

    tokens = []Tok
    i++
    max = len(l)-1
    for i < max {
        t = l[i]
        tokens[len(tokens)] = t
        i++
    }

    if len(tokens) == 0 {
        OUTPUT += "};\n"
        return
    }

    currentFn = fn

    parseLines(tokens, fnElems)

    currentFn = null
    if strlen(fn.returns.type) > 0 {
        if fn.returned == false {
            throwErr(&l[len(l)-1], "Function '"+fn.name+"' is not returned.")
        }
    }

    OUTPUT += "};\n"
}


//Handling lines

parseLine(line []Tok, elems Elems*) {
    if len(line) == 0 {
        return
    }
    line = parsePointers(line)
    ltp = getLineType(line)
    
    parsed = false
    if ltp == LINE_TYPE_INCLUDE {
        parsed = true
        parseInclude(line, elems)
    } else if ltp == LINE_TYPE_DEFINE {
        parsed = true
        parseDefine(line, elems)
    } else if ltp == LINE_TYPE_CLIB {
        parsed = true
        parseClib(line)
    } else if ltp == LINE_TYPE_STRUCT {
        parsed = true
        parseStruct(line, elems)
    } else if ltp == LINE_TYPE_CONST {
        parsed = true
        parseConst(line, elems)
    } else if ltp == LINE_TYPE_MACRO {
        return
    } else if ltp != LINE_TYPE_FN_DECL {
        line = prePross(line, elems)
    }
    if ltp == LINE_TYPE_VAR {
        parsed = true
        parseVar(line, elems)
    } else if ltp == LINE_TYPE_FN_CALL {
        if len(line) > 1 {
            throwErr(&line[len(line)-1], "Not expecting {TOKEN} after function call.")
        }
        ft = line[0]
        parsed = true
        OUTPUT = OUTPUT + ft.cont + ";\n"
    } else if ltp == LINE_TYPE_FN_DECL {
        parsed = true
        parseFnDeclare(line, elems)
    } else if ltp == LINE_TYPE_RETURN {
        parsed = true
        parseReturn(line, elems)
    } else if ltp == LINE_TYPE_IF {
        parsed = true
        parseIf(line, elems)
    } else if ltp == LINE_TYPE_ELSE {
        debugLine(line)
    }
    
    if parsed == false {
        ft = line[0]
        throwErr(&ft, "{TOKEN} not expected at the bigining of a line.")
    }

    if strlen(NEXT_LINE) > 0 {
        OUTPUT += NEXT_LINE
        NEXT_LINE = ""
    }

}

parseLines(tokens []Tok, elems Elems*) {
    line = []Tok
    ft = tokens[0]
    currentLine = ft.line
    nbEncl = 0
    i=0; for i < len(tokens) {
        t = tokens[i]
        
        if t.type == TOKEN_TYPE_ENCL {
            if t.cont == "(" {
                nbEncl++
            } else if t.cont == ")" {
                nbEncl--
            } else if t.cont == "{" {
                nbEncl++
            } else if t.cont == "}" {
                nbEncl--
            } else if t.cont == "[" {
                nbEncl++
            } else if t.cont == "]" {
                nbEncl--
            }
        }

        if nbEncl == 0 {
            if t.line != currentLine {
                if t.type == TOKEN_TYPE_ENCL {
                    line[len(line)] = t
                    pt = tokens[i-1]
                    currentLine = pt.line
                } else {
                    currentLine = t.line
                }
                parseLine(line, elems)
                clear(line)
                if t.type == TOKEN_TYPE_ENCL {
                    i++
                    continue
                }
            }
        }

        line[len(line)] = t
        i++
    }

    if len(line) > 0 {
        if nbEncl == 0 {
                parseLine(line, elems)
                clear(line)
        } else {
            ft = line[len(line)-1]
            throwErr(&ft, "Missing closing token, line ending by {TOKEN}.")
        }
    }

}

