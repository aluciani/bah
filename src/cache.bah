//The cache is used when using '#import' to compile the imported object as an object file.
//This object file will then not be recompiled unless a file of the object has been edited since last compilation,
//or a new version of the compiler is used.
//Note that you can purge the cache by deletint the cache folder's contents inside the Bah directory.

//Represents an entry inside the cache.
struct cacheFile {
    file: str
    last: int
    ver: str
    date: int
    mem: int
    opti: int
    files: []str
}

cache = []cacheFile*

//Reads the cache, who could have guessed?
//Scans the value of the cache inside the global variable called 'cache'.
readCache()  {
    fs = fileStream{}
    fs.open(BAH_DIR + "cache/cache.json", "r")
    if fs.isValid() == 0 || fs.getSize() == 0 {
        mkdir(BAH_DIR + "cache", noCheck(S_IRWXU))
        fs.createFile(BAH_DIR + "cache/cache.json")
        return
    }
    if fs.getSize() > 0 {
        j = parseJson(fs.readContent())
        fs.close()
        j.scan(&cache)
    }


}

//Returns a cacheFile instance from an imported file name.
getCacheFile(s str) cacheFile* {
    if cache == null {
        return null
    }
    i=0; for i < len(cache), i++ {
        c = cache[i]
        if c.file == s && c.mem == RCPlevel && c.opti == isOptimized {
            return c
        }
    }
    return null
}

//Updates a cacheFile instance to set the new modification date of the newly compiled file.
updateCacheFile(c cacheFile*) {
    c.last = getLastModified(c.file)
    c.ver = BAH_VERSION
    c.date = getTimeUnix()
}

//Used for registering a new cacheFile instance from an imported file's name.
makeCacheFile(f str) {
    c = new cacheFile
    c.file = f
    c.ver = BAH_VERSION
    c.mem = RCPlevel
    c.opti = isOptimized
    c.date = getTimeUnix()
    c.last = getLastModified(f)
    if cache == null {
        cache = []cacheFile*
    }
    cache[len(cache)] = c
}

//Used for saving the runtime copy of the cache to the cache file.
writeCache() {
    fs = fileStream{}
    fs.open(BAH_DIR + "cache/cache.json", "w")
    fs.writeFile(toJson(&cache))
    fs.close()
}

//Used to decide weither a file should be recompiled or if its cached version is still good.
isValidCacheFile(cf cacheFile*) bool {
    if cf.last != getLastModified(cf.file) {
        return false
    }
    if fileExists(BAH_DIR+"cache/"+pathToVarName(cf.file)+intToStr(cf.mem)+intToStr(cf.opti)+".o.o") == 0 {
        return false
    }

    if cf.ver != BAH_VERSION {
        return false
    }
    return true
}