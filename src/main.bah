#include "iostream.bah"
#include "flags.bah"
#include "rand.bah"
#include "exec.bah"
#include "time.bah"
#include "rope.bah"

///////////////////////OS SPECIFIC THINGS////////////////////////
#linux {
    BAH_DIR = "/opt/bah/"
    BAH_OS = "linux"
    BAH_CC = "gcc"
}
#darwin {
    BAH_DIR = "/opt/bah/"
    BAH_OS = "darwin"
    BAH_CC = "clang"
}

#windows {
    BAH_DIR = "C:/Bah/"
    BAH_OS = "windows"
    BAH_CC = "gcc"
}
//////////////////////BUILD SPECIFIC THINGS//////////////////////
const BAH_VERSION = "v1.2 (build 98)"

debug = false
verboseRuntime = false
isObject = false
isUnsafe = false

execName = "bah"
isSubObject = false

#include "./globals.bah"

#include "./lexer.bah"
#include "./type.bah"
#include "./errors.bah"
#include "./parser.bah"
#include "./declarative.bah"


memErrHandle() cpstring {
    r = "file: "+compilerState.currentFile
    if currentFn != null {
        r += "\nfunction: "+currentFn.name+"()"
    }
    return r
}

main(args []cpstring) int {
    // timer.open("res.json")

    onMemoryError = memErrHandle
    
    execName = args[0] //for calling a sub-process for compiling imports

    if execName[0] == '.' || execName[0] == '/' {
        execName = absPath(execName)
    }

    flags = flags{}
    flags.addString("o", "Name of the file to output.")
    flags.addBool("c", "Translate bah file to C instead of compiling it.")
    flags.addBool("v", "Show version of the compiler.")
    flags.addBool("l", "Compile as a library.")
    #linux {
        flags.addBool("d", "Compile as a dynamic executable. (useful if you are using a library that is only available shared but might reduce portability).")
    }
    #windows {
        flags.addBool("d", "Compile as a dynamic executable. (useful if you are using a library that is only available shared but might reduce portability).")
    }
    flags.addBool("rcp", "Enables RCP (reference counter) instead of the garbage collector. Warning: if you are using self-reference, this will lead to memory leaks!")
    flags.addBool("fastrcp", "Enables RCP without leak detection. It is recommended to test you programs with the -rcp flag to test for leak detection before using this flag.")
    flags.addBool("debug", "Enables verbose json output.")
    flags.addBool("verboseRuntime", "Enables verbose runtime, a debug mode of the compiled program. (obsolete)")
    flags.addBool("verboseCC", "Enables verbose C compiler output, USE IN LAST RESORT.")

    //cross compiler
    flags.addString("target", "Select the target OS for cross compilling (linux, windows, darwin), default: "+BAH_OS+".")
    flags.addString("bahDir", "If your Bah directory is not the default one ("+BAH_DIR+").")
    flags.addString("CC", "To change the C compiler used, default: "+BAH_CC+".")
    flags.addBool("object", "Compile as an object.")
    flags.addBool("unsafe", "Compile without safety checking. This will make for faster executable but if your program crashes, it will show less informations.")
    flags.parse(args)

    if flags.isSet("target") == 1 {
        BAH_OS = flags.get("target")
        println("Build target: "+BAH_OS)
    }
    if flags.isSet("bahDir") == 1 {
        BAH_DIR = flags.get("bahDir")
        bahDirArr = strAsArr(BAH_DIR)
        if bahDirArr[len(bahDirArr)-1] != '/' {
            BAH_DIR = BAH_DIR + "/"
        }
        println("Bah directory: "+BAH_DIR)
    }
    if flags.isSet("CC") == 1 {
        BAH_CC = flags.get("CC")
        println("C compiler: "+BAH_CC)
    }

    if flags.isSet("verboseRuntime") {
        println("-verboseRuntime is obsolete.")
        exit(1)
    }

    RCPlevel = 0
    if flags.isSet("rcp") {
        RCPlevel = 1
    } else if flags.isSet("fastrcp") {
        RCPlevel = 2
    }

    verboseRuntime = flags.isSet("verboseRuntime") == 1
    debug = flags.isSet("debug") == 1
    isObject = flags.isSet("object") == 1
    isUnsafe = flags.isSet("unsafe") == 1

    if debug == true {
        debugStart() //for IDE purposes
    }

    RCPenabled = flags.isSet("rcp") == 1 || flags.isSet("fastrcp")

    if flags.isSet("v") == 1 {
        println("Bah compiler version: "+BAH_VERSION+".\nÂ© Alois Laurent Boe")
        return 0
    }

    if flags.isSet("c") == 1 && flags.isSet("l") == 1 {
        panic("Cannot use -c (to translate to C code) and -l (to compile as a library) at the same time.")
    }

    INIT = rope("") //C code of the __BAH_init function

    //C entry point of the program
    OUTPUT = rope("
    void __BAH_init();
    #define noCheck(v) v
    #define array(type)	\
    struct{	\
    type *data; \
    long int length; \
    long int realLength; \
    long int elemSize; \
    }
    typedef array(char*)* __BAH_ARR_TYPE_cpstring;
    long int __BAH__main(__BAH_ARR_TYPE_cpstring);
    ")

    if flags.isSet("l") == 0 {
        if RCPenabled == true {
            OUTPUT = OUTPUT + rope("
            void RCP_init();
            void RCP_shutdown();
            void free(void*);
            #include <string.h>
            int main(int argc, char ** argv) {
            RCP_init();
            array(char*) * args = malloc(sizeof(array(char*)));
            args->data = malloc(sizeof(char*)*argc);
            memcpy(args->data, argv, sizeof(char*)*argc);
            args->elemSize = sizeof(char*);
            args->length = argc;
            __BAH_init();
            long int r =  __BAH__main((__BAH_ARR_TYPE_cpstring)args);
            free(args->data);
            free(args);
            RCP_shutdown();
            return r;
            };
            #define main(v) __BAH__main(v)
            ")

        } else {
            OUTPUT = OUTPUT + rope("
            #include <gc.h>
            #include <string.h>
            int main(int argc, char ** argv) {
            GC_INIT();
            array(char*) * args = GC_MALLOC(sizeof(array(char*)));
            args->data = GC_MALLOC(sizeof(char*)*argc);
            memcpy(args->data, argv, sizeof(char*)*argc);
            args->elemSize = sizeof(char*);
            args->length = argc;
            __BAH_init();
            long int r =  __BAH__main((__BAH_ARR_TYPE_cpstring)args);
            GC_FREE(args->data);
            GC_FREE(args);
            return r;
            };
            #define main(v) __BAH__main(v)
            ")
        }
    }

    //definning the []cpstring C type because it is used for the first time in the C entry point.
    compilerState = compilerStateTag{}
    compilerState.arrTypesDecl[0] = "__BAH_ARR_TYPE_cpstring"
    
    //opening the file to compile
    fileName = absPath(args[1])
    compilerState.currentFile = fileName
    fm = fileMap{}
    f = fm.open(fileName)
    if fm.isValid() == 0 || fm.size == 0 {
        println("Could not open file '"+args[1]+"'.")
        exit(1)
    }
    startTime = getTimeUnix() //for timming compilation time
    tokens = lexer(f) //tokenizing the first file
    fm.close()


    if len(tokens) == 0 {
        println("File '"+fileName+"' not recognized.")
        exit(1)
    }

    elems = new Elems //the struct containning the state of the code (vars, funcs...) at every scopes

    //if the file is an object, we dont want to declare an entry point.
    if isObject == true {
        OUTPUT = rope("
        #define noCheck(v) v
        #define array(type)	\
        struct{	\
        type *data; \
        long int length; \
        long int realLength; \
        long int elemSize; \
        }
        typedef array(char*)* __BAH_ARR_TYPE_cpstring;
        long int __BAH__main(__BAH_ARR_TYPE_cpstring);
        ")
        shouldOnlyDecl = true
    }

    //includes the builtin libraries
    if includeFile("builtin.bah", elems) == false {
        panic("Could not find std-libs, please check '"+BAH_DIR+"'")
    }
    shouldOnlyDecl = false //should also set values to vars, funcs...

    //if the file is being compiled as a lib, remove all its content and declare everything (builtin.bah)
    if flags.isSet("l") == 1 {
        OUTPUT = rope("")
        declareAll(elems)
    }

    compilerState.currentDir = getDirFromFile(fileName) //for handling includes
    parseLines(tokens, elems) //parse the frst file

    if isObject == false && isUnsafe == false {
        l = 0
        i=0; for i < len(elems.fns), i++ {
            fn = elems.fns[i]
            if fn.isBinding == true {
                continue
            }
            l++
        }
        OUTPUT += rope("volatile struct __Bah_fnName_mapper __tmp____Bah_fnNames["+intToStr(l)+"];")
        j=0
        i=0; for i < len(elems.fns), i++ {
            fn = elems.fns[i]
            if fn.isBinding == true {
                continue
            }
            name = fn.name
            if fn.from != "" && strHasPrefix(name, fn.from+"__") {
                n = string(name)
                n.trimLeft(strlen(fn.from)+2)
                name = fn.from+"."+n.str()
            }
            INIT += rope("
            __tmp____Bah_fnNames["+intToStr(j)+"].n = \""+name+"\";
            __tmp____Bah_fnNames["+intToStr(j)+"].p = "+fn.name+";\n")
            j++
        }
        INIT += rope("
        __Bah_fnNames->data = __tmp____Bah_fnNames;
        __Bah_fnNames->length = "+intToStr(l)+";")
    }

    makeInit() //makes the init function

    excludeFns = []cpstring {
        "main",
        "cpstringCharAt",
        "cpstringSubsitute",
        "channel",
        "mapWrapper",
        "arraySubstitute"
    }

    //optimization: if the file is not an object, removed unused functions.
    // if isObject == false && compilerState.hasImports == false {
    //     i=0; for i < len(elems.fns), i++ {
    //         fn = elems.fns[i]
    //         if fn.used == false && fn.code != null && fn.name in excludeFns == false {
    //             ropeSet(fn.code, "//optimized out: "+fn.name+"\n")
    //         }
    //     }
    // }


    //if we run in debug mode, we dont want to compile the program
    if debug == true {
        debugEnd() //prints the file end, if not printed it will be interpreted as an error occuring
        return 0
    }

    //printing parsing statistics
    if isObject == false {
        totalTime = getTimeUnix() - startTime
        println("Parsed. ("+intToStr(totalLines)+" lines, total time: "+intToStr(totalTime / 1000000)+"ms, lexer time: "+intToStr(totalLexerTime / 1000000)+"ms)\e[0m")
    }

    //setting the output name
    if flags.isSet("o") == 1 {
        fileName = flags.get("o")
    } else {
        outFileName = string(args[1])
        outFileName.trimRight(4)
        fileName = outFileName.str()
    }

    //setting the linking mode
    isStatic = "-static"
    if flags.isSet("d") == 1 || BAH_OS == "darwin" {
        isStatic = ""
    }

    //making an executable from the C code
    if flags.isSet("c") == 0 {
        //if file is an object, do not link it
        obj = ""
        if flags.isSet("object") == 1 {
            fileName = fileName + ".o"
            obj = "-c"
        }

        randFileName = "-x c - -x none" //reading from stdin
        gccArgs = BAH_CC+" -I \""+BAH_DIR+"libs/"+BAH_OS+"/include/\" -L \""+BAH_DIR+"libs/"+BAH_OS+"/\" "+ randFileName+ " "+isStatic+" "+obj+" -w -O1 -o "+fileName //the compiler (C compiler) command
        
        if flags.isSet("l") == 1 {
            gccArgs = gccArgs + " -c"
        }

        //adding C libraries
        cLibs = compilerState.cLibs
        i=0;for i < len(cLibs) {
            l = cLibs[i]
            gccArgs = gccArgs + " -" + l
            i = i + 1
        }

        //executes the C compiler
        cmd = command(gccArgs)
        cmd.input = OUTPUT.toStr()
        #linux {
            if flags.isSet("verboseCC") == 0 {
                cmd.error = false
            }
        }
        if flags.isSet("verboseCC") == 1 {
            println(cmd.run())
        } else {
            cmd.run()
        }
        
        if cmd.status != 0 {   
            println("\e[1;31m[CC-ERROR]\e[0m\nCould not compiled.")
            return 1
        }

        if flags.isSet("l") == 1 {
            cmd = command("ar rcs "+fileName+".a "+fileName)
            cmd.run()
        }

    } else {
        //making the C file without compiling it
        if flags.isSet("o") == 0 {
            fileName = fileName + ".c"
        }

        gccArgs = BAH_CC+" -I \""+BAH_DIR+"libs/"+BAH_OS+"/include/\" -L \""+BAH_DIR+"libs/"+BAH_OS+"/\" "+ fileName+ " "+isStatic+" -O1 -w "
        cLibs = compilerState.cLibs
        i=0;for i < len(cLibs) {
            l = cLibs[i]
            gccArgs = gccArgs + " -" + l
            i = i + 1
        }
        OUTPUT = rope("//COMPILE WITH: '"+gccArgs+"'\n") + OUTPUT
        fs = fileStream{}
        fs.open(fileName, "w")
        fs.writeFile(OUTPUT.toStr())
        fs.close()
    }

    //print that the compiler finished is job without any error
    if isObject == false {
        totalTime = getTimeUnix() - startTime
        println("\e[1;32mDone. (compiled in "+intToStr(totalTime / 1000000)+"ms)\e[0m")
    }
    // timer.save()
    return 0
}
