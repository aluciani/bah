#include "iostream.bah"
#include "flags.bah"
#include "rand.bah"
#include "exec.bah"
#include "time.bah"
#include "rope.bah"

///////////////////////OS SPECIFIC THINGS////////////////////////
const BAH_DIR = "/opt/bah/"
//////////////////////BUILD SPECIFIC THINGS//////////////////////
const BAH_VERSION = "v1.0 (build 20)"
#include "./globals.bah"

#include "./lexer.bah"
#include "./type.bah"
#include "./errors.bah"
#include "./parser.bah"

main(args []cpstring) int {
    flags = flags{}
    flags.addString("o", "Name of the file to output.")
    flags.addBool("c", "Translate bah file to C instead of compiling it.")
    flags.addBool("v", "Show version of the compiler.")
    flags.addBool("l", "Compile as a library.")
    flags.parse(args)

    if flags.isSet("v") == 1 {
        println("Bah compiler version: "+BAH_VERSION+".\nÂ© Alois Laurent Boe")
        return 0
    }

    if flags.isSet("c") == 1 && flags.isSet("l") == 1 {
        panic("Cannot use -c (to translate to C code) and -l (to compile as a library) at the same time.")
    }

    OUTPUT = rope("
#include \""+BAH_DIR+"libs/include/gc.h\"

#define noCheck(v) v
#define array(type)	\
struct{	\
type *data; \
long int length; \
long int elemSize; \
}
typedef array(char*)* __BAH_ARR_TYPE_cpstring;
long int __BAH__main(__BAH_ARR_TYPE_cpstring);
")

    if flags.isSet("l") == 0 {

    OUTPUT = OUTPUT + rope("
int main(int argc, char ** argv) {
GC_INIT();
array(char*) * args = GC_MALLOC(sizeof(array(char*)));
args->data = GC_MALLOC(sizeof(char*)*argc);
memcpy(args->data, argv, sizeof(char*)*argc);
args->elemSize = sizeof(char*);
args->length = argc;
return __BAH__main((__BAH_ARR_TYPE_cpstring)args);
};
#define main(v) __BAH__main(v)
")
    }


    compilerState = compilerStateTag{}
    compilerState.arrTypesDecl[0] = "__BAH_ARR_TYPE_cpstring"
    
    fileName = args[1]
    compilerState.currentFile = fileName
    fm = fileMap{}
    f = fm.open(fileName)
    
    startTime = getTimeUnix()
    tokens = lexer(f)
    fm.close()

    if len(tokens) == 0 {
        panic("File '"+fileName+"' not recognized.")
    }

    elems = new Elems
    if includeFile("builtin.bah", elems) == false {
        panic("Could not find std-libs, please check '"+BAH_DIR+"'")
    }
    parseLines(tokens, elems)
    totalTime = getTimeUnix() - startTime
    println("Parsed. ("+intToStr(totalLines)+" lines, total time: "+intToStr(totalTime / 1000000)+"ms, lexer time: "+intToStr(totalLexerTime / 1000000)+"ms)\e[0m")


    if flags.isSet("o") == 1 {
        fileName = flags.get("o")
    } else {
        outFileName = string(fileName)
        outFileName.trimRight(4)
        fileName = outFileName.str()
    }

    if flags.isSet("c") == 0 {
        randFileName = "TMP_C_FILE_"
        i=0; for i < 9 {
            nb = randomInRange(0,99)
            s = intToStr(nb)
            randFileName = randFileName + s
            i = i + 1
        }
        randFileName = randFileName + ".c"

        fs = fileStream{}
        fs.open(randFileName, "w")
        fs.writeFile(OUTPUT.toStr())
        fs.close()

        gccArgs = "clang "+ randFileName+ " -w -o "+fileName
        
        if flags.isSet("l") == 1 {
            gccArgs = gccArgs + " -c"
        }

        cLibs = compilerState.cLibs

        i=0;for i < len(cLibs) {
            l = cLibs[i]
            gccArgs = gccArgs + " -" + l
            i = i + 1
        }

        cmd = command(gccArgs)
        gccOut = cmd.run()
        removeFile(randFileName)
        if strlen(gccOut) > 0 {   
            println("\e[1;31m[CLANG-ERROR]\e[0m\nCould not compiled.")
            exit(1)
        }

        if flags.isSet("l") == 1 {
            cmd = command("ar rcs "+fileName+".a "+fileName)
            cmd.run()
        }

    } else {
        if flags.isSet("o") == 0 {
            fileName = fileName + ".c"
        }

        gccArgs = "gcc "+ fileName+ " -w "
        cLibs = compilerState.cLibs
        i=0;for i < len(cLibs) {
            l = cLibs[i]
            gccArgs = gccArgs + " -" + l
            i = i + 1
        }
        OUTPUT = concatenateRopes(rope("//COMPILE WITH: '"+gccArgs+"'\n"), OUTPUT)
        fs = fileStream{}
        fs.open(fileName, "w")
        fs.writeFile(OUTPUT.toStr())
        fs.close()
    }

    totalTime = getTimeUnix() - startTime
    println("\e[1;32mDone. (compiled in "+intToStr(totalTime / 1000000)+"ms)\e[0m")
    return 0
}
