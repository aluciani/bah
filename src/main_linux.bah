#include "iostream.bah"
#include "flags.bah"
#include "rand.bah"
#include "exec.bah"
#include "time.bah"
#include "rope.bah"

///////////////////////OS SPECIFIC THINGS////////////////////////
const BAH_DIR = "/opt/bah/"
const BAH_OS = "linux"
//////////////////////BUILD SPECIFIC THINGS//////////////////////
const BAH_VERSION = "v1.1 (build 38)"

debug = false

#include "./globals.bah"

#include "./lexer.bah"
#include "./type.bah"
#include "./errors.bah"
#include "./parser.bah"

#cLib "O1"

main(args []cpstring) int {
    flags = flags{}
    flags.addString("o", "Name of the file to output.")
    flags.addBool("c", "Translate bah file to C instead of compiling it.")
    flags.addBool("v", "Show version of the compiler.")
    flags.addBool("l", "Compile as a library.")
    flags.addBool("d", "Compile as a dynamic executable. (useful if you are using a library that is only available shared but might reduce portability).")
    flags.addBool("rcp", "Enables RCP (reference counter) instead of the garbage collector. Warning: if you are using self-reference, this will lead to memory leaks!")
    flags.addBool("debug", "Enables verbose json output.")
    flags.parse(args)

    debug = flags.isSet("debug") == 1

    if debug == true {
        debugStart()
    }

    RCPenabled = flags.isSet("rcp") == 1

    if flags.isSet("v") == 1 {
        println("Bah compiler version: "+BAH_VERSION+".\nÂ© Alois Laurent Boe")
        return 0
    }

    if flags.isSet("c") == 1 && flags.isSet("l") == 1 {
        panic("Cannot use -c (to translate to C code) and -l (to compile as a library) at the same time.")
    }

    OUTPUT = rope("

#define noCheck(v) v
#define array(type)	\
struct{	\
type *data; \
long int length; \
long int elemSize; \
}
typedef array(char*)* __BAH_ARR_TYPE_cpstring;
long int __BAH__main(__BAH_ARR_TYPE_cpstring);
")

    if flags.isSet("l") == 0 {

        if RCPenabled == true {

            OUTPUT = OUTPUT + rope("
        int main(int argc, char ** argv) {
        RCP_init();
        array(char*) * args = malloc(sizeof(array(char*)));
        args->data = malloc(sizeof(char*)*argc);
        memcpy(args->data, argv, sizeof(char*)*argc);
        args->elemSize = sizeof(char*);
        args->length = argc;
        long int r =  __BAH__main((__BAH_ARR_TYPE_cpstring)args);
        free(args->data);
        free(args);
        RCP_shutdown();
        return r;
        };
        #define main(v) __BAH__main(v)
        ")

        } else {
        OUTPUT = OUTPUT + rope("
        #include \""+BAH_DIR+"libs/include/gc.h\"
        int main(int argc, char ** argv) {
        GC_INIT();
        array(char*) * args = GC_MALLOC(sizeof(array(char*)));
        args->data = GC_MALLOC(sizeof(char*)*argc);
        memcpy(args->data, argv, sizeof(char*)*argc);
        args->elemSize = sizeof(char*);
        args->length = argc;
        long int r =  __BAH__main((__BAH_ARR_TYPE_cpstring)args);
        GC_FREE(args->data);
        GC_FREE(args);
        return r;
        };
        #define main(v) __BAH__main(v)
        ")
        }

    }


    compilerState = compilerStateTag{}
    compilerState.arrTypesDecl[0] = "__BAH_ARR_TYPE_cpstring"
    
    fileName = absPath(args[1])
    compilerState.currentFile = fileName
    fm = fileMap{}
    f = fm.open(fileName)
    if fm.isValid() == 0 {
        panic("Could not open file '"+fileName+"'.")
    }
    startTime = getTimeUnix()
    tokens = lexer(f)
    fm.close()


    if len(tokens) == 0 {
        panic("File '"+fileName+"' not recognized.")
    }

    elems = new Elems
    if includeFile("builtin.bah", elems) == false {
        panic("Could not find std-libs, please check '"+BAH_DIR+"'")
    }
    compilerState.currentDir = getDirFromFile(fileName)
    parseLines(tokens, elems)

    if debug == false {
        totalTime = getTimeUnix() - startTime
        println("Parsed. ("+intToStr(totalLines)+" lines, total time: "+intToStr(totalTime / 1000000)+"ms, lexer time: "+intToStr(totalLexerTime / 1000000)+"ms)\e[0m")
    }

    if flags.isSet("o") == 1 {
        fileName = flags.get("o")
    } else {
        outFileName = string(fileName)
        outFileName.trimRight(4)
        fileName = outFileName.str()
    }

    isStatic = "-static"
    if flags.isSet("d") == 1 {
        isStatic = ""
    }

    if flags.isSet("c") == 0 {
        randFileName = "TMP_C_FILE_"
        i=0; for i < 9 {
            nb = randomInRange(0,99)
            s = intToStr(nb)
            randFileName = randFileName + s
            i = i + 1
        }
        randFileName = randFileName + ".c"

        fs = fileStream{}
        fs.open(randFileName, "w")
        fs.writeFile(OUTPUT.toStr())
        fs.close()

        gccArgs = "gcc "+ randFileName+ " "+isStatic+" -w -O1 -o "+fileName
        
        if flags.isSet("l") == 1 {
            gccArgs = gccArgs + " -c"
        }

        cLibs = compilerState.cLibs

        i=0;for i < len(cLibs) {
            l = cLibs[i]
            gccArgs = gccArgs + " -" + l
            i = i + 1
        }

        cmd = command(gccArgs)
        cmd.error = false
        cmd.run()
        removeFile(randFileName)
        if cmd.status != 0 {   
            println("\e[1;31m[GCC-ERROR]\e[0m\nCould not compiled.")
            exit(1)
        }

        if flags.isSet("l") == 1 {
            cmd = command("ar rcs "+fileName+".a "+fileName)
            cmd.run()
        }

    } else {
        if flags.isSet("o") == 0 {
            fileName = fileName + ".c"
        }

        gccArgs = "gcc "+ fileName+ " "+isStatic+" -O1 -w "
        cLibs = compilerState.cLibs
        i=0;for i < len(cLibs) {
            l = cLibs[i]
            gccArgs = gccArgs + " -" + l
            i = i + 1
        }
        OUTPUT = concatenateRopes(rope("//COMPILE WITH: '"+gccArgs+"'\n"), OUTPUT)
        fs = fileStream{}
        fs.open(fileName, "w")
        fs.writeFile(OUTPUT.toStr())
        fs.close()
    }

    if debug == false {
        totalTime = getTimeUnix() - startTime
        println("\e[1;32mDone. (compiled in "+intToStr(totalTime / 1000000)+"ms)\e[0m")
    } else {
        debugEnd()
    }

 
    return 0
}