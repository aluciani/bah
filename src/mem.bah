isOutterScope(ce ptr, e Elems*) bool {
    for e != null {
        if ce == e {
            return true
        }
        e = e.parent
    }
    return false
}

decrVar(v variable*, elems Elems*) rope* {
    r = rope("")
    //is array
    if strHasPrefix(v.type, "[]") {
        r += rope("RCP_decr("+v.name+");\n")
    } else if strHasPrefix(v.type, "chan:") {
        r += rope("RCP_decr("+v.name+");\n")
    } else {
        if strHasPrefix(v.type, "map:") {
            nv = new variable
            *nv = *v
            v = nv
            v.type = "mapWrapper*"
        }
        //var can be both a struct and a pointer
        isPointer = isRCPpointerType(v.type)
        //is a struct
        s = searchStruct(v.type, elems)
        if s != null && s.isBinding == false {
            if isPointer == true {
            r += rope("RCP_decr("+v.name+");\n")
            } else {
            r += rope("RCP_scanStack(&"+v.name+", sizeof("+v.name+"), 1);\n")
            }
        } else if isPointer == true {
            //is a pointer
            r = r + rope("RCP_decr("+v.name+");\n")
        }
    }
    return r
}

incrVar(v variable*, elems Elems*) rope* {

    if strCount(v.name, "*") > 0 {
        return rope("")
    }

    s = searchStruct(v.type, elems)
    if s != null && isRCPpointerType(v.type) == false && s.isBinding == false {
        return rope("RCP_scanStack(&"+v.name+", sizeof("+v.name+"), 0);")
    }

    return rope("RCP_incr("+v.name+");")
}

RCPavailable() bool {
    return RCPenabled == true
}

beginRCPscope(elems Elems*, excl []variable*) {
    if RCPavailable() == false {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if varInArr(v, excl) {
            continue
        }
        if v.isGlobal == false && isRCPtype(v.type, elems) {
            OUTPUT += incrVar(v, elems)
        }
    }
}

beginRCPscopeLeaky(elems Elems*) {
    if RCPavailable() == false {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if v.isGlobal == false && v.declScope == elems && isRCPtype(v.type, elems) {
            OUTPUT += incrVar(v, elems)
        }
    }
}

removeDefs(elems Elems*) {
    i=0; for i < len(elems.defined), i++ {
        OUTPUT += rope("\n#undef "+elems.defined[i]+"\n")
    }
    // i=len(elems.vars)-1; for i != -1, i-- {
    //     v = elems.vars[i]
    //     vn = string(v.name)
    //     if v.ogDeclScope == elems && vn.hasSuffix("__Bah_strlen") {
    //         c = v.count
    //         if *c == 0 {
    //             if v.metaRope != null {
    //                 OUTPUT.totalLen += ropeSet(v.metaRope, "//removed meta: "+v.name+"\n")
    //             } else {
    //                 OUTPUT.totalLen += ropeSet(v.declRope, "//removed declaration: "+v.name+"\n")
    //             }
    //             *c = -1
    //         }
    //     }
    // }
}

endRCPscope(elems Elems*, excl []variable*) {
    if RCPavailable() == false {
        removeDefs(elems)
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if varInArr(v, excl) {
            continue
        }
        if v.isGlobal == false && isRCPtype(v.type, elems) {
            OUTPUT += decrVar(v, elems)
        }
    }
    removeDefs(elems)
}

endRCPscopeLeaky(elems Elems*, excl variable*) {
    if RCPavailable() == false {
        removeDefs(elems)
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if excl != null && excl.name == v.name {
            continue
        }
        if v.isGlobal == false && v.declScope == elems && isRCPtype(v.type, elems) {
            OUTPUT += decrVar(v, elems)
        }
    }
    removeDefs(elems)
}

registerRCPvar(t cpstring, c cpstring, elems Elems*) cpstring {
    av = new variable
    av.type = t
    av.name = genCompilerVar()
    elems.vars[len(elems.vars)] = av
    cType = getCType(av.type, elems)
    OUTPUT = OUTPUT + rope(cType.str()+" "+av.name+" ="+c+";")
    return av.name
}

RCPselfRef(v variable*) bool {
    i=0; for i < len(compilerState.RCPvars) {
        r = compilerState.RCPvars[i]
        if r.name == v.name {
            return true
        }
        i = i + 1
    }
    return false
}