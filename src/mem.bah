decrVar(v variable*, elems Elems*) rope* {
    r = rope("")
    //is array
    if strHasPrefix(v.type, "[]") {
        r += rope("RCP_decr("+v.name+");\n")
    } else if strHasPrefix(v.type, "chan:") {
        r = rope("{
            struct RCP * chanRCP = RCP_request("+v.name+");
            if (chanRCP != null && chanRCP->c == 1) {
                "+v.name+"->destroy("+v.name+");
                RCP_decr("+v.name+"->queue);
            };
            RCP_decrRCP(chanRCP);
        };")
    } else {
        if strHasPrefix(v.type, "map:") {
            nv = new variable
            *nv = *v
            v = nv
            v.type = "mapWrapper*"
        }
        //var can be both a struct and a pointer
        isPointer = isRCPpointerType(v.type)
        //is a struct
        s = searchStruct(v.type, elems)
        if s != null && s.isBinding == false {
            if isPointer == true {
            r += rope("RCP_decr("+v.name+");\n")
            } else {
            r += rope("RCP_scanStack(&"+v.name+", sizeof("+v.name+"), 1);\n")
            }
        } else if isPointer == true {
            //is a pointer
            r = r + rope("RCP_decr("+v.name+");\n")
        }
    }
    return r
}

incrVar(v variable*, elems Elems*) rope* {

    if strCount(v.name, "*") > 0 {
        return rope("")
    }

    s = searchStruct(v.type, elems)
    if s != null && isRCPpointerType(v.type) == false && s.isBinding == false {
        return rope("RCP_scanStack(&"+v.name+", sizeof("+v.name+"), 0);")
    }

    return rope("RCP_incr("+v.name+");")
}

RCPavailable() bool {
    return absPath(compilerState.currentFile) != absPath(BAH_DIR+"rcp.bah") && absPath(compilerState.currentFile) != absPath(BAH_DIR+"fastrcp.bah") && RCPenabled == true
}

beginRCPscope(elems Elems*, excl []variable*) {
    if RCPavailable() == false {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if varInArr(v, excl) {
            continue
        }
        if v.isGlobal == false && isRCPtype(v.type, elems) {
            OUTPUT += incrVar(v, elems)
        }
    }
}

beginRCPscopeLeaky(elems Elems*) {
    if RCPavailable() == false {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if v.isGlobal == false && v.outterScope == false && isRCPtype(v.type, elems) {
            OUTPUT += incrVar(v, elems)
        }
    }
}

endRCPscope(elems Elems*, excl []variable*) {
    if RCPavailable() == false {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if varInArr(v, excl) {
            continue
        }
        if v.isGlobal == false && isRCPtype(v.type, elems) {
            OUTPUT += decrVar(v, elems)
        }
    }
}

endRCPscopeLeaky(elems Elems*, excl variable*) {
    if RCPavailable() == false {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if excl != null && excl.name == v.name {
            continue
        }
        if v.isGlobal == false && v.outterScope == false && isRCPtype(v.type, elems) {
            OUTPUT += decrVar(v, elems)
        }
    }
}

// endRCPscope(elems Elems*, outter bool, exc []variable*) {
//     if RCPavailable() == false {
//         i=0; for i < len(elems.vars), i++ {
//             v = elems.vars[i]
//             if v.outterScope == false && varInArr(v, exc) == false && isRCPpointerType(v.type) == false {
//                 s = searchStruct(v.type, elems)
//                 if s != null {
//                     memb = searchStructMemb("_end", s, elems)
//                     if memb != null && memb.isFn == true {
//                         OUTPUT += rope(v.name+"._end(&"+v.name+");\n")
//                     }
//                 }
//             }
//         }
//         return
//     }
//     i=0; for i < len(elems.vars), i++ {
//         v = elems.vars[i]
//         takeOutter = false
//         if outter == true {
//             if v.outterScope == false {
//                 takeOutter = true
//             }
//         } else {
//             takeOutter = true
//         }
//         if takeOutter == true && v.isGlobal == false && varInArr(v, exc) == false {
//             if isRCPtype(v.type, elems) == true {
//                     OUTPUT = OUTPUT + decrVar(v, elems)
//             } else {
//                 s = searchStruct(v.type, elems)
//                 if s != null {
//                     memb = searchStructMemb("_end", s, elems)
//                     if memb != null {
//                         OUTPUT += rope(v.name+"._end(&"+v.name+");\n")
//                     }
//                 }
//             }
//         }
//     }
// }

// beginRCPscope(elems Elems*) {
//     if RCPavailable() == false {
//         return
//     }
//     // i=0; for i < len(vars), i++ {
//     //     v = vars[i]
//     //     if isRCPpointerType(v.type) == false {
//     //         s = searchStruct(v.type, elems)
//     //         if s == null {
//     //             continue
//     //         }
//     //         OUTPUT += rope("RCP_scanStack(&"+v.name+", sizeof("+v.name+"), 0);\n")
//     //     } else {
//     //         incrVar(v, elems)
//     //     }
//     // }

//     i=0; for i < len(elems.vars), i++ {
//         v = elems.vars[i]
//         if isRCPpointerType(v.type) == false {
//             s = searchStruct(v.type, elems)
//             if s == null {
//                 continue
//             }
//             OUTPUT += rope("RCP_scanStack(&"+v.name+", sizeof("+v.name+"), 0);\n")
//         } else {
//             OUTPUT += incrVar(v, elems)
//         }
//     }
// }

// decrRCPstackVars(vars []variable*, elems Elems*) {
//     if RCPavailable() == false {
//         return
//     }
//     i=0; for i < len(vars), i++ {
//         v = vars[i]
//         if isRCPpointerType(v.type) == false {
//             s = searchStruct(v.type, elems)
//             if s == null {
//                 continue
//             }
//             OUTPUT += rope("RCP_scanStack(&"+v.name+", sizeof("+v.name+"), 1);\n")
//         }
//     }
// }

// endRCPnonGlobScope(elems Elems*, exc []variable*) {
//     if RCPavailable() == false {
//         i=0; for i < len(elems.vars), i++ {
//             v = elems.vars[i]
//             if v.isGlobal == false && varInArr(v, exc) == false && isRCPpointerType(v.type) == false {
//                 s = searchStruct(v.type, elems)
//                 if s != null {
//                     fn = searchFunc(s.name + "___end", elems, true)
//                     if fn != null {
//                         OUTPUT += rope(v.name+"._end(&"+v.name+");\n")
//                     }
//                 }
//             }
//         }
//         return
//     }
//     i=0; for i < len(elems.vars), i++ {
//         v = elems.vars[i]
//         if varInArr(v, exc) == false {
//             if isRCPtype(v.type, elems) == true {
//                 OUTPUT += decrVar(v, elems)
//             } else {
//                 s = searchStruct(v.type, elems)
//                 if s != null {
//                     memb = searchStructMemb("_end", s, elems)
//                     if memb != null {
//                         OUTPUT += rope(v.name+"._end(&"+v.name+");\n")
//                     }
//                     OUTPUT += decrVar(v, elems)
//                 }

//             }
//         }
//     }
// }

registerRCPvar(t cpstring, c cpstring, elems Elems*) cpstring {
    av = new variable
    av.type = t
    av.name = genCompilerVar()
    elems.vars[len(elems.vars)] = av
    cType = getCType(av.type, elems)
    OUTPUT = OUTPUT + rope(cType.str()+" "+av.name+" ="+c+";")
    return av.name
}

// makeRCPfuncFromStruct(s cStruct*, elems Elems*) rope* {
//     if s.isBinding == true || RCPavailable() == false || isObject == true {
//         return rope("")
//     }

//     decrMembs = rope("")

//     i=0; for i < len(s.members) {
//         m = s.members[i]
//         rm = string(m.type)
//         rm.replace("*", "")
//         if isRCPtype(m.type, elems) {
//             if rm.str() != s.name {
//                 mv = new variable
//                 mv.name = "e->" + m.name
//                 mv.type = m.type
//                 decrMembs = decrMembs + decrVar(mv, elems)
//             } else {
//                 throwWarning("Strcture '"+s.name+"' has a self-referenced member '"+m.name+"'. May lead to memory leaks, recompile the program without the '-rcp' flag if memory leaks happens.")
//                 amp = "&"
//                 heap = "0"
//                 if strCount(m.type, "*") > 0 {
//                     amp = ""
//                     heap = "1"
//                 }
//                 mCType = getCType(m.type, elems)
//                 decrMembs = decrMembs + rope("
//                 {
//                     "+mCType.str()+" memb = "+amp+"e->"+m.name+";
//                     if (RCP_isAllocated(memb) == true) {
//                         __RCP_clean_"+s.name+"(memb, "+heap+");
//                     };
//                 }
//                 ")
//             }
//         }
//         i = i + 1
//     }
//     endCall = ""
//     endFn = searchStructMemb("_end", s, elems)
//     if endFn != null {
//         endCall = "e->_end(e);"
//     }


//     r = rope("void* __RCP_clean_"+s.name+"(struct "+s.name+"* e, int heap) {
//         if(heap == 1) {
//             struct RCP* srcp = RCP_request(e);
//             if (srcp != null) {
//                 if (srcp->c == 1) {
//                     ") + decrMembs + rope("
//                 }
//                 RCP_decrRCP(srcp);
//             }
//         } else if(RCP_decrCounter((void*)e->__RCP_counter)==0) {
//             "+endCall+"
//             ") + decrMembs + rope("
//         }
//     };\n")

//     return r
// }

RCPselfRef(v variable*) bool {
    i=0; for i < len(compilerState.RCPvars) {
        r = compilerState.RCPvars[i]
        if r.name == v.name {
            return true
        }
        i = i + 1
    }
    return false
}