//User optimization, passing argumeny by reference
OPTI_checkFuncScopeRef(elems Elems*) {
    if strHasPrefix(compilerState.currentFile, BAH_DIR) == true {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if v.isArg == false {
            continue
        }
        if v.lastSet != elems {
            if isRCPpointerType(v.type) == false && v.type != "reflectElement" && string(v.name).hasPrefix("____BAH_COMPILER_VAR_") == false {
                s = searchStruct(v.type, elems)
                if s != null && currentFn != null {
                    throwNoticeLine("in \e[1;37m"+currentFn.name+"()\e[0m: argument \e[1;37m"+v.name+"\e[0m ("+v.type+") could be passed by reference.", currentFn.line)
                }
            }
        }
    }
}

//Is a token an expensive expretion to evaluate.
//Usefull for helped branch prediction.
isExprExpensive(t Tok*) bool {
    if t.isExpensive == true {
        return true
    }

    if t.type != TOKEN_TYPE_VAR && t.type != TOKEN_TYPE_INT && t.type != TOKEN_TYPE_FLOAT {
        return true
    }
    return false
}

//Converts a byte to C octal notation.
byteToOctal(b byte) cpstring {
    n uint32 = b
    r = ""
    i=0; for n != 0, i++ {
        r = intToStr(n % 8) + r
        n /= 8
    }
    escp = "\\0"
    if i == 3 {
        escp = escp[:1]
    }
    return escp + r
}

//Returns an int encoded in C octal notation.
escapeIntOctal(n int) cpstring {
    s cpstring = &n
    r = ""
    i=0; for i < 8, i++ {
        r += byteToOctal(<byte>s[i])
    }
    return r
}

getStrLen(s cpstring) uint {
    l = 0
    i=0; for s[i] != null, i++ {
        if s[i] == <char>92 {
            continue
        }
        l++
    }
    return l
}

strLitteralToBahStr(s cpstring) cpstring {
    return s
    // l = getStrLen(s) - 2
    // return "(char*)(\"" + escapeIntOctal(l) +"#"+ s[1:] + "+9)"
}