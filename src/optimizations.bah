//User optimization, passing argumeny by reference
OPTI_checkFuncScopeRef(elems Elems*) {
    if strHasPrefix(compilerState.currentFile, BAH_DIR) == true {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if v.isArg == false {
            continue
        }
        if v.lastSet != elems {
            if isRCPpointerType(v.type) == false && v.type != "reflectElement" && string(v.name).hasPrefix("____BAH_COMPILER_VAR_") == false {
                s = searchStruct(v.type, elems)
                if s != null && currentFn != null {
                    if debug {
                        throwNoticeLine("in "+currentFn.name+"(): argument "+v.name+" ("+v.type+") could be passed by reference.", currentFn.line)

                    } else {
                        throwNoticeLine("in \e[1;37m"+currentFn.name+"()\e[0m: argument \e[1;37m"+v.name+"\e[0m ("+v.type+") could be passed by reference.", currentFn.line)
                    }
                }
            }
        }
    }
}

//Is a token an expensive expretion to evaluate.
//Usefull for helped branch prediction.
isExprExpensive(t Tok*) bool {
    if t.isExpensive == true {
        return true
    }

    if t.type != TOKEN_TYPE_VAR && t.type != TOKEN_TYPE_INT && t.type != TOKEN_TYPE_FLOAT {
        return true
    }
    return false
}

//Converts a byte to C octal notation.
byteToOctal(b byte) cpstring {
    n uint32 = b
    r = ""
    i=0; for n != 0, i++ {
        r = intToStr(n % 8) + r
        n /= 8
    }
    escp = "\\0"
    if i == 3 {
        escp = escp[:1]
    }
    return escp + r
}

//Returns an int encoded in C octal notation.
escapeIntOctal(n int) cpstring {
    s char* = &n
    r = ""
    i=0; for i < 4, i++ {
        r += byteToOctal(<byte>noCheck(s[i]))
    }
    return r
}

getStrLen(s cpstring) uint {
    l = len(s)
    n = 0
    i=1; for i+1 < l, i++ {
        n++
        if s[i] == <char>92 {
            if s[i+1] == <char>10 {
                i++
            } else if s[i+1] == '0' {
                i++
                start = i
                for i-start < 2, i++ {
                    if isNumber(s[i]) == false {
                        break
                    }
                }
                i--
            }
            i++
        }
    }

    return n
}

strLitteralToBahStr(s cpstring) cpstring {
    l = getStrLen(s)
    return "\"" + escapeIntOctal(l) + "\"" + s
}