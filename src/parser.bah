#include "iostream.bah"
#include "string.bah"
#include "path.bah"

#include "./logger.bah"
#include "./lexer.bah"
#include "./var.bah"
#include "./mem.bah"
#include "./verboseOut.bah"

debugLine(line []Tok) {
    cont = ""
    i=0; for i < len(line) {
        t = line[i]
        cont = cont + " '" + t.cont + "'"
        i =i + 1
    }
    println(cont)
}


dupElems(elems Elems*) Elems* {

    nElems = new Elems

    //vars
    j=0; for j < len(elems.vars) {
        v = elems.vars[j]
        nv = new variable
        *nv = *v
        nv.outterScope = true
        nElems.vars[j] = nv
        j = j + 1
    }

    //structs
    j=0; for j < len(elems.structs) {
        s = elems.structs[j]
        ns = new cStruct
        *ns = *s
        nElems.structs[j] = ns
        j = j + 1
    }

    //types
    j=0; for j < len(elems.types) {
        t = elems.types[j]
        nt = t
        nElems.types[j] = nt
        j = j + 1
    }

    //fns
    j=0; for j < len(elems.fns) {
        f = elems.fns[j]
        nf = new func
        *nf = *f
        nElems.fns[j] = nf
        j = j + 1
    }


    return nElems
}

#define lineType int

const LINE_TYPE_INCLUDE = <lineType>0
const LINE_TYPE_DEFINE = <lineType>1
const LINE_TYPE_CONST = <lineType>2
const LINE_TYPE_VAR = <lineType>3
const LINE_TYPE_FN_DECL = <lineType>4
const LINE_TYPE_FN_CALL = <lineType>5
const LINE_TYPE_STRUCT = <lineType>6
const LINE_TYPE_CLIB = <lineType>7
const LINE_TYPE_RETURN = <lineType>8
const LINE_TYPE_IF = <lineType>9
const LINE_TYPE_ELSE = <lineType>10
const LINE_TYPE_MACRO = <lineType>11
const LINE_TYPE_FOR = <lineType>12
const LINE_TYPE_FOR_OPERATOR = <lineType>13
const LINE_TYPE_PRE_KEYWORD = <lineType>14
const LINE_TYPE_ASYNC = <lineType>15

prevLine = <lineType>-1

getLineType(line []Tok) lineType {

    ft = line[0]

    if ft.type == TOKEN_TYPE_FUNC {
        return LINE_TYPE_FN_CALL
    }
    if ft.type == TOKEN_TYPE_KEYWORD {
        if ft.cont == "#include" {
            return LINE_TYPE_INCLUDE
        } else if ft.cont == "#define" {
            return LINE_TYPE_DEFINE
        } else if ft.cont == "const" {
            return LINE_TYPE_CONST
        } else if ft.cont == "struct" {
            return LINE_TYPE_STRUCT
        } else if ft.cont == "#cLib" {
            return LINE_TYPE_CLIB
        } else if ft.cont == "return" {
            return LINE_TYPE_RETURN
        } else if ft.cont == "if" {
            return LINE_TYPE_IF
        } else if ft.cont == "else" {
            return LINE_TYPE_ELSE
        } else if ft.cont == "#macro" {
            return LINE_TYPE_MACRO
        } else if ft.cont == "for" {
            return LINE_TYPE_FOR
        } else if ft.cont == "async" {
            return LINE_TYPE_ASYNC
        } else if ft.cont == "continue" || ft.cont == "break" {
            return LINE_TYPE_FOR_OPERATOR
        } else {
            return LINE_TYPE_PRE_KEYWORD
        }
    } else if ft.type == TOKEN_TYPE_VAR {
        if len(line) == 1 {
            throwErr(&ft, "Cannot declare var {TOKEN} without a type.")
        }
        st = line[1]
        if st.type == TOKEN_TYPE_ENCL && st.cont == "(" {
            lt = line[len(line)-1]
            if lt.type == TOKEN_TYPE_ENCL && lt.cont == "}"{
                return LINE_TYPE_FN_DECL
            }
            return LINE_TYPE_FN_CALL
        }

        return LINE_TYPE_VAR
    }

    return <lineType>-1
}


//Inline parsing
parseCast(line []Tok, elems Elems*) []Tok {

    nl = []Tok

    i=0; for i < len(line) {
        t = line[i]
        if t.cont == "<" {
            break
        }
        nl[i] = t
        i = i + 1
    }
    if i == len(line) {
        return line
    }

    for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_SYNTAX {
            if t.cont == "<" {
                max = i + 3
                if max < len(line) {
                    nt = line[i+1]
                    nnt = line[i+2]
                    nnnt = line[i+3]
                    if nt.type == TOKEN_TYPE_VAR {
                        if nnt.type == TOKEN_TYPE_SYNTAX {
                            if nnt.cont == ">" {
                                
                                nnnt.bahType = nt.cont
                                cCast = getCType(nt.cont, elems)
                                cCastStr = cCast.str()
                                nnnt.cont = "("+cCastStr+")"+nnnt.cont
                                nl[len(nl)] = nnnt
                                i = i + 4
                                continue
                            }
                        }
                    }
                }
            }
        }

        nl[len(nl)] = t

        i =i + 1
    }

    return nl
}

getDirFromFile(f cpstring) cpstring {
    p = strAsArr(__STR(f))
    i = len(p)-1; for i >= 0 {
        c = p[i]
        if c == '/' {
            p[i+1] = <char>0
            break
        }
        i = i - 1
    }

    if i <= 0 {
        return ""
    }

    return arrAsStr(p)
}

#define parseLines(ts []Tok, elems Elems*)
includeFile(ccstr cpstring, elems Elems*) bool {

    if ccstr == "BAH_MEM_COLLECTOR" {
        if RCPenabled == true {
            if flags.isSet("rcp") {
                ccstr = "rcp.bah"
            } else if flags.isSet("fastrcp") {
                ccstr = "fastrcp.bah"
            }
        } else {
            ccstr = "gc.bah"
        }
    }

    includes = compilerState.includes
    i=0; for i < len(includes) {
        if includes[i] == ccstr {
            return true
        }
        i =i + 1
    }
    fm = fileMap{}
    fileName = BAH_DIR + ccstr
    isBahDir = true
    f = fm.open(fileName)
    if fm.isValid() == 0 {
        fileName = absPath(compilerState.currentDir + ccstr)
        f = fm.open(fileName)
        isBahDir = false
        if fm.isValid() == 0 {
            return false
        }
    }
    oDir = compilerState.currentDir
    if isBahDir == false {
        compilerState.currentDir = compilerState.currentDir + getDirFromFile(ccstr)
    } else {
        compilerState.currentDir = BAH_DIR + getDirFromFile(ccstr)
    }
    oFile = compilerState.currentFile
    compilerState.currentFile = fileName
    includes[len(includes)] = ccstr
    tokens = lexer(f)
    fm.close()
    if len(tokens) == 0 {
        panic("File '"+ccstr+"' not recognized.")
    }
    parseLines(tokens, elems)
    compilerState.currentFile = oFile 
    compilerState.currentDir = oDir

    return true
}

parseInclude(l []Tok, elems Elems*) {

    if len(l) > 2 {
        throwErr(&l[len(l)-1], "Invalid usage of include, ending by {TOKEN}.")
    }
    strt = l[1]
    if strt.type != TOKEN_TYPE_STR {
        throwErr(&strt, "Cannot use {TOKEN} as string in include.")
    }
    sc = strt.cont
    strTrimLeft(&sc, 1)
    strTrimRight(&sc, 1)
    if strHasPrefix(sc, "<") || strHasSuffix(sc, ".h") || strHasSuffix(sc, ".c") {
        OUTPUT = OUTPUT + rope("#include "+sc+"\n")
        compilerState.cIncludes[len(compilerState.cIncludes)] = sc
    } else {
        if includeFile(sc, elems) == false {
            throwErr(&strt, "Could not find file {TOKEN}.")
        }
    }

}

signs = []cpstring{"|", "&", "%", "+", "-", "*", "/"}

parseOperations(line []Tok, ltp lineType, elems Elems*) []Tok {

    nl = []Tok{line[0]}

    i=1; for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_SYNTAX && inArrayStr(t.cont, signs) {
            if i + 1 >= len(line) {
                throwErr(&t, "Cannot use {TOKEN} on nothing.")
            }
            pt = nl[len(nl)-1]
            nt = line[i+1]
            if t.cont == "-" && pt.isValue == false && nt.type == TOKEN_TYPE_INT {
                nt.cont = t.cont + nt.cont
                nl[len(nl)] = nt
                i = i + 2
                continue
            }
            
            if nt.type == TOKEN_TYPE_SYNTAX && nt.cont == t.cont {
                c = t.cont + nt.cont
                tl = t.line
                tp = t.pos
                tmpT = Tok{
                    cont: c
                    ogCont: c
                    isValue: false
                    line: tl
                    pos: tp
                    type: TOKEN_TYPE_SYNTAX
                }
                nl[len(nl)] = tmpT
                i = i + 2
                continue
            }

            ptt = getTypeFromToken(&pt, true, elems)
            ntt = getTypeFromToken(&nt, true, elems)
            if compTypes(ptt, ntt) == false {
                throwErr(&nt, "Cannot use {TOKEN} ("+ntt+") as "+ptt+".")
            }
            t.isValue = true

            if verboseRuntime == true && ltp != LINE_TYPE_ELSE {
                if isRCPpointerType(ntt) || isRCPpointerType(ptt) {
                    verboseOutOper(pt, nt, pt.line, elems)
                }
            }

            if compTypes(ptt, "cpstring") {
                if t.cont != "+" {
                    throwErr(&t, "Can only do concatenation (+) on cpstrings, not {TOKEN}.")
                }
                j = i - 1
                wasAdd = true
                strConts = []cpstring
                for j < len(line) {
                    strAddTk = line[j]
                    if wasAdd == false {
                        if strAddTk.cont != "+" {
                            break
                        }
                        wasAdd = true
                    } else {
                        strAddTkT = getTypeFromToken(&strAddTk, true, elems)
                        if compTypes(strAddTkT, "cpstring") == false {
                            throwErr(&strAddTkT, "Cannot use {TOKEN} ("+ntt+") as "+ptt+".")
                            break
                        }
                        if strAddTk.type == TOKEN_TYPE_FUNC && strHasPrefix(strAddTk.cont, "noCheck(") == false && isRCPtype(strAddTkT, elems) == true {
                            strConts[len(strConts)] = registerRCPvar(strAddTkT, strAddTk.cont, elems)
                        } else {
                            strConts[len(strConts)] = strAddTk.cont
                        }
                        wasAdd = false
                    }
                    j = j + 1
                }
                
                // if len(strConts) > 2 {
                    i = j

                    rstr = registerRCPvar("cpstring", "null", elems)

                    lens = ""
                    totStrLen = "1"
                    j=0; for j < len(strConts) {
                        js = intToStr(j)
                        lens = lens + "long int strLen_"+js+" = strlen("+strConts[j]+");\n"
                        totStrLen = totStrLen + " + strLen_"+js
                        j = j + 1
                    }
                    cats = rope("")
                    j=0; for j < len(strConts) {
                        js = intToStr(j)
                        cats = cats + rope("
                        strncpy("+rstr+"+currStrOff, "+strConts[j]+", strLen_"+js+");
                        currStrOff += strLen_"+js+";
                        ")
                        j = j + 1
                    }

                    res = rope("
                    {
                        long int currStrOff = 0;
                        "+lens+";                            
                        "+rstr+" = memoryAllocSTR("+totStrLen+");
                        ")+cats+rope("
                    }
                    ")

                    if isGlobal() {
                        INIT = INIT + res
                    } else {
                        OUTPUT = OUTPUT + res
                    }



                    t.cont = rstr

                    t.type = TOKEN_TYPE_VAR
                    t.bahType = ptt
                    t.isOper = false
                    t.pos = pt.pos
                    t.ogCont = pt.cont
                    nl[len(nl)-1] = t
                    continue
            } else {
                s = searchStruct(ptt, elems)
                if s != null {
                    addMthd = searchStructMemb("add", s, elems)
                    subMthd = searchStructMemb("sub", s, elems)
                    multMthd = searchStructMemb("mult", s, elems)
                    divMthd = searchStructMemb("div", s, elems)
                    sep = "."
                    amp = "&"
                    if strCount(ptt, "*") > 0 {
                        sep = "->"
                        amp = ""
                    }
                    if t.cont == "+" && addMthd != null && addMthd.isFn == true {
                        t.cont = pt.cont + sep + "add(" + amp + pt.cont + ", "+nt.cont+")"
                    } else if t.cont == "-" && subMthd != null && subMthd.isFn == true {
                        t.cont = pt.cont + sep + "sub(" + amp + pt.cont + ", "+nt.cont+")"
                    } else if t.cont == "*" && multMthd != null && multMthd.isFn == true {
                        t.cont = pt.cont + sep + "mult(" + amp + pt.cont + ", "+nt.cont+")"
                    } else if t.cont == "/" && divMthd != null && divMthd.isFn == true {
                        t.cont = pt.cont + sep + "div(" + amp + pt.cont + ", "+nt.cont+")"
                    } else {
                        throwErr(&pt, "Undefined operation on {TOKEN} ("+ptt+").")
                    }
                } else {
                    t.cont = pt.cont + " " + t.cont + " " + nt.cont
                }
            }
            t.type = TOKEN_TYPE_VAR
            t.bahType = ptt
            t.pos = pt.pos
            t.isOper = true
            t.ogCont = pt.cont
            nl[len(nl)-1] = t
            i = i + 2
            continue
        } 
        else if t.isValue == true {
            if strHasPrefix(t.cont, "-") {
                pt = nl[len(nl)-1]
                if pt.isValue == true {
                    ptt = getTypeFromToken(&pt, true, elems)
                    ntt = getTypeFromToken(&t, true, elems)
                    if compTypes(ptt, ntt) == false {
                        throwErr(&t, "Cannot use {TOKEN} ("+ntt+") as "+ptt+".")
                    }
                    t.type = TOKEN_TYPE_VAR
                    t.isOper = true
                    t.cont = pt.cont + t.cont
                    t.bahType = ptt
                    t.pos = pt.pos
                    nl[len(nl)-1] = t
                    i = i + 1
                    continue
                }
            }
        }
        nl[len(nl)] = t
        i =i + 1
    }

    return nl
}

#define prePross(line []Tok, ltp lineType, elems Elems*) []Tok


parseStructType(line []Tok, elems Elems*) []Tok {

    nl = []Tok

    i=0; for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_VAR {
            if strHasPrefix(t.bahType, "[]") {
                nl[len(nl)] = t
                i =i + 1
                continue
            }
            i =i + 1
            if i < len(line) {
                nt = line[i]
                if nt.cont == "{" {
                    i = i + 1
                    s = searchStruct(t.cont, elems)
                    if s == null {
                        throwErr(&t, "Unknown struct name {TOKEN}.")
                    }
                    memory = []Tok
                    for i < len(line) {
                        t = line[i]
                        if t.cont == "}" {
                            break
                        }
                        memory[len(memory)] = t
                        i = i + 1
                    }

                    if len(memory) > 0 {
                        memory = prePross(memory, <lineType>-1, elems)
                    }

                    declType = 0
                    rvn = genCompilerVar()
                    tmpV = new variable
                    tmpV.name = rvn
                    tmpV.type = s.name
                    rst = getCType(s.name, elems)
                    r = rope(rst.str()+" "+rvn+" = "+"{};\n"+declareStructMethods(tmpV, s, elems))
                    j=0;k=0; for k < len(memory) {
                        t = memory[k]
                        if k+2 < len(memory) {
                            st = memory[k+1]
                            vl = memory[k+2]
                            if st.cont == ":" {
                                if declType != 0 && declType != 1 {
                                    throwErr(&t, "Cannot declare member {TOKEN} by name in list declaration.")
                                }
                                declType = 1
                                if t.type != TOKEN_TYPE_VAR {
                                    throwErr(&t, "Cannot use {TOKEN} as struct member name.")
                                }
                                j=0; for j < len(s.members) {
                                    m = s.members[j]
                                    if m.name != t.cont {
                                        j = j + 1
                                        continue
                                    }
                                    vlt = getTypeFromToken(&vl, true, elems)
                                    if compTypes(vlt, m.type) == false {
                                        throwErr(&vl, "Cannot use {TOKEN} ("+vlt+") as '"+m.type+"'.")
                                    }
                                    r = r + rope(rvn+"."+m.name+" = "+vl.cont+";\n")
                                    break
                                }
                                if j == len(s.members) {
                                    throwErr(&t, "Struct '"+s.name+"' has no member called {TOKEN}.")
                                }
                                k = k + 3
                                continue
                            }
                        }
                        if declType != 0 && declType != 2 {
                            throwErr(&t, "Cannot declare member {TOKEN} without specifying its name.")
                        }
                        declType = 2

                        if j > len(s.members) {
                            throwErr(&t, "Too many members {TOKEN}.")
                        }
                        m = s.members[j]
                        j = j + 1

                        tt = getTypeFromToken(&t, true, elems)
                        if compTypes(tt, m.type) == false {
                            throwErr(&t, "Cannot use {TOKEN} ("+tt+") as '"+m.type+"'.")
                        }

                        r = r + rope(rvn+"."+m.name+" = "+t.cont+";\n")

                        if k+1 < len(memory) {
                            k = k + 1
                            st = memory[k]
                            if st.cont != "," {
                                throwErr(&st, "Need ',' separator between two values, not {TOKEN}.")
                            }
                        }
                        k = k + 1
                    }

                    if isGlobal() {
                        INIT = INIT + r
                    } else {
                        OUTPUT = OUTPUT + r
                    }

                    t.bahType = s.name
                    t.cont = rvn
                    t.isValue = true
                    nl[len(nl)] = t
                    i =i + 1
                    continue
                    
                } else {
                    i =i - 1
                }
            }
        }
        nl[len(nl)] = t
        i =i + 1
    }


    return nl
}

parseStructVars(line []Tok, elems Elems*) []Tok {

    nl = []Tok

    i=0; for i < len(line) {
        t = line[i]
        if t.cont == "." {
            break
        }
        i = i + 1
    }
    if i == len(line) {
        return line
    }
    

    i=0;for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_VAR {
            i =i + 1
            for i < len(line) {
                it = line[i]
                if it.cont != "." {
                    break
                }
                    v = searchVar(t.cont, elems)
                    if v == null {
                        throwErr(&t, "Unknown var {TOKEN}.")
                    }
                    sep = "."
                    if strCount(v.type, "*") {
                        sep = "->"
                    }
                    s = searchStruct(v.type, elems)
                    if s == null {
                        throwErr(&t, "Cannot use {TOKEN} ("+v.type+") as a structure.")
                    }
                    i =i + 1
                    nt = line[i]
                    if nt.type != TOKEN_TYPE_VAR {
                        throwErr(&nt, "Cannot use {TOKEN} as struct member name.")
                    }
                    memb = searchStructMemb(nt.cont, s, elems)
                    if memb == null {
                        throwErr(&nt, "Unknown struct member {TOKEN}.")
                    }
                    t.cont = t.cont + sep + memb.name
                i =i + 1
            }
            nl[len(nl)] = t
            continue
        }

        nl[len(nl)] = t
        i =i + 1
    }


    return nl
}

parseArrayType(line []Tok, elems Elems*) []Tok {

    nl = []Tok

    i=0; for i < len(line), i++ {
        t = line[i]
        if t.cont == "[" {
            break
        }
        nl[i] = t
    }
    if i == len(line) {
        return line
    }

    for i < len(line), i++ {
        t = line[i]
        if t.cont == "[" {
            i++
            if i < len(line) {
                t = line[i]
                if t.cont == "]" {
                    i++
                    depth = 1
                    bracks = "[]"
                    for i < len(line) - 1, i++ {
                        t = line[i]
                        nt = line[i+1]
                        if t.cont == "[" && nt.cont == "]" {
                            depth++
                            bracks = bracks + "[]" 
                            i++
                        } else {
                            break
                        }
                    }
                    if i < len(line) {
                        t = line[i]
                        if t.type != TOKEN_TYPE_VAR {
                            throwErr(&t, "Cannot use {TOKEN} as array type.")
                        }
                        arrElem = t.cont
                        t.bahType = bracks+arrElem
                        t.cont = ""
                        t.isValue = true
                        nl[len(nl)] = t
                        continue
                    }
                }
            }
        }

        nl[len(nl)] = t
    }

    return nl
}

comparators = []cpstring{"==", "!=", ">", "<", "<=", ">=", "in"}
compSep = []cpstring{"||", "&&"}

parseBool(line []Tok, elems Elems*) []Tok {

    nl = []Tok


    i=0; for i < len(line) {
        t = line[i]
        if inArrayStr(t.cont, comparators) || inArrayStr(t.cont, compSep) {
            break
        }
        nl[i] = t
        i = i + 1
    }
    if i == len(line) {
        return line
    }

    for i < len(line) {
        t = line[i]

        if inArrayStr(t.cont, comparators) {
            if i == 0 {
                throwErr(&t, "Cannot use {TOKEN} to compare with nothing.")
            }
            pt = nl[len(nl)-1]
            max = i + 1
            if max >= len(line) {
                throwErr(&t, "Cannot use {TOKEN} to compare with nothing.")
            }
            nt = line[i+1]
            ptt = getTypeFromToken(&pt, true, elems)
            ntt = getTypeFromToken(&nt, true, elems)

            if t.cont == "in" {
                arrT = string(ntt)
                if arrT.hasPrefix("[]") == 0 {
                    throwErr(&nt, "Cannot use {TOKEN} ("+ntt+") as an array.")
                }
                arrT.trimLeft(2)
                if compTypes(ptt, arrT.str()) == false {
                    throwErr(&pt, "Cannot search for {TOKEN} ("+ptt+") inside array of type "+ntt+".")
                }
                compVar = genCompilerVar()

                comp = ""

                if ptt == "cpstring" {
                    comp = nt.cont+"->data[i] != 0 && strcmp("+nt.cont+"->data[i], "+pt.cont+") == 0"
                } else {
                    comp = nt.cont+"->data[i] == "+pt.cont
                }

                OUTPUT = OUTPUT + rope("
                int "+compVar+" = 0;
                for(int i=len("+nt.cont+")-1; i != -1; i--) {
                    if ("+comp+") {
                        "+compVar+" = 1;
                        break;
                    };
                };
                ")
                pt.cont = compVar
            } else {
                if compTypes(ptt, ntt) == false {
                    throwErr(&nt, "Cannot compare {TOKEN} ("+ntt+") to "+ptt+".")
                }
                if ptt == "cpstring" {
                    check = ""
                    if pt.type != TOKEN_TYPE_STR {
                        check = "__checkString("+pt.cont+", \""+compilerState.currentFile+":"+intToStr(t.line)+" "+pt.cont+" \")==1&&"
                    }
                    if nt.type != TOKEN_TYPE_STR {
                        check = check + "__checkString("+nt.cont+", \""+compilerState.currentFile+":"+intToStr(t.line)+" "+nt.cont+"\")==1&&"
                    }
                    if t.cont == "==" {
                        pt.cont = "(" + check + "strcmp("+pt.cont+", "+nt.cont+") == 0)"
                    } else if t.cont == "!=" {
                        pt.cont = "(" + check + "strcmp("+pt.cont+", "+nt.cont+") != 0)"
                    } else if t.cont == ">" {
                        pt.cont = "(" + check + "strlen("+pt.cont+") > srtlen("+nt.cont+"))"
                    } else if t.cont == "<" {
                        pt.cont = "(" + check + "strlen("+pt.cont+") < srtlen("+nt.cont+"))"
                    } else if t.cont == ">=" {
                        pt.cont = "(" + check + "strlen("+pt.cont+") >= srtlen("+nt.cont+"))"
                    } else if t.cont == "<=" {
                        pt.cont = "(" + check + "strlen("+pt.cont+") <= srtlen("+nt.cont+"))"
                    }
                } else {
                    pt.cont = "(" + pt.cont + t.cont + nt.cont + ")"
                }
            }
            pt.bahType = "bool"
            nl[len(nl)-1] = pt
            i = i + 2
            continue
        }

        nl[len(nl)] = t
        i =i + 1
    }


    line = nl
    nl = []Tok
    i=0; for i < len(line) {
        t = line[i]
        if inArrayStr(t.cont, compSep) {
            if i == 0 {
                throwErr(&t, "Cannot use {TOKEN} to compare with nothing.")
            }
            pt = nl[len(nl)-1]
            max = i + 1
            if max >= len(line) {
                throwErr(&t, "Cannot use {TOKEN} to compare with nothing.")
            }
            nt = line[i+1]
            ptt = getTypeFromToken(&pt, true, elems)
            ntt = getTypeFromToken(&nt, true, elems)
            if ptt != "bool" {
                if ptt != "int" {
                    throwErr(&pt, "Cannot compare {TOKEN} that is not a bool.")
                }
            }
            if ntt != "bool" {
                if ntt != "int" {
                    throwErr(&nt, "Cannot compare {TOKEN} that is not a bool.")
                }
            }
            pt.cont = "(" + pt.cont + t.cont + nt.cont + ")"
            pt.bahType = "bool"
            nl[len(nl)-1] = pt
            i = i + 2
            continue

        }

        nl[len(nl)] = t
        i =i + 1
    }


    return nl
}

parsePointers(l []Tok) []Tok {

    nl = []Tok

    ptrOpers = []cpstring{"&", "*"}

    i=0; for i < len(l) {
        t = l[i]

        if t.type == TOKEN_TYPE_SYNTAX {
            if t.cont == "*" {
                if i > 0 {
                    pt = nl[len(nl)-1]
                    if pt.type == TOKEN_TYPE_VAR {
                        if i + 1 < len(l) {
                            nt = l[i+1]
                            if nt.isValue == false {
                                pt.cont = pt.cont + t.cont
                                nl[len(nl)-1] = pt
                                i = i + 1
                                continue
                            }
                        } else {
                            pt.cont = pt.cont + t.cont
                            nl[len(nl)-1] = pt
                            i = i + 1
                            continue
                        }
                    }
                }
            }

            if inArrayStr(t.cont, ptrOpers) {
                if i > 0 {
                    pt = nl[len(nl)-1]
                    if pt.isValue == true {
                        nl[len(nl)] = t
                        i = i + 1
                        continue            
                    }
                }
                i = i + 1
                if i < len(l) {
                    nt = l[i]
                    if nt.type == TOKEN_TYPE_VAR {
                        nt.cont = t.cont + nt.cont
                        nl[len(nl)] = nt
                        i = i + 1
                        continue
                    }
                }
            }
        }

        nl[len(nl)] = t
        i = i + 1
    }


    return nl
}


parseArrayVars(l []Tok, elems Elems*) []Tok {

    nl = []Tok

    found = false
    i=0; for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_VAR {
            i = i + 1
            if i < len(l) {
                t = l[i]
                if t.cont == "[" {
                    found = true
                    break
                }
            }
        }
        i = i + 1
    }
    if found == false {
        return l
    }

    ft = l[0]

    i=0; for i < len(l), i++ {
        t = l[i]

        if t.cont == "[" {
            ti = i-1
            lt = nl[len(nl)-1]
            if lt.type != TOKEN_TYPE_VAR && lt.type != TOKEN_TYPE_FUNC {
                nl[len(nl)] = t
                continue
            }
            tt = getTypeFromToken(&lt, true, elems)
            if strHasPrefix(tt, "[]") == false {
                throwErr(&lt, "Cannot use {TOKEN} ("+tt+") as an array.")
            }
            strTrimLeft(&tt, 2)

            memory = []Tok
            i =i + 1
            nbBracks = 1
            for i < len(l), i++ {
                it = l[i]
                if it.cont == "[" {
                    nbBracks =nbBracks + 1
                } else if it.cont == "]" {
                    nbBracks =nbBracks - 1
                    if nbBracks == 0 {
                        break
                    }
                }
                memory[len(memory)] = it
            }
            if len(memory) == 0 {
                throwErr(&l[i], "Expected index not {TOKEN}.")
            }

            memory = prePross(memory, <lineType>-1, elems)

            cont = ""
            j=0; for j < len(memory), j++ {
                mt = memory[j]
                cont = cont + mt.cont
            }

            if ti > 0 && ft.cont != "else" {
                OUTPUT = OUTPUT + rope("
                if ("+lt.cont+"->length <= "+cont+") {
                    printf(\"array ("+compilerState.currentFile+":"+intToStr(lt.line)+"): "+lt.cont+"[%d] with length %d\\n\", "+cont+", "+lt.cont+"->length);
                    exit(1);
                };
                ")
            }

            lt.cont = lt.cont + "->data[" + cont + "]"
            lt.bahType = tt
            nl[len(nl)-1] = lt
            continue
        }

        nl[len(nl)] = t
    }

    return nl
}

parseSerialize(e Tok, elems Elems*) cpstring {


    v = searchVar(e.cont, elems)
    if v == null {
        throwErr(&e, "Must be a var, not {TOKEN}.")
    }

    s = searchStruct(v.type, elems)
    if s == null {
        throwErr(&e, "Must be a struct, not {TOKEN}.")
    }

    svt = string(v.type)
    ptrLevel = svt.count("*")
    
    svt.replace("*", "")

    code cpstring

    if ptrLevel == 0 {
        code = "__serialize(&" + e.cont + ", " + "sizeof(struct "+svt.str()+")"
    } else {
        ptrRect = ""
        for ptrLevel > 1 {
            ptrRect = ptrRect + "*"
            ptrLevel = ptrLevel - 1
        }
        code = "__serialize(" + ptrRect + e.cont + ", " + "sizeof(struct "+svt.str()+")"
        //is heap allocated, meanning we should calculate real size

        i=0; for i < len(s.members) {
            m = s.members[i]
            if m.type == "cpstring" {
                code = code + "+strlen("+e.cont+"->"+m.name+")"
            }
            i = i + 1
        }   

    }


    return code + ")"
}

parseReflect(t Tok, tt cpstring, elems Elems*, parsedPointer bool, ogName cpstring, offset cpstring) Tok {

    isArr = "0"

    if t.type != TOKEN_TYPE_VAR || t.type != TOKEN_TYPE_FUNC {
        cType = getCType(tt, elems)
        v = genCompilerVar()
        if parsedPointer == true {
            cType.append("*")
        }
        OUTPUT = OUTPUT + rope(cType.str()+" "+v+" = "+t.cont+";\n")
        t.cont = v
        if t.type == TOKEN_TYPE_STR {
            ogName = "[bah cpstring]"
        }
    }

    arrElem = "0"
    if strHasPrefix(tt, "[]") {
        isArr = "1"
        aet = string(tt)
        aet.trimLeft(2)
        tmpT = Tok{}
        tmpT.type = TOKEN_TYPE_VAR
        tmpT.cont = "0"
        rt = parseReflect(tmpT, aet.str(), elems, true, "", "0")
        
        aev = genCompilerVar()
        
        OUTPUT = OUTPUT + rope("
        struct reflectElement "+aev+" = "+rt.cont+";
        ")

        arrElem = "&"+aev
    }

    isStruct = "0"
    ts = searchStruct(tt, elems)
    structLayout = "0"    

    if ts != null {
        isStruct = "1"
        structLayout = genCompilerVar()

        slv = new variable
        slv.name = structLayout
        slv.type = "[]reflectElement"

        elems.vars[len(elems.vars)] = slv

        dataLayout = rope("")

        i=0; for i < len(ts.members) {
            m = ts.members[i]
            tmpT = Tok{}
            tmpT.type = TOKEN_TYPE_VAR
            sep = "->"
            if strCount(tt, "*") == 0 {
                sep = "."
            }
            mCtype = getCType(m.type, elems)
            offsetTT = string(tt)
            offsetTT.replace("*", "")
            tmpT.cont = "("+mCtype.str()+"*)((char*)("+t.cont+") + offsetof(struct "+offsetTT.str()+", "+m.name+"))"
            rt = parseReflect(tmpT, m.type, elems, true, m.name, "offsetof(struct "+offsetTT.str()+", "+m.name+")")
            dataLayout = dataLayout + rope(structLayout+"->data["+intToStr(i)+"] = "+rt.cont+";\n")
            i = i + 1
        }

        OUTPUT = OUTPUT + rope("
        array(struct reflectElement) * "+structLayout+" = memoryAlloc(sizeof(array(struct reflectElement)));
        "+structLayout+"->elemSize = sizeof(struct reflectElement);
        "+structLayout+"->length = "+intToStr(len(ts.members))+";
        "+structLayout+"->data = memoryAlloc("+structLayout+"->length * "+structLayout+"->elemSize);
        ") + dataLayout
    }

    amp = ""
    if strCount(tt, "*") == 0 && tt != "cpstring" && tt != "ptr" && parsedPointer == false {
        amp = "&"
    }

    name = string(ogName)
    if hasStructSep(name) == true {
        name = splitStructSepAfter(name)
    }

    cType = getCType(tt, elems)

    if cType.hasPrefix("struct ") {
        cType.replace("*", "")
    }

    if cType.length == 0 {
        cType.set("0")
    }

    rv = new variable
    rv.name = genCompilerVar()
    rv.type = "reflectElement"

    elems.vars[len(elems.vars)] = rv

    OUTPUT = OUTPUT + rope("struct reflectElement "+rv.name+" = __reflect("+amp+t.cont+", sizeof("+cType.str()+"), \""+tt+"\", \""+name.str()+"\", "+isArr+", "+arrElem+", "+isStruct+", "+structLayout+", "+offset+");\n")
                        //                                                    value                  size             type           name            isArr       arrE        isStruct      structLayout      offset
    t.cont = rv.name

    return t
}

parseFnCall(l []Tok, ltp lineType, elems Elems*) []Tok {

    nl = []Tok

    found = false
    i=0; for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_VAR {
            i =i + 1
            if i < len(l) {
                t = l[i]
                if t.cont == "(" {
                    found = true
                    break
                }
            }
        }
        i =i + 1
    }

    if found == false {
        return l
    }

    i=0; for i < len(l) {
        ot = l[i]

        if ot.type == TOKEN_TYPE_VAR {
            i = i + 1
            if i < len(l) {
                nt = l[i]
                if nt.cont == "(" {
                    nbPar = 1
                    i = i + 1
                    fnName = ot.cont
                    fn = searchFunc(fnName, elems, true)
                    if fn == null {
                        throwErr(&ot, "Unknown function {TOKEN}.")
                    }
                    varName = string("")
                    fnStr = string(fnName)
                    arg1 variable*
                    if hasStructSep(fnStr) {
                        arg1 = fn.args[0]
                        fnarg1t = getCType(arg1.type, elems)
                        varName = fnStr
                        realFn = splitStructSepAfter(fnStr)
                        varName.trimRight(realFn.length)
                        c = varName.charAt(varName.length - 1)
                        if c == '.' {
                            varName.trimRight(1)
                        } else {
                            varName.trimRight(2)
                        }
                        varNameStr = varName.str()
                        v = searchVar(varNameStr, elems)
                        if v == null {
                            throwErr(&ot, "Cannot use {TOKEN} as a struct.")
                        }
                        if strCount(v.type, "*") == 0 {
                            varName.prepend("&")
                        }
                        varName.prepend("("+fnarg1t.str()+")")

                    }
                    ot.cont = fnName+"("
                    paramIndex = 0
                    memory = []Tok
                    if varName.length > 0 {
                        tk = Tok{}
                        tk.cont = varName.str()
                        tk.bahType = arg1.type
                        tk.type = TOKEN_TYPE_VAR
                        tk.isValue = true
                        memory[len(memory)] = tk

                        nt = l[i]
                        if nt.cont != ")" {
                        tk = Tok{}
                        tk.cont = ","
                        tk.type = TOKEN_TYPE_SYNTAX
                        tk.isValue = false
                        memory[len(memory)] = tk
                        }
                    }
                    for i < len(l) {
                        t = l[i]
                        if t.cont == "(" {
                            nbPar = nbPar + 1
                        } else if t.cont == ")" {
                            nbPar = nbPar - 1
                        }
                        memory[len(memory)] = t
                        if nbPar == 0 {
                            i = i + 1
                            break
                        }
                        i = i + 1    
                    }

                    if fnName == "noCheck" {
                        j=0; for j < len(memory) {
                            t = memory[j]
                            ot.cont = ot.cont + " " + t.cont
                            j =j + 1
                        }
                        ot.cont = ot.cont
                        ot.type = TOKEN_TYPE_FUNC
                        ot.isFunc = true
                        ot.bahType = "ptr"
                        nl[len(nl)] = ot
                        continue
                    }

                    if fnName == "panic" {
                        currLine = "\""+compilerState.currentFile + ":" + intToStr(ot.line)+"\""
                        par = memory[len(memory)-1]
                        cl = par.line
                        memory[len(memory)-1] = Tok{
                            type: TOKEN_TYPE_SYNTAX
                            cont: ","
                            line: cl
                        }
                        memory[len(memory)] = Tok{
                            type: TOKEN_TYPE_STR
                            cont: currLine
                            line: cl
                        }
                        memory[len(memory)] = par
                        fnName = "__BAH_panic"
                        ot.cont = fnName+"("
                        fn = searchFunc(fnName, elems, true)
                    }

                    memory = prePross(memory, ltp, elems)

                    ft = memory[0]
                    //for verboseOutput
                    fnArgs = []Tok

                    if ft.cont != ")" {

                        j=0;for j < len(memory) {
                            t = memory[j]
                            
                            if paramIndex >= len(fn.args) {
                                throwErr(&t, "Too many arguments in function call.")
                            }
                            arg = fn.args[paramIndex]
                            tt = getTypeFromToken(&t, true, elems)
                            //Used for runtime reflection (in reflect.bah)
                            if arg.type == "reflectElement" && tt != "reflectElement" {
                                t = parseReflect(t, tt, elems, false, t.cont, "0")
                                tt = "reflectElement"
                            }
                            
                            if compTypes(tt, arg.type) == false {
                                throwErr(&t, "Cannot use {TOKEN} (" + tt + ") as " + arg.type + " in function call.")
                            }

                            if t.type == TOKEN_TYPE_FUNC && strHasPrefix(t.cont, "noCheck(") == false {
                                afnName = splitStringBefore(string(t.cont), "(")
                                afn = searchFunc(afnName, elems, true)
                                if afn != null && isRCPtype(afn.returns.type, elems) == true {
                                    t.cont = registerRCPvar(afn.returns.type, t.cont, elems)
                                }
                            }

                            if verboseRuntime == true {
                                fnArgs[len(fnArgs)] = t
                            }

                            ot.cont = ot.cont + t.cont
                            j = j + 1
                            t = memory[j]
                            if t.cont != "," {
                                if t.cont == ")" {
                                    j = j + 1
                                    paramIndex = paramIndex + 1
                                    break
                                } else {
                                    throwErr(&t, "Expected separator between values, not {TOKEN} in function call.")
                                }
                            } else {
                                paramIndex = paramIndex + 1
                                ot.cont = ot.cont + ","
                            }

                            j = j + 1
                        }

                    }
                    
                    if paramIndex < len(fn.args) {
                        ot.cont = fnName
                        throwErr(&ot, "Not enough arguments in function call, ending by {TOKEN}.")
                    }
                    if fn.name == "ser" {
                        ot.cont = parseSerialize(memory[0], elems)
                    } else {
                        ot.cont = ot.cont + ")"
                    }
                    ot.type = TOKEN_TYPE_FUNC
                    ot.bahType = fn.returns.type
                    ot.isFunc = true
                    nl[len(nl)] = ot

                    ft = l[0]
                    if verboseRuntime == true && ltp != LINE_TYPE_ELSE {
                        verboseOutFunc(fn, fnArgs, ft.line, elems)
                    }

                    continue
                }
            }
            i =i - 1
        }

        nl[len(nl)] = ot
        i =i + 1
    }


    return nl
}

parseArrayDecl(v variable*, l []Tok, i int, max int, elems Elems*) cpstring {
    arrayLength = 0
    arrType = getCType(v.type, elems)
    arrType.trimRight(1)
    code = "memoryAlloc(sizeof("+arrType.str()+"))"
    arrType.trimLeft(6)
    arrType.trimRight(1)
    elemTypeStr = arrType.str()

    if i + 1 != max {
        i =i + 1
        nt = l[i]
        if nt.cont != "{" {
            throwErr(&l[i+1], "{TOKEN} not expected after array initialization.")
        }
        elemBahType = string(v.type)
        elemBahType.trimLeft(2)
        elemBahTypeStr = elemBahType.str()
        i = i + 1
        memory = []Tok
        for i < max {
            memory[len(memory)] = l[i]
            i = i + 1
        }
        memory = prePross(memory, <lineType>-1, elems)
        i=0; for i < len(memory) {
            t = memory[i]
            if t.cont == "{" {

                j=i-1
                nbBraces = 0
                for i < len(memory), i++ {
                    tmpT = memory[i]
                    if tmpT.cont == "{" {
                        nbBraces++
                    } else if tmpT.cont == "}" {
                        nbBraces--
                    }
                    if nbBraces == 0 {
                        break
                    }
                }
                tmpV = new variable
                tmpV.name = genCompilerVar()
                elemType = string(v.type)
                elemType.trimLeft(2)
                tmpV.type = elemType.str()
                elems.vars[len(elems.vars)] = tmpV

                oldNL = NEXT_LINE
                NEXT_LINE = ""
                innerCode = parseArrayDecl(tmpV, memory, j, i+1, elems)
                cType = getCType(elemType.str(), elems)
                OUTPUT = OUTPUT + rope("
                array("+cType.str()+") * "+tmpV.name+" = "+innerCode+";
                "+NEXT_LINE+"
                ")
                NEXT_LINE = oldNL
                
                t = Tok{
                    type: TOKEN_TYPE_VAR
                    cont: tmpV.name
                    bahType: elemType.str()
                    isValue: true
                }

            }
            tt = getTypeFromToken(&t, true, elems)
            if compTypes(tt, elemBahTypeStr) == false {
                throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+elemBahTypeStr)
            }
            
            strArrayLength = intToStr(arrayLength)
            arrayLength =arrayLength + 1

            if tt == "cpstring" {
                t.cont = "__STR("+t.cont+")"
            }

            NEXT_LINE = NEXT_LINE + v.name + "->data[" + strArrayLength + "] = " + t.cont + ";\n"
            i++
            t = memory[i]

            if t.cont != "," {
                if t.cont == "}" {
                    allocLength = arrayLength
                    if allocLength > 50 {
                        modAllocAmm = allocLength % 50
                        allocLength = allocLength + modAllocAmm
                    } else {
                        allocLength = 50
                    }
                    allocLengthStr = intToStr(allocLength)
                    NEXT_LINE = v.name + "->data = memoryAlloc(sizeof(" + elemTypeStr + ") * " + allocLengthStr + ");" + NEXT_LINE
                    break
                } else {
                    throwErr(&t, "Expected ',' got {TOKEN}.")
                }
            }
            i = i + 1
        }
    }
    strArrayLength = intToStr(arrayLength)
    NEXT_LINE = "
" + v.name + "->length = " + strArrayLength + ";
" + v.name + "->elemSize = sizeof(" + elemTypeStr + ");
" + NEXT_LINE
    return code
}

parseVar(l []Tok, elems Elems*) {
    ft = l[0]
    if ft.isFunc == true {
        if len(l) > 1 {
            throwErr(&l[len(l)-1], "Not expecting {TOKEN} after function call.")
        }
        ft = l[0]
        parsed = true
        OUTPUT = OUTPUT + rope(ft.cont + ";\n")
        return
    }
    l = parseStructType(l, elems)
    isEqual = false
    toVar = false
    isPointedVar = false
    isStruct = false
    currentType = ""
    ft = l[0]
    v = searchVar(ft.cont, elems)
    exists = true
    ogName cpstring
    if v == null {
        exists = false
        v = new variable
        v.name = ft.cont
        v.type = ""
    } else {
        ogName = v.name
    }
    if v.isConst == true {
        throwErr(&ft, "Cannot set the value of const {TOKEN}.")
    }
    code = ""

    if exists == true && isGlobal() {
        throwErr(&ft, "Cannot redeclare global variable {TOKEN}.")
    }

    if len(l) == 2 {
        lt = l[1]
        if lt.type == TOKEN_TYPE_SYNTAX && lt.cont == "++" || lt.cont == "--" {
            if exists == false {
                throwErr(&ft, "Cannot use '"+lt.cont+"' on non declared {TOKEN} variable.")
            }
            nl = []Tok
            nl[0] = l[0]

            nl[1] = Tok{
                type: TOKEN_TYPE_SYNTAX
                cont: "="
                isValue: false
            }
            
            c = ""
            if lt.cont == "++" {
                c = ft.cont+"+1"
            } else if lt.cont == "--" {
                c = ft.cont+"-1"
            }
            
            ltl = lt.line
            ltp = lt.pos
            ltc = lt.cont

            nl[2] = Tok{
                type: TOKEN_TYPE_INT
                cont: c
                line: ltl
                ogCont: ltc
                pos: ltp
                isOper: true
                isValue: true
            }
            l = nl
        }
    }

    i=1; for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_SYNTAX {
            if t.cont == "=" {
                if strlen(currentType) > 0 {
                    sct = string(currentType)
                    sct.replace(" ", "")
                    v.type = sct.str()
                }
                isEqual = true
                i = i + 1
                continue
            }
        }
        if isEqual == false {
            currentType = currentType + " " + t.cont
        } else {
            if t.cont == "new" {
                isStruct = true
                max = i + 1
                if max >= len(l) {
                    throwErr(&t, "Cannot initiate {TOKEN} struct without specifying struct name.")
                }
                max = max + 1
                if max < len(l) {
                    t = l[i+2]
                    throwErr(&t, "{TOKEN} not expected after initiating new struct.")
                }
                t = l[i+1]
                if t.type != TOKEN_TYPE_VAR {
                    throwErr(&t, "Cannot use {TOKEN} as a struct name.")
                }
                s = searchStruct(t.cont, elems)
                if s == null {
                    throwErr(&t, "Unknown struct {TOKEN}.")
                }
                vect = getCType(s.name, elems)
                vectStr = vect.content
                code = "memoryAlloc(sizeof("+vectStr+"))"
                v.type = s.name + "*"
                NEXT_LINE = declareStructMethods(v, s, elems)
                break
            } else if t.cont == "chan" {
                if i >= len(l) {
                    throwErr(&t, "Cannot declare a {TOKEN} without a type (chan <type>).")
                }
                i++
                nt = l[i]
                v.type = "chan:" + nt.cont
                code = "channel()"
                if i+1 != len(l) {
                    errT = l[i+1]
                    throwErr(&errT, "{TOKEN} not expected after channel declaration.")
                }
                break

            }
            if t.isValue == false {
                throwErr(&t, "Cannot use {TOKEN} as value in var declaration.")
            }
            tp = getTypeFromToken(&t, true, elems)
            if exists == true {
                if compTypes(tp, v.type) == false {
                    throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                }
            } else {
                if strlen(currentType) == 0 {
                    if strlen(v.type) == 0 {
                        v.type = tp
                    } else {
                        if compTypes(tp, v.type) == false {
                            throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                        }
                    }
                }
            }
            if strlen(t.cont) > 0 && strHasPrefix(t.cont, "{") == false {
                code = code + " " + t.cont
                if t.isOper == false && RCPavailable() == true  {
                    iv = searchVar(t.cont, elems)
                    if iv != null && iv.isConst == false {
                        toVar = true
                        isPointedVar = strHasPrefix(t.cont, "&")
                        s = searchStruct(iv.type, elems)
                        if s != null && strCount(iv.type, "*") == 0 && s.isBinding == false {
                            if strCount(iv.name, "*") == 0 {
                                code = code + "; RCP_incrCounter("+iv.name+".__RCP_counter)"
                            } else {
                                ivn = string(iv.name)
                                ivn.replace("*", "")
                                code = code + "; RCP_incr("+ivn.str()+")"
                            }
                        }
                    }
                }
                break
            }


            if strHasPrefix(v.type, "[]") {
                code = parseArrayDecl(v, l, i, len(l), elems)
                break
            }
            isStruct = true
            max = i + 1
            if max != len(l) {
                throwErr(&l[i+1], "{TOKEN} not expected after struct initialization.")
            }
            // s = searchStruct(v.type, elems)
            // NEXT_LINE = declareStructMethods(v, s, elems)
            code = code + " " + t.cont
        }

        i =i + 1
    }

    if exists == true {
        // oCode = code
        if strlen(code) == 0 {
            throwErr(&ft, "Cannot re-declare {TOKEN}.")
        }
        if strlen(currentType) > 0 {
            st = l[1]
            throwErr(&st, "Cannot change the type of already declared var '"+ft.cont+"' to {TOKEN}.")
        }
        if isStruct == false {
            if isRCPpointerType(v.type) && isPointedVar == false && RCPavailable() == true {
                cType = getCType(v.type, elems)
                if toVar == true {
                    if RCPselfRef(v) == false {
                        code = "*("+cType.str()+"*)RCP_decrIL(&"+v.name+") = *("+cType.str()+"*)RCP_incrIL(&"+code+")"
                    } else {
                        tmpV = new variable
                        tmpV.name = genCompilerVar()
                        tmpV.type = v.type
                        dv = decrVar(tmpV, elems)
                        code = cType.str()+" "+tmpV.name+" = "+v.name+"; "+v.name+" = *("+cType.str()+"*)RCP_incrIL(&"+code+");"+dv.toStr()
                    }
                } else {
                    tmpV = new variable
                    tmpV.name = genCompilerVar()
                    tmpV.type = v.type
                    dv = decrVar(tmpV, elems)
                    code = cType.str()+" "+tmpV.name+" = "+v.name+"; "+v.name+" = "+code+";"+dv.toStr()
                }
            } else {
                s = searchStruct(v.type, elems)
                if s != null && RCPavailable() == true && RCPselfRef(v) == false && s.isBinding == false  && strCount(v.name, "*") == 0 {
                        code = "RCP_decrCounter("+v.name+".__RCP_counter); " + v.name + " = " + code
                } else {
                    code = v.name + " = " + code
                }
            }
        } else {
            strTrim(&code)
            if strHasPrefix(code, "{") == false {
                code = v.name + " = " + code
            }
        }
        if v.isArray == true {
            nLength = string(v.name)
            n = string(v.name)
            i=0; for i < nLength.length {
                c = nLength.charAt(i)
                if c == '[' {
                    break
                }
                i =i + 1
            }
            nLength.trimLeft(i+1)
            nLength.trimRight(1)
            nLengthStr = nLength.str()

            i=n.length; for i > 0 {
                c = n.charAt(i)
                if c == '[' {
                    break
                }
                i =i - 1
            }
            tamm = n.length - i
            
            n.trimRight(tamm + 6)
            nstr = n.str()
            elemType = getCType(v.type, elems)
            elemTypeStr = elemType.str()

            code = "
{
long nLength = " + nLengthStr + ";
if (" + nstr + "->length < nLength+1) {
if ((nLength+1) % 50 == 0 || nLength == 0) {
void * newPtr = memoryRealloc("+nstr+"->data, (nLength+50)*sizeof("+elemTypeStr+"));
"+nstr+"->data = newPtr;
}
"+code+";
"+nstr+"->length = nLength+1;
} else {
"+code+";
}
}"

        }
    } else {
        if strlen(currentType) > 0 {
            v.type = currentType
        }

        vts = string(v.type)
        vts.replace(" ", "")
        v.type = vts.content
        if strlen(v.type) == 0 {
            throwErr(&ft, "Cannot declare {TOKEN} without a type.")
        }
        vct cpstring
        if vts.hasPrefix("function(") {
            tmpfn = parseFnType(vts)
            tmpfnRetCType = getCType(tmpfn.returns.type, elems)

            tmpfnArgsCType = ""
            j=0; for j < len(tmpfn.args) {
                arg = tmpfn.args[j]
                ct = getCType(arg.type, elems)
                tmpfnArgsCType = tmpfnArgsCType + ct.str()
                j = j + 1
                if j < len(tmpfn.args) {
                    tmpfnArgsCType = tmpfnArgsCType + ","
                }
            }

            vct = tmpfnRetCType.str() + " (*"+v.name+")("+tmpfnArgsCType+")"
        } else {
            vct = setCType(v, elems)
        }
        if strlen(code) > 0 {
            if isRCPpointerType(v.type) && RCPavailable() == true && toVar == true  && isPointedVar == false {
                cType = getCType(v.type, elems)
                if isGlobal() {
                    INIT = INIT + rope(v.name + " = *("+cType.str()+"*)RCP_incrIL(&"+code+");\n")
                } else {
                    code = vct+" = *("+cType.str()+"*)RCP_incrIL(&"+code+")"
                }
            } else {
                if isGlobal() {
                    INIT = INIT + rope(v.name + " = " + code+";\n")
                } else {
                    code = vct + " = " + code
                }
            }
        } else {
            if isRCPpointerType(v.type) {
                code = vct + "= null"
            } else {
                code = vct
            }
        }
        vars = elems.vars
        vars[len(vars)] = v

        debugPrint("var_declaration", ft.line, v)

        if isGlobal() {
            OUTPUT = OUTPUT + rope(vct+";\n")
        }

    }

    if isGlobal() {
        INIT = INIT + rope(NEXT_LINE)
        NEXT_LINE = ""
    } else {
        OUTPUT = OUTPUT + rope(code + ";\n")
    }


}

getCfunctionType(cfrt string, elemName cpstring, elems Elems*) cpstring {

    tmpfn = parseFnType(cfrt)
    tmpfnRetCType = getCType(tmpfn.returns.type, elems)
    tmpfnArgsCType = ""
    j=0; for j < len(tmpfn.args) {
        arg = tmpfn.args[j]
        ct = getCType(arg.type, elems)
        tmpfnArgsCType = tmpfnArgsCType + ct.str()
        j = j + 1
        if j < len(tmpfn.args) {
            tmpfnArgsCType = tmpfnArgsCType + ","
        }
    }

    return tmpfnRetCType.str() + " (*"+elemName+")("+tmpfnArgsCType+")"
}


parseFnHeader(prev cpstring, l []Tok, i int*, fn func*, elems Elems*) cpstring {

    j = *i
    ft = l[j]
    tpdf = ""
    if ft.type != TOKEN_TYPE_VAR {
        throwErr(&ft, "Cannot use {TOKEN} as function name.")
    }
    fn.name = prev + ft.cont

    arguments = []variable*

    code = fn.name + "("


    j = j + 2
    
    t = l[j]
    if t.cont != ")" {

        for j < len(l) {
            t = l[j]
            if t.type != TOKEN_TYPE_VAR {
                throwErr(&t, "Cannot use {TOKEN} as argument name.")
            }
            argName = t.cont

            j =j + 1
            if j >= len(l) {
                throwErr(&t, "Cannot declare argument {TOKEN} without a type.")
            }
            t = l[j]
            argType = t.cont

            j =j + 1
            isComa = false
            nbPars = 1
            for j < len(l) {
                t = l[j]
                isComa = false
                if t.cont != "," {
                    if t.cont == "(" {
                        nbPars = nbPars + 1
                    } else if t.cont == ")" {
                        nbPars = nbPars - 1
                    }
                    if t.cont == ")" && nbPars == 0 {
                        break
                    } else {
                        argType = argType + t.cont
                    }
                } else {
                    isComa = true
                    break
                }                
                j =j + 1
            }

            argument = new variable
            argument.name = argName
            argument.type = argType
            arguments[len(arguments)] = argument
            

            argCType = getCType(argType, elems)

            cfrt = string(argType)
            newArgType = argCType.str()
            if cfrt.hasPrefix("[]") == 1 {
                cfrt.trimLeft(2)
                if cfrt.hasSuffix("*") {
                    nbast = cfrt.count("*")
                    cfrt.trimRight(nbast)
                }
                newArgType = "__BAH_ARR_TYPE_" + cfrt.str()
                csatd = compilerState.arrTypesDecl
                if inArrayStr(newArgType, csatd) == false {
                    csatd[len(csatd)] = newArgType
                    tpdf = tpdf + "typedef " + argCType.str() + " " + newArgType + ";\n"
                }
            }
            if cfrt.hasPrefix("function(") == 1 {
                code = code + getCfunctionType(cfrt, argName, elems)
            } else {
                code = code + newArgType + " " + argName
            }
            if isComa == true {
                code = code + ","
            } else {
                code = code + ")"
                break
            }
            j =j + 1
        }
    } else {
        code = code + ")"
    }

    j =j + 1

    returns = new variable
    returns.type = ""
    for j < len(l) {
        t = l[j]
        if t.cont == "{" {
            break
        }
        returns.type = returns.type + t.cont
        j =j + 1
    }
    if strlen(returns.type) {
        rts = string(returns.type)
        rts.replace(" ", "")
        returns.type = rts.content
    }
    *i = j
    returns.name = fn.name
    fn.returns = returns
    fn.args = arguments

    fnRetType = getCType(returns.type, elems)
    newFnRetType = fnRetType.str()

    cfrt = string(returns.type)
    if cfrt.hasPrefix("[]") == 1 {
        cfrt.trimLeft(2)
        if cfrt.hasSuffix("*") {
            nbast = cfrt.count("*")
            cfrt.trimRight(nbast)
        }
        newFnRetType = "__BAH_ARR_TYPE_" + cfrt.str()
        csatd = compilerState.arrTypesDecl
        if inArrayStr(newFnRetType, csatd) == false {
            csatd[len(csatd)] = newFnRetType
            tpdf = tpdf + "typedef " + fnRetType.str() + " " + newFnRetType + ";\n"
        }
    }
    code = tpdf + newFnRetType + " " + code



    return code
}

parseStruct(l []Tok, elems Elems*) {

    s = new cStruct
    structs = elems.structs
    structs[len(structs)] = s
    methds = s.methods
    if len(l) < 4 {
        throwErr(&l[len(l)-1], "Cannot declare struct has such, please do 'struct <name> { <memberName>:<memberType> }'.")
    }
    nameToken = l[1]
    i = 2
    doesOutput = true
    if nameToken.cont == "!" {
        nameToken = l[2]
        i = 3
        doesOutput = false
        s.isBinding = true
    }
    if nameToken.type != TOKEN_TYPE_VAR {
        throwErr(&nameToken, "Cannot use {TOKEN} as struct name.")
    }
    os = searchStruct(nameToken.cont, elems)
    if os != null {
        throwErr(&nameToken, "Struct {TOKEN} already exists.")
    }
    s.name = nameToken.cont
    members = s.members
    currentCStruct = s
    allMembs = []cpstring
    st = l[i]
    if st.type == TOKEN_TYPE_KEYWORD {
        if st.cont == "extend" {
            i =i + 1
            extdSNameTk = l[i]
            i =i + 1
            if extdSNameTk.type != TOKEN_TYPE_VAR {
                throwErr(&extdSNameTk, "Cannot use {TOKEN} as struct name.")
            }
            extdS = searchStruct(extdSNameTk.cont, elems)
            s.extendedFrom = extdS.name
            if extdS == null {
                throwErr(&extdSNameTk, "Struct {TOKEN} does not exist.")
            }
            extdsmbs = extdS.members
            j=0; for j < len(extdsmbs) {
                em = extdsmbs[j]
                cemt = string(em.type)
                membDeclStr cpstring
                if cemt.hasPrefix("function(") == 1 {
                    tmpfn = parseFnType(cemt)
                    tmpfnRetCType = getCType(tmpfn.returns.type, elems)
                    tmpfnArgsCType = ""
                    j=0; for j < len(tmpfn.args) {
                        arg = tmpfn.args[j]
                        ct = getCType(arg.type, elems)
                        tmpfnArgsCType = tmpfnArgsCType + ct.str()
                        j = j + 1
                        if j < len(tmpfn.args) {
                            tmpfnArgsCType = tmpfnArgsCType + ","
                        }
                    }
                    membDeclStr = tmpfnRetCType.str() + " (*"+em.name+")("+tmpfnArgsCType+")"
                } else {
                    if isRCPpointerType(em.type) {
                        s.hasRCPmemb = true
                    }
                    membDecl = getCType(em.type, elems)
                    membDecl.append(" ")
                    membDecl.append(em.name)
                    membDeclStr = membDecl.content
                }
                allMembs[len(allMembs)] = membDeclStr
                members[len(members)] = em
                j = j + 1
            }
            k=0; for k < len(extdS.methods) {
                emt = extdS.methods[k]

                mthdDecl = getCType(emt.returns.type, elems)
                mthdDecl.append("(*" + emt.name + ")(")
                j=0; for j < len(emt.args) {
                    a = emt.args[j]
                    tp = getCType(a.type, elems)
                    tp.append(" " + a.name)
                    max = len(emt.args) - 1
                    if j != max {
                        tp.append(",")
                    }
                    mthdDecl.append(tp.str())
                    j =j + 1
                }
                mthdDecl.append(")")
                allMembs[len(allMembs)] = mthdDecl.str()

                k = k + 1
            }
        } else {
            throwErr(&st, "Cannot use keyword {TOKEN} in struct declaration.")
        }
    }
    braceTk = l[i]
    i =i + 1
    if braceTk.cont != "{" {
        throwErr(&braceTk, "Cannot use {TOKEN} in struct declaration.")
    }
    OOUT = OUTPUT
    nextLine = ""
    for i < len(l) {
        t = l[i]
        max = i + 2
        if max >= len(l) {
            if t.type == TOKEN_TYPE_ENCL && t.cont == "}" {
                break
            }
            throwErr(&l[len(l)-1], "Not enough argument in member declaration, ending by {TOKEN}.")
        }
        memb = new structMemb
        if t.type != TOKEN_TYPE_VAR {
            throwErr(&t, "Cannot use {TOKEN} as member name.")
        }
        memb.name = t.cont
        ii=0; for ii < len(members) {
            m = members[ii]
            if m.name == memb.name {
                throwErr(&t, "Member {TOKEN} has already been declared.")
            }
            ii =ii + 1
        }
        i =i + 1
        t = l[i]
        if t.cont != ":" {
            if t.cont != "(" {
                throwErr(&t, "Member name should be followed by ':' not {TOKEN}.")
            } else {
                fnPrefix = s.name + "__"
                fn = new func
                nl = []Tok
                j=i-1; for j < len(l) {
                    t = l[j]
                    if t.cont == "{" {
                        break
                    }
                    nl[len(nl)] = t
                    if j == i {
                        t.type = TOKEN_TYPE_VAR
                        t.cont = "this"
                        t.isValue = true
                        nl[len(nl)] = t

                        t.type = TOKEN_TYPE_VAR
                        t.cont = s.name+"*"
                        t.isValue = true
                        nl[len(nl)] = t

                        nt = l[j+1]
                        if nt.cont != ")" {
                            t.type = TOKEN_TYPE_SYNTAX
                            t.cont = ","
                            t.isValue = false
                            nl[len(nl)] = t
                        }
                    }
                    j =j + 1
                }
                i =i - 1

                nli = 0

                code = rope(parseFnHeader(fnPrefix, nl, &nli, fn, elems))
                i = i + nli
                i = i - 2

                returns = fn.returns
                arguments = fn.args
                fn.from = s.name
                code = code + rope("{\n")
                
                fnElems = dupElems(elems)
                j=0; for j < len(arguments) {
                    a = arguments[j]
                    a.outterScope = true
                    fnElems.vars[len(fnElems.vars)] = a
                    j =j + 1
                }

                fns = elems.fns
                fns[len(fns)] = fn

                tokens = []Tok
                nbBraces = 1
                t = l[i]
                if t.cont == "{" {
                    i =i + 1
                }
                for i < len(l) {
                    t = l[i]
                    if t.cont == "{" {
                        nbBraces =nbBraces + 1
                    } else if t.cont == "}" {
                        nbBraces =nbBraces - 1
                    }
                    if nbBraces == 0 {
                        break
                    }
                    tokens[len(tokens)] = t
                    i =i + 1
                }


                mfn = new func
                mfn.args = fn.args
                mfn.name = fn.name
                mfn.returns = fn.returns
                mfn.from = s.name

                strTrimLeft(&mfn.name, strlen(fnPrefix))

                methds[len(methds)] = mfn

                if len(tokens) == 0 {
                    code = code + rope("};\n")
                } else {
                    OUTPUT = rope("")
                    currentFn = fn
                    parseLines(tokens, fnElems)
                    currentFn = null
                    if fn.returned == false {
                        if strlen(fn.returns.type) > 0 {
                            throwErr(&l[len(l)-1], "Function '"+fn.name+"' is not returned.")
                        }
                        endRCPscope(fnElems, null)
                    }
                    code = code + OUTPUT + rope("};\n")
                }
                if doesOutput == true {
                    nextLine = nextLine + code.toStr()
                }

                mthdDecl = getCType(fn.returns.type, elems)
                mthdDecl.append("(*" + mfn.name + ")(")
                j=0; for j < len(arguments) {
                    a = arguments[j]
                    tp = getCType(a.type, elems)
                    tp.append(" "+a.name)
                    max = len(arguments) - 1
                    if j != max {
                        tp.append(",")
                    }
                    mthdDecl.append(tp.str())
                    j =j + 1
                }
                mthdDecl.append(")")
                allMembs[len(allMembs)] = mthdDecl.str()

                i =i + 1
                continue

            }
        }
        i =i + 1
        mbmType = ""
        currentLine = t.line
        for i < len(l) {
            t = l[i]
            if t.cont == "=" {
                i =i - 1
                break
            }
            if t.line != currentLine {
                i =i - 1
                break
            }
            mbmType = mbmType + t.cont
            i =i + 1
        }
        
        memb.type = mbmType
        i =i + 1
        t = l[i]
        if i < len(l) {
            if t.cont == "=" {
                i =i + 1
                t = l[i]
                if t.isValue == false {
                    throwErr(&t, "Cannot use {TOKEN} as default value for member.")
                }
                tt = getTypeFromToken(&t, true, elems)
                if compTypes(tt, memb.type) == false {
                    throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+memb.type+" for member.")
                }
                memb.def = t.cont

            } else {
                i =i - 1
            }
        }
        if isRCPpointerType(memb.type) {
            s.hasRCPmemb = true
        }
        members[len(members)] = memb
        membDeclStr cpstring
        cmt = string(memb.type)
        if cmt.hasPrefix("function(") == 1 {
            tmpfn = parseFnType(cmt)
            tmpfnRetCType = getCType(tmpfn.returns.type, elems)
            tmpfnArgsCType = ""
            j=0; for j < len(tmpfn.args) {
                arg = tmpfn.args[j]
                ct = getCType(arg.type, elems)
                tmpfnArgsCType = tmpfnArgsCType + ct.str()
                j = j + 1
                if j < len(tmpfn.args) {
                    tmpfnArgsCType = tmpfnArgsCType + ","
                }
            }
            membDeclStr = tmpfnRetCType.str() + " (*"+memb.name+")("+tmpfnArgsCType+")"
        } else {
            membDecl = getCType(memb.type, elems)
            membDecl.append(" " + memb.name)
            membDeclStr = membDecl.str()
        }
        allMembs[len(allMembs)] = membDeclStr
        i =i + 1
    }
    s.members = members
    if doesOutput == true {
        OUTPUT = OOUT
        NEXT_LINE = nextLine
        code = rope("struct "+s.name+" {\n")
        i=0; for i < len(allMembs) {
            m = allMembs[i]
            code = code + rope(m +";\n")
            i =i + 1
        }
        if RCPavailable() == true {
            code = code + rope("void * __RCP_counter;\n")
        }
        
        code = code + rope("};\n")
        OUTPUT = OUTPUT + code + makeRCPfuncFromStruct(s, elems)
    }

    if debug == true {

        ds = new debugStruct
        ds.name = s.name
        i=0; for i < len(s.members) {
            m = s.members[i]
            mv = new variable
            mv.name = m.name
            mv.type = m.type
            mv.isConst = false
            mv.isArray = m.isArray
            ds.membs[i] = mv
            i = i + 1
        }

        debugPrint("struct_declare", nameToken.line, ds)
    }


}

parseDefine(l []Tok, elems Elems*) {

    if len(l) < 3 {
        throwErr(&l[len(l)-1], "Invalid usage of define, cannot end on {TOKEN}.")
    }
    
    ft = l[1]
    st = l[2]

    i = 1
    doesOutput = true
    if ft.cont == "!" {
        ft = l[2]
        st = l[3]
        i = 2
        doesOutput = false
    }

    if st.cont == "(" {
        
        fn = new func
        code = parseFnHeader("", l, &i, fn, elems)
        fns = elems.fns
        fn.isBinding = true
        fns[len(fns)] = fn
        if doesOutput == true {
            OUTPUT = OUTPUT + rope(code+";\n")
        }

    } else {
        tp = ""
        i++; for i < len(l), i++ {
            t = l[i]
            tp = tp + t.cont
        }
        if ft.type != TOKEN_TYPE_VAR {
            throwErr(&ft, "Cannot use {TOKEN} as new type name.")
        }
        cTypeNewType = getCType(tp, elems)
        cTypeNewTypeStr = cTypeNewType.str()
        if doesOutput == true {
            OUTPUT = OUTPUT + rope("typedef " + cTypeNewTypeStr + " " + ft.cont + ";\n")
        }

        if debug == true {
            dt = new debugType
            dt.name = ft.cont
            dt.refers = tp
            debugPrint("type_declare", ft.line, dt)
        }

        tps = elems.types
        tps[len(tps)] = ft.cont
    }

}

parseClib(line []Tok) {

    clibs = compilerState.cLibs
    
    i=1; for i < len(line) {
        t = line[i]
        if t.type != TOKEN_TYPE_STR {
            throwErr(&t, "Cannot use {TOKEN} as C library name.")
        }

        cc = string(t.cont)
        cc.trimLeft(1)
        cc.trimRight(1)
        ccstr = cc.str()

        found = false
        j=0; for j < len(clibs) {
            l = clibs[j]
            if l == ccstr {
                found = true
                break               
            }
            j =j + 1
        }
        if found == true {
            i =i + 1
            continue
        }
        clibs[len(clibs)] = ccstr

        i =i + 1
    }

}

parseConst(l []Tok, elems Elems*) {
    l = parseCast(l, elems)
    if len(l) != 4 {
        throwErr(&l[0], "Invalid usage of {TOKEN}, must be 'const <constName> = <constValue>'. ")
    }
    vart = l[1]
    equt = l[2]
    valt = l[3]
    if vart.type != TOKEN_TYPE_VAR {
        throwErr(&vart, "Cannot take {TOKEN} as const name.")
    }
    if equt.cont != "=" {
        throwErr(&equt, "Expected '=' not {TOKEN}.")
    }
    if valt.isValue == false {
        throwErr(&equt, "Must be a value, not {TOKEN}.")
    }
    v = new variable
    v.isConst = true
    v.constVal = valt.cont
    v.name = vart.cont
    v.type = getTypeFromToken(&valt, true, elems)
    vars = elems.vars
    vars[len(vars)] = v

    OUTPUT = OUTPUT + rope("#define "+v.name+" "+valt.cont+"\n")

}

parseReturn(l []Tok, elems Elems*) {

    if len(l) > 2 {
        throwErr(&l[0], "Invalid usage of {TOKEN}, must be 'return <returnValue>'")
    }
    if currentFn == null {
        throwErr(&l[0], "Cannot return a value outside of a function.")
    }
    rv = ""

    if len(l) == 1 {
        if strlen(currentFn.returns.type) != 0 {
            throwErr(&l[0], "Cannot return nothing as "+currentFn.returns.type+".")
        }
    } else {
        rvt = l[1]
        if rvt.isValue == false {
            throwErr(&rvt, "Must be a value, not {TOKEN}.")
        } else if rvt.type == TOKEN_TYPE_VAR && rvt.isOper == false {
            v = searchVar(rvt.cont, elems)
            if v != null && isRCPtype(v.type, elems) == true && v.outterScope == false && RCPavailable() == true {
                OUTPUT = OUTPUT + incrVar(v, elems)
            }
        }
        rv = rvt.cont
        tt = getTypeFromToken(&rvt, true, elems)
        if compTypes(tt, currentFn.returns.type) == false {
            throwErr(&rvt, "Cannot return {TOKEN} ("+tt+") as "+currentFn.returns.type+".")
        }
    }
    if compilerState.isBranch == false {
        currentFn.returned = true
    }
    rvar = genCompilerVar()
    cType = getCType(currentFn.returns.type, elems)

    if strlen(rv) > 0 {
        OUTPUT = OUTPUT + rope(cType.str() + " " + rvar + " = "+rv+";\n")
        endRCPscope(elems, null)
        OUTPUT = OUTPUT + rope("return "+rvar+";\n")
    } else {
        endRCPscope(elems, null)
        OUTPUT = OUTPUT + rope("return;\n")
    }
}

parseIf(l []Tok, elems Elems*) {

    if len(l) < 4 {
        ft = l[0]
        throwErr(&ft, "Invalid usage of {TOKEN}, must be 'if <condition> {<code>}'")
    }
    condt = l[1]
    if condt.bahType != "bool" {
        if condt.bahType != "int" {
            throwErr(&condt, "Cannot use {TOKEN} as condition in if statement.")
        }
    }
    t = l[2]
    if t.cont != "{" {
        throwErr(&t, "Expected '{' not {TOKEN} after condtition in if statement.")
    }
    tokens = []Tok
    max = len(l) - 1
    i=3;for i < max {
        t = l[i]
        tokens[len(tokens)] = t
        i =i + 1
    }
    OUTPUT = OUTPUT + rope("if ("+condt.cont+") {\n")

    ifElems = dupElems(elems)

    oldIB = compilerState.isBranch
    compilerState.isBranch = true
    parseLines(tokens, ifElems)
    endRCPscope(ifElems, null)
    if debug == true {
        lt = l[len(l)-1]
        debugEndScope(lt.line, ifElems)
    }
    compilerState.isBranch = oldIB
    OUTPUT = OUTPUT + rope("}\n")


}

parseElse(l []Tok, elems Elems*) {

    if prevLine != LINE_TYPE_IF {
        if prevLine != LINE_TYPE_ELSE {
            throwErr(&l[0], "Can only use {TOKEN} after 'if' statement.")
        }
    }
    if len(l) < 3 {
        throwErr(&l[0], "Incalid usage of {TOKEN}, must be 'else {<code>}'.")
    }
    ft = l[1]
    OUTPUT = OUTPUT + rope("else ")
    if ft.cont == "if" {
        memory = []Tok
        i=1; for i < len(l) {
            memory[len(memory)] = l[i]
            i =i + 1
        }
        parseIf(memory, elems)
        prevLine = LINE_TYPE_IF

    } else {
        if ft.cont != "{" {
            throwErr(&ft, "Expected 'if' or '{' not {TOKEN}.")
        }
        memory = []Tok
        max = len(l) - 1
        i=2; for i < max {
            memory[len(memory)] = l[i]
            i =i + 1
        }
        OUTPUT = OUTPUT + rope("{\n")
        ifElems = dupElems(elems)

        oldIB = compilerState.isBranch
        compilerState.isBranch = true
        parseLines(memory, ifElems)
        endRCPscope(ifElems, null)
        if debug == true {
            lt = l[len(l)-1]
            debugEndScope(lt.line, ifElems)
        }
        compilerState.isBranch = oldIB
        OUTPUT = OUTPUT + rope("}\n")
    }

}

#define parseLine(l []Tok, elems Elems*)

parseFor(l []Tok, elems Elems*) {

    if len(l) < 4 {
        throwErr(&l[0], "Invalid usage of {TOKEN}.")
    }

    nbComas = 0
    i=1; for i < len(l) {
        t = l[i]
        if t.cont == "{" {
            break
        }
        if t.type == TOKEN_TYPE_SYNTAX && t.cont == "," {
            if nbComas == 1 {
                throwErr(&t, "Invalid line separation of for, cannot set more than 2 lines: {TOKEN}.")
            }
            nbComas = nbComas + 1
        }
        i = i + 1
    }

    tokens = []Tok
    if nbComas > 0 {
        if nbComas != 1 {
            t = l[0]
            throwErr(&t, "Invalid usage of {TOKEN}, can only partition line in 2 using 'for <condition>, <insctruction> {<code>}'.")
        }

        inst = []Tok
        condt = l[1]

        if condt.bahType != "bool" {
            if condt.bahType != "int" {
                throwErr(&condt, "Cannot use {TOKEN} as condition in for statement.")
            }
        }

        st = l[2]

        if st.type != TOKEN_TYPE_SYNTAX || st.cont != "," {
            throwErr(&st, "Cannot use {TOKEN}, need ',' to split for loop instructions.")
        }

        i=3; for i < len(l), i++ {
            t = l[i]
            if t.type == TOKEN_TYPE_ENCL && t.cont == "{" {
                break
            }
            inst[len(inst)] = t
        }

        oldOut = OUTPUT
        OUTPUT = rope("")

        parseLine(inst, elems)

        instC = string(OUTPUT.toStr())
        OUTPUT = oldOut
        instC.trimRight(2)

        t = l[i]
        if t.cont != "{" {
            throwErr(&t, "Expected '{' not {TOKEN} after '<condition>,<instruction>' in for statement.")
        }

        max = len(l) - 1
        i=i+1;for i < max, i++ {
            t = l[i]
            tokens[len(tokens)] = t
        }

        OUTPUT = OUTPUT + rope("for (; "+condt.cont+"; "+instC.str()+") {\n")

    } else {
        condt = l[1]
        if condt.bahType != "bool" {
            if condt.bahType != "int" {
                throwErr(&condt, "Cannot use {TOKEN} as condition in for statement.")
            }
        }
        t = l[2]
        if t.cont != "{" {
            throwErr(&t, "Expected '{' not {TOKEN} after condtition in for statement.")
        }
        max = len(l) - 1
        i=3;for i < max, i++ {
            t = l[i]
            tokens[len(tokens)] = t
        }
        OUTPUT = OUTPUT + rope("while ("+condt.cont+") {\n")
    }
    ifElems = dupElems(elems)

    oldIB = compilerState.isBranch
    oldIF = compilerState.isFor
    compilerState.isBranch = true
    compilerState.isFor = true
    parseLines(tokens, ifElems)
    endRCPscope(ifElems, null)
    if debug == true {
        lt = l[len(l)-1]
        debugEndScope(lt.line, ifElems)
    }
    compilerState.isFor = oldIF
    compilerState.isBranch = oldIB
    OUTPUT = OUTPUT + rope("};\n")

}

parseForOp(l []Tok, elems Elems*) {

    ft = l[0]
    if compilerState.isFor == false {
        throwErr(&ft, "Cannot {TOKEN} outside of for statement.")
    }
    if len(l) != 1 {
        throwErr(&ft, "Nothing expected after {TOKEN}.")
    }
    //TODO: include outter forloop declared variables incase the keyword is inside a if branch,etc...
    endRCPscope(elems, null)
    OUTPUT = OUTPUT + rope(ft.cont + ";\n")

}

parsePreKeyword(l []Tok, elems Elems*) {

    ft = l[0]

    if ft.cont == "#warning" {
        if len(l) != 2 {
            throwErr(&ft, "Invalid usage of {TOKEN} '#warning \"message\"'.")
        }
        mt = l[1]
        if mt.type != TOKEN_TYPE_STR {
            throwErr(&mt, "Cannot use {TOKEN} as a string.")
        }

        msg = string(mt.cont)
        msg.trimLeft(1)
        msg.trimRight(1)


        throwWarning(msg.str())
        return
    }
    
    if len(l) < 3 {
        throwErr(&ft, "Invalid usage of keyword {TOKEN}.")
    }
    
    if ft.cont == "#linux" || ft.cont == "#windows" || ft.cont == "#darwin" {
        isOS = string(ft.cont)
        isOS.trimLeft(1)
        if isOS.str() != BAH_OS {
            return
        }
    } else if ft.cont == "#static" {
        if flags.isSet("d") == 1 {
            return
        }
    } else if ft.cont == "#dynamic" {
        if flags.isSet("d") == 0 {
            return
        }
    } else if ft.cont == "#gc" {
        if RCPavailable() == true {
            return
        }
    } else if ft.cont == "#rcp" {
        if RCPavailable() == false {
            return
        }
    } else if ft.cont == "#lib" {
        if flags.isSet("l") == 0 {
            return
        }
    } else if ft.cont == "#exec" {
        if flags.isSet("l") == 1 {
            return
        }
    } else {
        throwErr(&ft, "Undefined token {TOKEN}.")
    }

    st = l[1]
    lt = l[len(l)-1]
    if st.cont != "{" || lt.cont != "}" {
        throwErr(&st, "Expected code block after keyword {TOKEN}.")
    }

    nl = []Tok
    i=2; for i < len(l) - 1 {
        nl[i-2] = l[i]
        i = i + 1
    }

    parseLines(nl, elems)

}

parseAsync(l []Tok, elems Elems*) {
    if len(l) != 2 {
        ft = l[0]
        throwErr(&ft, "Cannot use keyword {TOKEN} on a function call 'async <function call>'.")
    }
    fnT = l[1]
    if fnT.isFunc == false {
        throwErr(&fnT, "Cannot use keyword async on {TOKEN}. Usage: 'async <function call>'.")
    }
    
    found = false
    i=0; for i < len(compilerState.cLibs) {
        if compilerState.cLibs[i] == "lpthread" {
            found = true
            break
        }
        i = i + 1
    }
    if found == false {
        compilerState.cLibs[len(compilerState.cLibs)] = "lpthread"
    }

    sFnT = string(fnT.cont)
    
    fnNameParts = splitString(sFnT, "(")
    fnName = fnNameParts[0]

    fn = searchFunc(fnName.str(), elems, true)
    
    if fn == null {
        throwErr(&fnT, "Internal compiler error.\n Error in async parsing, arround {TOKEN}.")
    }
    sMembs = ""
    unSerMembs = ""
    
    i=0; for i < len(fn.args) {
        a = fn.args[i]
        cType = getCType(a.type, elems)
        sMembs = sMembs + cType.str()+" "+a.name+";\n"
        unSerMembs = unSerMembs + "args->"+a.name
        i = i + 1
        if i < len(fn.args) {
            unSerMembs = unSerMembs + ", "
        }
    }

    tmpArgsStruct = "struct {\n"+sMembs+"}"
    fnWrapper = genCompilerVar()
    tmpArgs = genCompilerVar()

    sFnT.trimLeft(fnName.length+1)
    sFnT.trimRight(1)

    tCreate = "pthread_create"
    if RCPavailable() == false {
        tCreate = "GC_pthread_create"
    }


    OUTPUT = OUTPUT + rope("
    void "+fnWrapper+"("+tmpArgsStruct+"* args) {
        "+fnName.str()+"("+unSerMembs+");
    };
    {
        "+tmpArgsStruct+" "+tmpArgs+" = {"+sFnT.str()+"};
        pthread_t id;
        "+tCreate+"(&id, 0, "+fnWrapper+", &"+tmpArgs+");
    }; 
    
    ")
}

addRCPvars(l []Tok, ltp lineType, elems Elems*) {
    i=0
    if ltp == LINE_TYPE_VAR {
        i = 1
    }
    for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_VAR {
            v = searchVar(t.cont, elems)
            if v != null {
                compilerState.RCPvars[len(compilerState.RCPvars)] = v
            }
        }
        i = i + 1
    }

}


parseChan(l []Tok, elems Elems*) []Tok {
    nl = []Tok
    i=0; for i < len(l), i++ {
        t = l[i]
        if t.type == TOKEN_TYPE_SYNTAX && t.cont == "->" || t.cont == "<-" {
            //receive
            if t.cont == "<-" {
                i++
                if i < len(l) {
                    nt = l[i]
                    if nt.type != TOKEN_TYPE_VAR {
                        throwErr(&nt, "Cannot use {TOKEN} as channel.")
                    }
                    ntt = string(getTypeFromToken(&nt, true, elems))
                    if ntt.hasPrefix("chan:") == 0 {
                        throwErr(&nt, "Cannot use var {TOKEN} ("+ntt.str()+") as channel.")
                    }
                    ntt.trimLeft(5)

                    if isGlobal() {
                        throwErr(&t, "Cannot receive ({TOKEN}) from a channel outside of a function.")
                    }

                    if isRCPpointerType(ntt.str()) {
                        ct = getCType(ntt.str(), elems)
                        t.cont = "("+ct.str()+")"+nt.cont+"->receive("+nt.cont+")"
                    } else {
                        ct = getCType(ntt.str(), elems)
                        t.cont = "*("+ct.str()+"*)"+nt.cont+"->receive("+nt.cont+")"
                    }
                    t.isFunc = true
                    t.type = TOKEN_TYPE_FUNC
                    t.isValue = true
                    t.bahType = ntt.str()
                } else {
                    throwErr(&t, "Cannot use {TOKEN} on nothing")
                }
            } else {
                if i == 0 {
                    throwErr(&t, "Cannot une {TOKEN} on nothing.")
                }
                if i+1 >= len(l) {
                    throwErr(&t, "Cannot send ({TOKEN}) to nothing.")
                }
                pt = l[i+1]
                nt = l[i-1]
                ntt = getTypeFromToken(&nt, true, elems)

                if pt.type != TOKEN_TYPE_VAR {
                    throwErr(&pt, "Cannot use {TOKEN} as channel.")
                }
                ptt = string(getTypeFromToken(&pt, true, elems))
                if ptt.hasPrefix("chan:") == 0 {
                    throwErr(&pt, "Cannot use var {TOKEN} ("+ntt+") as channel.")
                }
                ptt.trimLeft(5)

                if isGlobal() {
                    throwErr(&t, "Cannot send ({TOKEN}) to a channel outside of a function.")
                }

                if compTypes(ptt.str(), ntt) == false {
                    throwErr(&nt, "Cannot send {TOKEN} ("+ntt+") to channel of type "+ptt.str()+".")
                }

                i++
                if isRCPpointerType(ptt.str()) {
                    OUTPUT = OUTPUT + rope(pt.cont+"->send("+pt.cont+", "+nt.cont+");\n")
                } else {
                    ct = getCType(ntt, elems)
                    tmpV = genCompilerVar()
                    OUTPUT = OUTPUT + rope("
                    "+ct.str()+" "+tmpV+" = "+nt.cont+";
                    "+pt.cont+"->sendAny("+pt.cont+", &"+tmpV+", sizeof("+tmpV+"));\n")
                }

                nl = []Tok
                return nl
            }
        }
        nl[len(nl)] = t
    }
    return nl
}

prePross(line []Tok, ltp lineType, elems Elems*) []Tok {

    fl = []Tok
    i = 0
    nbPar = 0
    if ltp != <lineType>-1 {
        for i < len(line) {
            t = line[i]
            if t.cont == "(" {
                nbPar = nbPar + 1
            } else if t.cont == ")" {
                nbPar = nbPar - 1
            } else if nbPar == 0 && t.cont == "{" {
                nt = line[i+1]
                if nt.line != t.line {
                    break
                }
            }
            fl[len(fl)] = t
            i =i + 1
        }
    } else {
        fl = line
    }

    fl = parseStructVars(fl, elems)
    fl = parseFnCall(fl, ltp, elems)
    fl = parseArrayVars(fl, elems)
    fl = parseArrayType(fl, elems)
    fl = parseStructType(fl, elems)
    fl = parseCast(fl, elems)
    addRCPvars(fl, ltp, elems)
    fl = parseOperations(fl, ltp, elems)
    fl = parseBool(fl, elems)
    fl = parseChan(fl, elems)

    if ltp != <lineType>-1 {
        for i < len(line) {
            fl[len(fl)] = line[i]
            i =i + 1
        }
    }


    return fl
}

parseFnDeclare(l []Tok, elems Elems*) {
    i = 0
    fn = new func
    ft = l[0]
    code = parseFnHeader("", l, &i, fn, elems)
    fn.line = ft.line
    fn.file = compilerState.currentFile
    ogFn = searchFunc(fn.name, elems, false)
    if ogFn != null {
        if ogFn.isBinding == false {
            lineStr = intToStr(ogFn.line)
            throwErr(&ft, "Cannot redeclare function {TOKEN}, previous declaration: "+ogFn.file+":"+lineStr+".")
        }
    }

    if fn.name == "main" {
        compilerState.haveEntryPoint = true
        if compTypes(fn.returns.type, "int") == false {
            throwErr(&ft, "{TOKEN} function should return 'int'.")
        }
        if len(fn.args) != 1 {
            throwErr(&ft, "{TOKEN} function should take one []cpstring argument. Should be: 
            'main(args []cpstring) int'")
        }
        fa = fn.args[0]
        if compTypes(fa.type, "[]cpstring") == false {
            throwErr(&ft, "{TOKEN} function should take []cpstring as argument. Should be: 
            'main(args []cpstring) int'")
        }
    }

    code = code + "{\n"
    OUTPUT = OUTPUT + rope(code)

    fnElems = dupElems(elems)
    
    vs = fnElems.vars
    j=0; for j < len(fn.args) {
        a = fn.args[j]
        a.outterScope = true
        vs[len(vs)] = a
        j =j + 1
    }
    fnElems.vars = vs
    
    if ogFn != null {
        ogFn.isBinding = false
        ogFn = fn
    } else {
        fns = elems.fns
        fns[len(fns)] = fn
    }

    tokens = []Tok
    i =i + 1
    max = len(l)-1
    for i < max {
        t = l[i]
        tokens[len(tokens)] = t
        i =i + 1
    }

    if len(tokens) == 0 {
        OUTPUT = OUTPUT + rope("};\n")
        return
    }

    currentFn = fn
    parseLines(tokens, fnElems)

    currentFn = null
    if fn.returned == false {
        if strlen(fn.returns.type) > 0 {
            throwErr(&l[len(l)-1], "Function '"+fn.name+"' is not returned.")
        }
        endRCPscope(fnElems, null)
    }

    OUTPUT = OUTPUT + rope("};\n")

    if debug == true {
        df = new debugFunction
        df.name = fn.name
        df.args = fn.args
        df.returns = fn.returns.type
        debugPrint("fn_declare", ft.line, df)
        lt = l[len(l)-1]
        debugEndScope(lt.line, fnElems)
    }

}


//Handling lines

parseLine(line []Tok, elems Elems*) {

    if len(line) == 0 {
        return
    }
    line = parsePointers(line)
    ltp = getLineType(line)

    compilerState.RCPvars = []variable*
    
    
    parsed = false
    if ltp == LINE_TYPE_INCLUDE {
        parsed = true
        parseInclude(line, elems)
    } else if ltp == LINE_TYPE_DEFINE {
        parsed = true
        parseDefine(line, elems)
    } else if ltp == LINE_TYPE_CLIB {
        parsed = true
        parseClib(line)
    } else if ltp == LINE_TYPE_STRUCT {
        parsed = true
        parseStruct(line, elems)
    } else if ltp == LINE_TYPE_CONST {
        parsed = true
        parseConst(line, elems)
    } else if ltp == LINE_TYPE_MACRO {
        return
    } else if ltp != LINE_TYPE_FN_DECL {
        line = prePross(line, ltp, elems)
        if len(line) == 0 {
            return
        }
    }
    if ltp == LINE_TYPE_VAR {
        parsed = true
        parseVar(line, elems)
    } else if ltp == LINE_TYPE_FN_CALL {
        if len(line) > 1 {
            throwErr(&line[len(line)-1], "Not expecting {TOKEN} after function call.")
        }
        ft = line[0]
        parsed = true
        OUTPUT = OUTPUT + rope(ft.cont + ";\n")
    } else if ltp == LINE_TYPE_FN_DECL {
        parsed = true
        parseFnDeclare(line, elems)
    } else if ltp == LINE_TYPE_RETURN {
        parsed = true
        parseReturn(line, elems)
    } else if ltp == LINE_TYPE_IF {
        parsed = true
        parseIf(line, elems)
    } else if ltp == LINE_TYPE_ELSE {
        parsed = true
        parseElse(line, elems)
    } else if ltp == LINE_TYPE_FOR {
        parsed = true
        parseFor(line, elems)
    } else if ltp == LINE_TYPE_FOR_OPERATOR {
        parsed = true
        parseForOp(line, elems)
    } else if ltp == LINE_TYPE_PRE_KEYWORD {
        parsePreKeyword(line, elems)
        parsed = true
    } else if ltp == LINE_TYPE_ASYNC {
        parseAsync(line, elems)
        parsed = true
    }
    
    if parsed == false{
        ft = line[0]
        throwErr(&ft, "{TOKEN} not expected.")
    }

    if strlen(NEXT_LINE) > 0 {
        OUTPUT = OUTPUT + rope(NEXT_LINE)
        NEXT_LINE = ""
    }
    prevLine = ltp


}

parseLines(tokens []Tok, elems Elems*) {

    if len(tokens) == 0 {
        return
    }
    line = []Tok
    ft = tokens[0]
    currentLine = ft.line
    nbEncl = 0
    i=0; for i < len(tokens) {
        t = tokens[i]
        
        if t.type == TOKEN_TYPE_ENCL {
            if t.cont == "(" {
                nbEncl =nbEncl + 1
            } else if t.cont == ")" {
                nbEncl =nbEncl - 1
            } else if t.cont == "{" {
                nbEncl =nbEncl + 1
            } else if t.cont == "}" {
                nbEncl =nbEncl - 1
            } else if t.cont == "[" {
                nbEncl =nbEncl + 1
            } else if t.cont == "]" {
                nbEncl =nbEncl - 1
            }
        }

        if t.type == TOKEN_TYPE_STR && t.begLine == currentLine {
            currentLine = t.line
        }

        if nbEncl == 0 {
            if t.line != currentLine {
                if t.type == TOKEN_TYPE_ENCL {
                    line[len(line)] = t
                    pt = tokens[i-1]
                    currentLine = pt.line
                } else {
                    currentLine = t.line
                }
                parseLine(line, elems)
                clear(line)
                if t.type == TOKEN_TYPE_ENCL {
                    i =i + 1
                    continue
                }
            } else if t.cont == ";" {
                currentLine = t.line
                parseLine(line, elems)
                clear(line)
                i =i + 1
                continue
            }
        }

        line[len(line)] = t
        i =i + 1
    }

    if len(line) > 0 {
        if nbEncl == 0 {
                parseLine(line, elems)
                clear(line)
        } else {
            ft = line[len(line)-1]
            throwErr(&ft, "Missing closing token, line ending by {TOKEN}.")
        }
    }


}

