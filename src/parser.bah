#include "iostream.bah"
#include "string.bah"
#include "path.bah"

#include "./logger.bah"
#include "./lexer.bah"
#include "./var.bah"
#include "./mem.bah"
#include "./verboseOut.bah"
#include "./cache.bah"

//Only for debug purposes
debugLine(line []Tok) {
    cont = ""
    i=0; for i < len(line) {
        t = line[i]
        cont = cont + " '" + t.cont + "'"
        i++
    }
    println(cont)
}

//duplicates the elems for making an inner scope
dupElems(elems Elems*) Elems* {
    nElems = new Elems

    //vars
    j=0; for j < len(elems.vars), j++ {
        v = elems.vars[j]
        nv = new variable
        *nv = *v
        nv.outterScope = true
        nElems.vars[j] = nv
    }

    //structs
    nElems.structs = elems.structs

    //types
    nElems.types = elems.types

    //fns
    nElems.fns = elems.fns

    return nElems
}

#define lineType int

const LINE_TYPE_INCLUDE = <lineType>0
const LINE_TYPE_DEFINE = <lineType>1
const LINE_TYPE_CONST = <lineType>2
const LINE_TYPE_VAR = <lineType>3
const LINE_TYPE_FN_DECL = <lineType>4
const LINE_TYPE_FN_CALL = <lineType>5
const LINE_TYPE_STRUCT = <lineType>6
const LINE_TYPE_CLIB = <lineType>7
const LINE_TYPE_RETURN = <lineType>8
const LINE_TYPE_IF = <lineType>9
const LINE_TYPE_ELSE = <lineType>10
const LINE_TYPE_MACRO = <lineType>11
const LINE_TYPE_FOR = <lineType>12
const LINE_TYPE_FOR_OPERATOR = <lineType>13
const LINE_TYPE_PRE_KEYWORD = <lineType>14
const LINE_TYPE_ASYNC = <lineType>15
const LINE_TYPE_IMPORT = <lineType>16

prevLine = <lineType>-1

//returns a line type from its tokens
getLineType(line []Tok) lineType {

    ft = line[0]

    if ft.type == TOKEN_TYPE_FUNC {
        return LINE_TYPE_FN_CALL
    }
    if ft.type == TOKEN_TYPE_KEYWORD {
        if ft.cont == "#include" {
            return LINE_TYPE_INCLUDE
        } else if ft.cont == "#import" {
            return LINE_TYPE_IMPORT
        } else if ft.cont == "#define" {
            return LINE_TYPE_DEFINE
        } else if ft.cont == "const" {
            return LINE_TYPE_CONST
        } else if ft.cont == "struct" {
            return LINE_TYPE_STRUCT
        } else if ft.cont == "#cLib" {
            return LINE_TYPE_CLIB
        } else if ft.cont == "return" {
            return LINE_TYPE_RETURN
        } else if ft.cont == "if" {
            return LINE_TYPE_IF
        } else if ft.cont == "else" {
            return LINE_TYPE_ELSE
        } else if ft.cont == "#macro" {
            return LINE_TYPE_MACRO
        } else if ft.cont == "for" {
            return LINE_TYPE_FOR
        } else if ft.cont == "async" {
            return LINE_TYPE_ASYNC
        } else if ft.cont == "continue" || ft.cont == "break" {
            return LINE_TYPE_FOR_OPERATOR
        } else {
            return LINE_TYPE_PRE_KEYWORD
        }
    } else if ft.type == TOKEN_TYPE_VAR {
        if len(line) > 1 {
            st = line[1]
            if st.type == TOKEN_TYPE_ENCL && st.cont == "(" {
                lt = line[len(line)-1]
                if lt.type == TOKEN_TYPE_ENCL && lt.cont == "}"{
                    return LINE_TYPE_FN_DECL
                }
                return LINE_TYPE_FN_CALL
            }
        }

        return LINE_TYPE_VAR
    }

    return <lineType>-1
}


parseCast(line []Tok, elems Elems*, guard bool) []Tok {
//     recorder = timer.record("parseCast")

    nl = []Tok
    i=0
    if guard == true {
        for i < len(line) {
            t = line[i]
            if t.type == TOKEN_TYPE_CAST {
                break
            }
            nl[i] = t
            i = i + 1
        }
        if i == len(line) {
            return line //found no cast in the line, returns it
        }
    }

    for i < len(line), i++ {
        t = line[i]
        if t.type == TOKEN_TYPE_CAST {
            if i + 1 < len(line) { //to make sure we have enough remainning tokens, even a value to cast
                nnnt = line[i+1] //value token
                //type token is enclaved by < and >
                tc = string(t.cont)
                tc.trimLeft(1)
                tc.trimRight(1)
                nnnt.bahType = tc.str()
                cCast = getCType(tc.str(), elems) //converting from Bah type to C type
                cCastStr = cCast.str()
                nnnt.cont = "("+cCastStr+")"+nnnt.cont //C code for casting
                nl[len(nl)] = nnnt //adding the concatenated code to the new line
                i += 2
                continue
            }
        }

        nl[len(nl)] = t //adding token to the new line
    }

    return nl
}

getDirFromFile(f cpstring) cpstring {
    p = strAsArr(__STR(f))
    i = len(p)-1; for i >= 0 {
        c = p[i]
        if c == '/' {
            p[i+1] = <char>0
            break
        }
        i = i - 1
    }

    if i <= 0 {
        return ""
    }

    return arrAsStr(p)
}

#define parseLines(ts []Tok, elems Elems*)
includeFile(ccstr cpstring, elems Elems*) bool {

    //includes the correct memory manager file
    if ccstr == "BAH_MEM_COLLECTOR" {
        if RCPenabled == true {
            if flags.isSet("rcp") {
                ccstr = "rcp.bah"
            } else if flags.isSet("fastrcp") {
                ccstr = "fastrcp.bah"
            }
        } else {
            ccstr = "gc.bah"
        }
    }

    //include guard
    if ccstr in compilerState.includes {
        return true
    }

    //open file with Bah directory prefix
    fm = fileMap{}
    fileName = BAH_DIR + ccstr
    isBahDir = true
    f = fm.open(fileName)
    if fm.isValid() == 0 { //try with the current dir instead of Bah dir
        fileName = absPath(compilerState.currentDir + ccstr)
        f = fm.open(fileName)
        isBahDir = false
        if fm.isValid() == 0 {
            return false //file cannot be found
        }
    }

    //store the current directory
    oDir = compilerState.currentDir
    if isBahDir == false {
        compilerState.currentDir = compilerState.currentDir + getDirFromFile(ccstr)
    } else {
        compilerState.currentDir = BAH_DIR + getDirFromFile(ccstr)
    }

    //stores current file and adds it to the include guard
    oFile = compilerState.currentFile
    compilerState.currentFile = fileName
    compilerState.includes[len(compilerState.includes)] = ccstr
    
    //reads file
    tokens = lexer(f)
    fm.close()
    if len(tokens) == 0 {
        panic("File '"+ccstr+"' not recognized.")
    }

    //handle declarative parsing
    oshd = shouldOnlyDecl
    if isObject == true {
        shouldOnlyDecl = true
    } else if isSubObject == true {
        shouldOnlyDecl = false
    }

    parseLines(tokens, elems)

    //restore old file's parameters
    shouldOnlyDecl = oshd
    compilerState.currentFile = oFile 
    compilerState.currentDir = oDir

    return true
}

parallelObjCompile(fn cpstring, oName cpstring, done chan:bool) {
    readCache()
    cf = getCacheFile(fn)
    wrkd = getCurrentPath()

    rcp = ""
    if RCPlevel == 1 {
        rcp = "-rcp"
    } else if RCPlevel == 2 {
        rcp = "-fastrcp"
    }

    //file not found in cache, need to compile it
    if isValidCacheFile(cf) == false {
        setCurrentPath(compilerState.currentDir)
        verboseCC = ""
        if flags.isSet("verboseCC") == 1 {
            verboseCC = "-verboseCC"
        }
        print("compilling: "+fn+"... ")
        cmd = command(execName + " "+fn+" "+rcp+" -object "+verboseCC+" -o "+oName)
        res = cmd.run()
        println("ok")
        setCurrentPath(wrkd)
        if cmd.status != 0 {
            print(res)
            exit(1)
        }
        if cf == null {
            makeCacheFile(fn)
        } else {
            updateCacheFile(cf)
        }
    }
    true -> done
}

parseImport(l []Tok, elems Elems*) {
    compilerState.hasImports = true
    //basic usage check
    if len(l) != 2 {
        throwErr(&l[0], "Invalid usage of {TOKEN}.")
    }
    strt = l[1]
    if strt.type != TOKEN_TYPE_STR {
        throwErr(&strt, "Cannot use {TOKEN} as file name (#import \"file\")")
    }

    //removes quotes from file name
    fileName = string(strt.cont)
    fileName.trimLeft(1)
    fileName.trimRight(1)

    //include guard
    if fileName.str() in compilerState.includes {
        return
    }
    compilerState.includes[len(compilerState.includes)] = fileName.str()

    //locates file
    fn = absPath(fileName.str())
    if <ptr>fn == null {
        fn = absPath(BAH_DIR + fileName.str())
        if <ptr>fn == null {
            throwErr(&strt, "Unknown file {TOKEN}.")
        }
    }

    //set file parameters
    of = compilerState.currentFile
    od = compilerState.currentDir
    compilerState.currentFile = fn
    compilerState.currentDir = getDirFromFile(fn)

    //open file
    fs = fileStream{}
    fs.open(fn, "r")
    f = fs.readContent()
    fs.close()

    //read file
    tokens = lexer(f)
    
    //sets declarative parsing parameter
    osod = shouldOnlyDecl
    shouldOnlyDecl = true
    oiso = isSubObject
    isSubObject = true

    oName = BAH_DIR+"cache/"+pathToVarName(fn)+intToStr(RCPlevel)+".o"
    compilerState.cLibs[len(compilerState.cLibs)] = "w "+oName+".o" //adds object file to the linker
    
    done = chan bool

    //checks for cache
    // #linux {
    //     async parallelObjCompile(fn, oName, done)
    // }
    // #darwin {
    //     async parallelObjCompile(fn, oName, done)
    // }
    // #windows {
        parallelObjCompile(fn, oName, done)
    // }

    //parse file
    parseLines(tokens, elems)

    ok = <- done

    //adds its init function
    INIT += rope("__BAH_init"+pathToVarName(fn)+"();\n")

    writeCache() //saves cache

    //restore old file's parameters
    shouldOnlyDecl = osod
    isSubObject = oiso
    compilerState.currentFile = of
    compilerState.currentDir = od
}

parseInclude(l []Tok, elems Elems*) {
    //basic usage check
    if len(l) > 2 {
        throwErr(&l[len(l)-1], "Invalid usage of include, ending by {TOKEN}.")
    }
    strt = l[1]
    if strt.type != TOKEN_TYPE_STR {
        throwErr(&strt, "Cannot use {TOKEN} as string in include.")
    }

    //removes quotes from file name
    sc = strt.cont
    strTrimLeft(&sc, 1)
    strTrimRight(&sc, 1)
    if strHasPrefix(sc, "<") || strHasSuffix(sc, ".h") || strHasSuffix(sc, ".c") { // is a C file
        OUTPUT = OUTPUT + rope("#include "+sc+"\n")
        compilerState.cIncludes[len(compilerState.cIncludes)] = sc
    } else { //is a Bah file
        if includeFile(sc, elems) == false {
            throwErr(&strt, "Could not find file {TOKEN}.")
        }
    }
}

signs = []cpstring{"|", "&", "%", "+", "-", "*", "/", "<<", ">>"}


#define prePross(line []Tok, ltp lineType, elems Elems*) []Tok


parseStructType(line []Tok, ltp lineType, elems Elems*) []Tok {
//     recorder = timer.record("parseStructType")
    //vars declaration are handled separatly
    if ltp == LINE_TYPE_VAR {
        return line
    }

    nl = []Tok
    i=0; for i < len(line) {
        t = line[i]
        if t.type == TOKEN_TYPE_VAR {
            //cannot declare struct type for arrays, leaving it to the arrayType handler
            if strHasPrefix(t.bahType, "[]") {
                nl[len(nl)] = t
                i++
                continue
            }
            i++
            nt = Tok{
                cont: ""
            }
            if i < len(line) {
                nt = line[i]
            }
            if i == len(line) || nt.cont != "{" {
                if i-2 >= 0 {
                    newTk = line[i-2]
                    //checking if struct should be declared on the heap or stack
                    if newTk.cont == "new" {
                        s = searchStruct(t.cont, elems)
                        if s == null {
                            throwErr(&t, "Cannot initialize new unknown struct {TOKEN}.")
                        }
                        t.cont = genCompilerVar()
                        tmpV = new variable
                        tmpV.name = t.cont
                        tmpV.type = s.name + "*"
                        cType = getCType(tmpV.type, elems)
                        structType = getCType(s.name, elems)
                        elems.vars[len(elems.vars)] = tmpV

                        OUTPUT = OUTPUT + rope(cType.str()+" "+t.cont+" = memoryAlloc(sizeof("+structType.str()+"));\n"+declareStructMethods(tmpV, s, elems))

                        nl[len(nl)-1] = t
                        continue
                    }
                }
            }
            //declare members
            if i < len(line) {
                nt = line[i]
                if nt.cont == "{" {
                    isHeap = false
                    sep = "."
                    if i-2 >= 0 {
                        newTk = line[i-2]
                        if newTk.cont == "new" {
                            isHeap = true
                            sep = "->"
                        }
                    }
                    i++
                    s = searchStruct(t.cont, elems)
                    if s == null {
                        throwErr(&t, "Unknown struct name {TOKEN}.")
                    }
                    //store the code inside braces inside memory
                    memory = []Tok
                    nbBraces = 1
                    for i < len(line), i++ {
                        t = line[i]
                        if t.cont == "{" {
                            nbBraces++
                        } else if t.cont == "}" {
                            nbBraces--
                            if nbBraces == 0 {
                                break
                            }
                        }
                        memory[len(memory)] = t
                    }

                    //preprocess the memory
                    if len(memory) > 0 {
                        memory = prePross(memory, <lineType>-1, elems)
                    }


                    declType = 0 //list of members or members by name
                    //make temp var
                    rvn = genCompilerVar()
                    tmpV = new variable
                    tmpV.name = rvn
                    if isHeap == true {
                        tmpV.type = s.name+"*"
                        elems.vars[len(elems.vars)] = tmpV
                    } else {
                        tmpV.type = s.name
                    }
                    rst = getCType(tmpV.type, elems)
                    r rope*

                    //allocate memory
                    if isHeap == true {
                        structType = string(rst.str())
                        structType.trimRight(1)
                        r = rope(rst.str()+" "+rvn+" = memoryAlloc(sizeof("+structType.str()+"));\n"+declareStructMethods(tmpV, s, elems))
                    } else {
                        r = rope(rst.str()+" "+rvn+" = {};\n"+declareStructMethods(tmpV, s, elems))
                    }
                    j=0;k=0; for k < len(memory) {
                        t = memory[k]
                        //declaration 'member: value'
                        if k+2 < len(memory) {
                            st = memory[k+1]
                            vl = memory[k+2]
                            if st.cont == ":" {
                                if declType != 0 && declType != 1 {
                                    throwErr(&t, "Cannot declare member {TOKEN} by name in list declaration.")
                                }
                                declType = 1
                                if t.type != TOKEN_TYPE_VAR {
                                    throwErr(&t, "Cannot use {TOKEN} as struct member name.")
                                }
                                j=0; for j < len(s.members) {
                                    m = s.members[j]
                                    if m.name != t.cont {
                                        j = j + 1
                                        continue
                                    }
                                    vlt = getTypeFromToken(&vl, true, elems)
                                    if compTypes(vlt, m.type) == false {
                                        throwErr(&vl, "Cannot use {TOKEN} ("+vlt+") as '"+m.type+"'.")
                                    }
                                    r = r + rope(rvn+sep+m.name+" = "+vl.cont+";\n")
                                    break
                                }
                                if j == len(s.members) {
                                    throwErr(&t, "Struct '"+s.name+"' has no member called {TOKEN}.")
                                }
                                k = k + 3
                                continue
                            }
                        }
                        if declType != 0 && declType != 2 {
                            throwErr(&t, "Cannot declare member {TOKEN} without specifying its name.")
                        }
                        //declaration 'value, value...'
                        declType = 2
                        if j > len(s.members) {
                            throwErr(&t, "Too many members {TOKEN}.")
                        }
                        m = s.members[j]
                        j++

                        tt = getTypeFromToken(&t, true, elems)
                        if compTypes(tt, m.type) == false {
                            throwErr(&t, "Cannot use {TOKEN} ("+tt+") as '"+m.type+"'.")
                        }

                        r += rope(rvn+sep+m.name+" = "+t.cont+";\n")

                        if k+1 < len(memory) {
                            k++
                            st = memory[k]
                            if st.cont != "," {
                                throwErr(&st, "Need ',' separator between two values, not {TOKEN}.")
                            }
                        }
                        k++
                    }

                    //outputs C code
                    if isGlobal() {
                        INIT = INIT + r
                    } else {
                        OUTPUT = OUTPUT + r
                    }

                    //makes token with the temp variable
                    t.bahType = tmpV.type
                    t.cont = rvn
                    t.isValue = true
                    if isHeap == true {
                        nl[len(nl)-1] = t
                    } else {
                        t.isEqual = true
                        nl[len(nl)] = t
                    }
                    i++
                    continue
                    
                } else {
                    i--
                }
            }
        }
        nl[len(nl)] = t
        i++
    }

    return nl
}

parseArrayType(line []Tok, elems Elems*, guard bool) []Tok {
//     recorder = timer.record("parseArrayType")

    nl = []Tok
    i=0
    if guard == true {
        for i < len(line), i++ {
            t = line[i]
            if t.cont == "[" {
                break
            }
            nl[i] = t
        }
        if i == len(line) {
            return line
        }
    }

    for i < len(line), i++ {
        t = line[i]
        if t.cont == "[" {
            i++
            if i < len(line) {
                t = line[i]
                if t.cont == "]" {
                    i++
                    depth = 1
                    bracks = "[]"
                    for i < len(line) - 1, i++ {
                        t = line[i]
                        nt = line[i+1]
                        if t.cont == "[" && nt.cont == "]" {
                            depth++
                            bracks = bracks + "[]" 
                            i++
                        } else {
                            break
                        }
                    }
                    if i < len(line) {
                        t = line[i]
                        if t.type != TOKEN_TYPE_VAR {
                            throwErr(&t, "Cannot use {TOKEN} as array type.")
                        }
                        arrElem = t.cont
                        t.bahType = bracks+arrElem
                        t.cont = ""
                        t.isValue = true
                        nl[len(nl)] = t
                        continue
                    }
                }
            }
        }

        nl[len(nl)] = t
    }

    return nl
}

comparators = []cpstring{"==", "!=", ">", "<", "<=", ">=", "in"}
compSep = []cpstring{"||", "&&"}


parsePointers(l []Tok) []Tok {

    nl = []Tok

    ptrOpers = []cpstring{"&", "*"}

    i=0; for i < len(l) {
        t = l[i]

        if t.type == TOKEN_TYPE_SYNTAX {
            if t.cont == "*" {
                if i > 0 {
                    pt = nl[len(nl)-1]
                    if pt.type == TOKEN_TYPE_VAR {
                        if i + 1 < len(l) {
                            nt = l[i+1]
                            if nt.isValue == false {
                                pt.cont = pt.cont + t.cont
                                nl[len(nl)-1] = pt
                                i = i + 1
                                continue
                            }
                        } else {
                            pt.cont = pt.cont + t.cont
                            nl[len(nl)-1] = pt
                            i = i + 1
                            continue
                        }
                    }
                }
            }

            if inArrayStr(t.cont, ptrOpers) {
                if i > 0 {
                    pt = nl[len(nl)-1]
                    if pt.isValue == true {
                        nl[len(nl)] = t
                        i = i + 1
                        continue            
                    }
                }
                i = i + 1
                if i < len(l) {
                    nt = l[i]
                    if nt.type == TOKEN_TYPE_VAR {
                        nt.cont = t.cont + nt.cont
                        nl[len(nl)] = nt
                        i = i + 1
                        continue
                    }
                }
            }
        }

        nl[len(nl)] = t
        i = i + 1
    }


    return nl
}


parseSerialize(e Tok, elems Elems*) cpstring {


    v = searchVar(e.cont, elems)
    if v == null {
        throwErr(&e, "Must be a var, not {TOKEN}.")
    }

    s = searchStruct(v.type, elems)
    if s == null {
        throwErr(&e, "Must be a struct, not {TOKEN}.")
    }

    svt = string(v.type)
    ptrLevel = svt.count("*")
    
    svt.replace("*", "")

    code cpstring

    if ptrLevel == 0 {
        code = "__serialize(&" + e.cont + ", " + "sizeof(struct "+svt.str()+")"
    } else {
        ptrRect = ""
        for ptrLevel > 1 {
            ptrRect = ptrRect + "*"
            ptrLevel = ptrLevel - 1
        }
        code = "__serialize(" + ptrRect + e.cont + ", " + "sizeof(struct "+svt.str()+")"
        //is heap allocated, meanning we should calculate real size

        i=0; for i < len(s.members) {
            m = s.members[i]
            if m.type == "cpstring" {
                code = code + "+strlen("+e.cont+"->"+m.name+")"
            }
            i = i + 1
        }   

    }


    return code + ")"
}

parseReflect(t Tok, tt cpstring, elems Elems*, parsedPointer bool, ogName cpstring, offset cpstring) Tok {

    isArr = "0"

    if t.type != TOKEN_TYPE_VAR || t.type != TOKEN_TYPE_FUNC {
        cType string
        if strHasPrefix(tt, "function(") {
            cType = string("void*")
        } else {
            cType = getCType(tt, elems)
        }
        v = genCompilerVar()
        if parsedPointer == true {
            cType.append("*")
        }
        OUTPUT = OUTPUT + rope(cType.str()+" "+v+" = "+t.cont+";\n")
        t.cont = v
        if t.type == TOKEN_TYPE_STR {
            ogName = "[bah cpstring]"
        }
    }

    arrElem = "0"
    if strHasPrefix(tt, "[]") {
        isArr = "1"
        aet = string(tt)
        aet.trimLeft(2)
        tmpT = Tok{}
        tmpT.type = TOKEN_TYPE_VAR
        tmpT.cont = "0"
        rt = parseReflect(tmpT, aet.str(), elems, true, "", "0")
        
        aev = genCompilerVar()
        
        OUTPUT = OUTPUT + rope("
        struct reflectElement "+aev+" = "+rt.cont+";
        ")

        arrElem = "&"+aev
    } else if strHasPrefix(tt, "map:") {
        aet = string(tt)
        aet.trimLeft(4)
        tmpT = Tok{}
        tmpT.type = TOKEN_TYPE_VAR
        tmpT.cont = "0"
        rt = parseReflect(tmpT, aet.str(), elems, true, "", "0")
        aev = genCompilerVar()
        OUTPUT = OUTPUT + rope("
        struct reflectElement "+aev+" = "+rt.cont+";
        ")
        arrElem = "&"+aev
    }

    isStruct = "0"
    ts = searchStruct(tt, elems)
    structLayout = "0"    

    if ts != null {
        isStruct = "1"
        structLayout = genCompilerVar()

        slv = new variable
        slv.name = structLayout
        slv.type = "[]reflectElement"

        elems.vars[len(elems.vars)] = slv

        dataLayout = rope("")

        i=0; for i < len(ts.members), i++ {
            m = ts.members[i]
            if m.type == tt {
                nm = new structMemb
                *nm = *m
                m = nm
                m.type = "ptr"
            }
            tmpT = Tok{}
            tmpT.type = TOKEN_TYPE_VAR
            sep = "->"
            if strCount(tt, "*") == 0 {
                sep = "."
            }
            mCtype = getCType(m.type, elems)
            offsetTT = string(tt)
            offsetTT.replace("*", "")
            tmpT.cont = "("+mCtype.str()+"*)((char*)("+t.cont+") + offsetof(struct "+offsetTT.str()+", "+m.name+"))"
            rt = parseReflect(tmpT, m.type, elems, true, m.name, "offsetof(struct "+offsetTT.str()+", "+m.name+")")
            dataLayout = dataLayout + rope(structLayout+"->data["+intToStr(i)+"] = "+rt.cont+";\n")
        }

        OUTPUT = OUTPUT + rope("
        array(struct reflectElement) * "+structLayout+" = memoryAlloc(sizeof(array(struct reflectElement)));
        "+structLayout+"->elemSize = sizeof(struct reflectElement);
        "+structLayout+"->length = "+intToStr(len(ts.members))+";
        "+structLayout+"->data = memoryAlloc("+structLayout+"->length * "+structLayout+"->elemSize);
        ") + dataLayout
    }

    amp = ""
    if strCount(tt, "*") == 0 && tt != "cpstring" && tt != "ptr" && parsedPointer == false {
        amp = "&"
    }

    name = string(ogName)
    if hasStructSep(name) == true {
        name = splitStructSepAfter(name)
    }

    cType string

    if strHasPrefix(tt, "function(") {
        cType = string("void*")
    } else {
        cType = getCType(tt, elems)
    }


    if cType.hasPrefix("struct ") {
        cType.replace("*", "")
    }

    if cType.length == 0 {
        cType.set("0")
    }

    rv = new variable
    rv.name = genCompilerVar()
    rv.type = "reflectElement"

    elems.vars[len(elems.vars)] = rv

    OUTPUT = OUTPUT + rope("struct reflectElement "+rv.name+" = __reflect("+amp+t.cont+", sizeof("+cType.str()+"), \""+tt+"\", \""+name.str()+"\", "+isArr+", "+arrElem+", "+isStruct+", "+structLayout+", "+offset+");\n")
                        //                                                    value                  size             type           name            isArr       arrE        isStruct      structLayout      offset
    t.cont = rv.name

    return t
}


parseArrayDecl(v variable*, l []Tok, i int, max int, elems Elems*) cpstring {
    arrayLength = 0
    arrType = getCType(v.type, elems)
    arrType.trimRight(1)
    code = "memoryAlloc(sizeof("+arrType.str()+"))"
    arrType.trimLeft(6)
    arrType.trimRight(1)
    elemTypeStr = arrType.str()

    if i + 1 != max {
        i++
        nt = l[i]
        if nt.cont != "{" {
            throwErr(&l[i+1], "{TOKEN} not expected after array initialization.")
        }
        elemBahType = string(v.type)
        elemBahType.trimLeft(2)
        elemBahTypeStr = elemBahType.str()
        i = i + 1
        memory = []Tok
        for i < max {
            memory[len(memory)] = l[i]
            i = i + 1
        }
        memory = prePross(memory, <lineType>-1, elems)
        i=0; for i < len(memory) {
            t = memory[i]
            if t.cont == "{" {

                j=i-1
                nbBraces = 0
                for i < len(memory), i++ {
                    tmpT = memory[i]
                    if tmpT.cont == "{" {
                        nbBraces++
                    } else if tmpT.cont == "}" {
                        nbBraces--
                    }
                    if nbBraces == 0 {
                        break
                    }
                }
                tmpV = new variable
                tmpV.name = genCompilerVar()
                elemType = string(v.type)
                elemType.trimLeft(2)
                tmpV.type = elemType.str()
                elems.vars[len(elems.vars)] = tmpV

                oldNL = NEXT_LINE
                NEXT_LINE = ""
                innerCode = parseArrayDecl(tmpV, memory, j, i+1, elems)
                cType = getCType(elemType.str(), elems)
                OUTPUT = OUTPUT + rope("
                array("+cType.str()+") * "+tmpV.name+" = "+innerCode+";
                "+NEXT_LINE+"
                ")
                NEXT_LINE = oldNL
                
                t = Tok{
                    type: TOKEN_TYPE_VAR
                    cont: tmpV.name
                    bahType: elemType.str()
                    isValue: true
                }

            }
            tt = getTypeFromToken(&t, true, elems)
            if compTypes(tt, elemBahTypeStr) == false {
                throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+elemBahTypeStr)
            }
            
            strArrayLength = intToStr(arrayLength)
            arrayLength =arrayLength + 1

            NEXT_LINE = NEXT_LINE + v.name + "->data[" + strArrayLength + "] = " + t.cont + ";\n"
            i++
            t = memory[i]

            if t.cont != "," {
                if t.cont == "}" {
                    allocLength = arrayLength
                    if allocLength > 50 {
                        modAllocAmm = allocLength % 50
                        allocLength = allocLength + modAllocAmm
                    } else {
                        allocLength = 50
                    }
                    allocLengthStr = intToStr(allocLength)
                    NEXT_LINE = v.name + "->data = memoryAlloc(sizeof(" + elemTypeStr + ") * " + allocLengthStr + ");" + NEXT_LINE
                    break
                } else {
                    throwErr(&t, "Expected ',' got {TOKEN}.")
                }
            }
            i = i + 1
        }
    }
    strArrayLength = intToStr(arrayLength)
    NEXT_LINE = "
" + v.name + "->length = " + strArrayLength + ";
" + v.name + "->elemSize = sizeof(" + elemTypeStr + ");
" + NEXT_LINE
    return code
}

equalsTokens = []cpstring{"=", "+=", "-=", "*=", "/="}

parseVar(l []Tok, elems Elems*) {
//     recorder = timer.record("parseVar")
    ft = l[0]
    if ft.isFunc == true {
        if len(l) > 1 {
            throwErr(&l[len(l)-1], "Not expecting {TOKEN} after function call.")
        }
        ft = l[0]
        parsed = true
        OUTPUT = OUTPUT + rope(ft.cont + ";\n")
        return
    }
    l = parseStructType(l, <lineType>-1, elems)
    isEqual = false
    toVar = false
    isPointedVar = false
    isStruct = false
    currentType = ""
    needsDefine = false
    ft = l[0]
    v = searchVar(ft.cont, elems)
    exists = true
    ogName cpstring
    if v == null {
        exists = false
        v = new variable
        v.name = ft.cont
        v.type = ""
    } else {
        ogName = v.name
    }
    if v.isConst == true {
        throwErr(&ft, "Cannot set the value of const {TOKEN}.")
    }
    code = ""

    if exists == true && isGlobal() {
        throwErr(&ft, "Cannot redeclare global variable {TOKEN}.")
    }
    

    if len(l) == 1 {
        t = l[0]
        c = string(t.cont)
        c.trimRight(2)
        v = searchVar(c.str(), elems)
        if v == null {
            throwErr(&t, "Cannot increase/decrease not declared variable {TOKEN}.")
        }
        OUTPUT += rope(t.cont + ";\n")
        return
    }

    // if len(l) == 2 {
    //     lt = l[1]
    //     if lt.type == TOKEN_TYPE_SYNTAX && lt.cont == "++" || lt.cont == "--" {
    //         if exists == false {
    //             throwErr(&ft, "Cannot use '"+lt.cont+"' on non declared {TOKEN} variable.")
    //         }
    //         nl = []Tok
    //         nl[0] = l[0]

    //         nl[1] = Tok{
    //             type: TOKEN_TYPE_SYNTAX
    //             cont: "="
    //             isValue: false
    //         }
            
    //         c = ""
    //         if lt.cont == "++" {
    //             c = ft.cont+"+1"
    //         } else if lt.cont == "--" {
    //             c = ft.cont+"-1"
    //         }
            
    //         ltl = lt.line
    //         ltp = lt.pos
    //         ltc = lt.cont

    //         nl[2] = Tok{
    //             type: TOKEN_TYPE_INT
    //             cont: c
    //             line: ltl
    //             ogCont: ltc
    //             pos: ltp
    //             isOper: true
    //             isValue: true
    //         }
    //         l = nl
    //     }
    // }

    if len(l) < 2 {
        throwErr(&ft, "Missing '=' after {TOKEN}.")
    }
    operT = l[1]
    if operT.cont in equalsTokens && operT.cont != "=" {
        nl = []Tok{l[0]}
        if 2 == len(l) {
            throwErr(&operT, "Cannot use {TOKEN} on nothing.")
        }
        oper = string(operT.cont)
        oper.trimRight(1)
        operTok = operT
        operTok.cont = oper.str()

        tmpL = []Tok {
            ft,
            operTok,
            l[2]
        }

        tmpL = prePross(tmpL, LINE_TYPE_VAR, elems)

        operT.cont = "="
        nl[len(nl)] = operT

        j=0; for j < len(tmpL), j++ {
            nl[len(nl)] = tmpL[j]
        }


        l = nl
    }

    i=1; for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_SYNTAX {
            if t.cont == "=" {
                if strlen(currentType) > 0 {
                    sct = string(currentType)
                    sct.replace(" ", "")
                    v.type = sct.str()
                }
                isEqual = true
                i = i + 1
                continue
            }
        }
        if isEqual == false {
            currentType = currentType + t.cont
        } else {

            if t.isEqual == true && exists == false && isGlobal() == false {
                needsDefine = true
            }

            if t.cont == "chan" {
                if i >= len(l) {
                    throwErr(&t, "Cannot declare a {TOKEN} without a type (chan <type>).")
                }
                i++
                nt = l[i]
                v.type = "chan:" + nt.cont
                code = "channel()"
                if i+1 != len(l) {
                    errT = l[i+1]
                    throwErr(&errT, "{TOKEN} not expected after channel declaration.")
                }
                break
            } else if t.cont == "map" {
                if i >= len(l) {
                    throwErr(&t, "Cannot declare a {TOKEN} without a type (map <type>).")
                }
                i++
                nt = l[i]
                v.type = "map:"+nt.cont
                code = "mapWrapper()"
                if i+1 != len(l) {
                    errT = l[i+1]
                    throwErr(&errT, "{TOKEN} not expected after map declaration.")
                }
                break
            } else if t.cont == "buffer" {
                if i >= len(l) {
                    throwErr(&t, "Cannot declare a {TOKEN} without a length (buffer <length>).")
                }
                i++
                nt = l[i]
                if nt.type != TOKEN_TYPE_INT {
                    throwErr(&nt, "Expected buffer length, not {TOKEN}.")
                }
                v.type = "buffer:"+nt.cont
                av = new variable
                av.type = "char*"
                av.name = genCompilerVar()
                elems.vars[len(elems.vars)] = av
                cType = getCType(av.type, elems)
                OUTPUT = OUTPUT + rope("char "+av.name+"["+nt.cont+"];")
                code = av.name
                if i+1 != len(l) {
                    errT = l[i+1]
                    throwErr(&errT, "{TOKEN} not expected after buffer declaration.")
                }
                break
            } 
            // if t.isValue == false {
            //     throwErr(&t, "Cannot use {TOKEN} as value in var declaration.")
            // }
            tp = getTypeFromToken(&t, true, elems)
            if exists == true {
                if compTypes(tp, v.type) == false {
                    throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                }
            } else {
                if currentType == "" {
                    if v.type == "" {
                        v.type = tp
                    } else {
                        if compTypes(tp, v.type) == false {
                            throwErr(&t, "Cannot use {TOKEN} ("+tp+") as "+v.type+".")
                        }
                    }
                }
            }
            if t.cont != "" && strHasPrefix(t.cont, "{") == false {
                code = code + t.cont
                if t.isOper == false && RCPavailable() == true {
                    iv = searchVar(t.cont, elems)
                    if iv != null && iv.isConst == false {
                        toVar = true
                        isPointedVar = strHasPrefix(t.cont, "&")
                        s = searchStruct(iv.type, elems)
                        if s != null && strCount(iv.type, "*") == 0 && s.isBinding == false {
                            if strCount(iv.name, "*") == 0 {
                                code = code + "; RCP_scanStack(&"+iv.name+", sizeof("+iv.name+"), 0)"
                            } else {
                                ivn = string(iv.name)
                                if ivn.count("*") > 0 {
                                    ivn.replace("*", "")
                                    code += "; RCP_scanStack("+ivn.str()+", sizeof("+iv.name+"), 0)"
                                } else {
                                    code = code + "; RCP_incr("+iv.name+")"
                                }
                            }
                        }
                    }
                }
                break
            }


            if strHasPrefix(v.type, "[]") {
                code = parseArrayDecl(v, l, i, len(l), elems)
                break
            }
            isStruct = true
            if i+1 != len(l) {
                throwErr(&l[i+1], "{TOKEN} not expected after struct initialization.")
            }
            // s = searchStruct(v.type, elems)
            // NEXT_LINE = declareStructMethods(v, s, elems)
            code = code + t.cont
        }

        i++
    }

    if exists == true {
        // oCode = code
        if strlen(code) == 0 {
            throwErr(&ft, "Cannot re-declare {TOKEN}.")
        }
        if strlen(currentType) > 0 {
            st = l[1]
            throwErr(&st, "Cannot change the type of already declared var '"+ft.cont+"' to {TOKEN}.")
        }
        preCode = ""
        if isStruct == false {
            if isRCPpointerType(v.type) && isPointedVar == false && RCPavailable() == true {
                cType = getCType(v.type, elems)
                if toVar == true {
                    if RCPselfRef(v) == false {
                        code = "*("+cType.str()+"*)RCP_decrIL(&"+v.name+") = *("+cType.str()+"*)RCP_incrIL(&"+code+")"
                    } else {
                        tmpV = new variable
                        tmpV.name = genCompilerVar()
                        tmpV.type = v.type
                        dv = decrVar(tmpV, elems)
                        code = cType.str()+" "+tmpV.name+" = "+v.name+"; "+v.name+" = *("+cType.str()+"*)RCP_incrIL(&"+code+");"+dv.toStr()
                    }
                } else {
                    tmpV = new variable
                    tmpV.name = genCompilerVar()
                    tmpV.type = v.type
                    dv = decrVar(tmpV, elems)
                    code = cType.str()+" "+tmpV.name+" = "+v.name+"; "+v.name+" = "+code+";"+dv.toStr()
                }
            } else {
                s = searchStruct(v.type, elems)
                if s != null && RCPavailable() == true && RCPselfRef(v) == false && s.isBinding == false {
                    if strCount(v.name, "*") == 0 {
                        preCode = "RCP_scanStack(&"+v.name+", sizeof("+v.name+"), 1); "
                    } else {
                        vn = string(v.name)
                        vn.replace("*", "")
                        preCode = "RCP_scanStack("+vn.str()+", sizeof("+v.name+"), 1); "
                    }
                    code = v.name + " = " + code
                } else {
                    code = v.name + " = " + code
                }
            }
        } else {
            strTrim(&code)
            if strHasPrefix(code, "{") == false {
                code = v.name + " = " + code
            }
        }
        if v.isArray == true {
            nLength = string(v.name)
            n = string(v.name)
            i=0; for i < nLength.length {
                c = nLength.charAt(i)
                if c == '[' {
                    break
                }
                i++
            }
            nLength.trimLeft(i+1)
            nLength.trimRight(1)
            nLengthStr = nLength.str()

            i=n.length; for i > 0 {
                c = n.charAt(i)
                if c == '[' {
                    break
                }
                i--
            }
            tamm = n.length - i
            
            n.trimRight(tamm + 6)
            nstr = n.str()
            elemType = getCType(v.type, elems)
            elemTypeStr = elemType.str()

            code = "
{
long nLength = " + nLengthStr + ";
if (" + nstr + "->length < nLength+1) {
if ((nLength+1) % 50 == 0 || nLength == 0) {
void * newPtr = memoryRealloc("+nstr+"->data, (nLength+50)*sizeof("+elemTypeStr+"));
"+nstr+"->data = newPtr;
}
"+code+";
"+nstr+"->length = nLength+1;
} else {
"+preCode+code+";
}
}"


        } else {
            code = preCode + code
        }
    } else {
        if currentType != "" {
            v.type = currentType
        }

        vts = string(v.type)
        vts.replace(" ", "")
        v.type = vts.str()
        if strlen(v.type) == 0 {
            throwErr(&ft, "Cannot declare {TOKEN} without a type.")
        }
        vct cpstring
        if vts.hasPrefix("function(") {
            tmpfn = parseFnType(vts)
            tmpfnRetCType = getCType(tmpfn.returns.type, elems)

            tmpfnArgsCType = ""
            j=0; for j < len(tmpfn.args) {
                arg = tmpfn.args[j]
                ct = getCType(arg.type, elems)
                tmpfnArgsCType = tmpfnArgsCType + ct.str()
                j = j + 1
                if j < len(tmpfn.args) {
                    tmpfnArgsCType = tmpfnArgsCType + ","
                }
            }

            vct = tmpfnRetCType.str() + " (*"+v.name+")("+tmpfnArgsCType+")"
        } else {
            vct = setCType(v, elems)
        }
        if code != "" && shouldOnlyDecl == false {

            
            if isRCPpointerType(v.type) && RCPavailable() == true && toVar == true  && isPointedVar == false {
                cType = getCType(v.type, elems)
                if isGlobal() {
                    INIT += rope(v.name + " = *("+cType.str()+"*)RCP_incrIL(&"+code+");\n")
                } else {
                    code = vct+" = *("+cType.str()+"*)RCP_incrIL(&"+code+")"
                }
            } else {
                if needsDefine == true {
                    elems.defined[len(elems.defined)] = v.name
                    if isGlobal() {
                        INIT += rope("#define "+v.name+" "+code+"\n")
                    } else {
                        code = "#define "+v.name+" "+code
                    }
                } else {
                    if isGlobal() {
                        INIT += rope(v.name + " = " + code+";\n")
                    } else {
                        code = vct + " = " + code
                    }
                }
            }
        } else {
            if isRCPpointerType(v.type) && shouldOnlyDecl == false  {
                code = vct + "= null"
            } else {
                code = vct
            }
        }

        if shouldOnlyDecl == true {
            vct = "extern "+vct
        }

        if isGlobal() {
            v.isGlobal = true
        } else {
            v.isGlobal = false
        }

        elems.vars[len(elems.vars)] = v

        debugPrint("var_declaration", ft.line, v)
        // registerType(&fileDeps, v.type, elems)

        if isGlobal() {
            OUTPUT += rope(vct+";\n")
        }


    }

    if isGlobal() {
        if isSubObject == false {
            INIT += rope(NEXT_LINE)
        }
        NEXT_LINE = ""
    } else {
        if needsDefine == true {
            OUTPUT += rope(code + "\n")
        } else {
            OUTPUT += rope(code + ";\n")
        }
    }


}

getCfunctionType(cfrt string, elemName cpstring, elems Elems*) cpstring {

    tmpfn = parseFnType(cfrt)
    tmpfnRetCType = getCType(tmpfn.returns.type, elems)
    tmpfnArgsCType = ""
    j=0; for j < len(tmpfn.args) {
        arg = tmpfn.args[j]
        ct = getCType(arg.type, elems)
        tmpfnArgsCType = tmpfnArgsCType + ct.str()
        j = j + 1
        if j < len(tmpfn.args) {
            tmpfnArgsCType = tmpfnArgsCType + ","
        }
    }

    return tmpfnRetCType.str() + " (*"+elemName+")("+tmpfnArgsCType+")"
}


parseFnHeader(prev cpstring, l []Tok, i int*, fn func*, elems Elems*) cpstring {

    j = *i
    ft = l[j]
    tpdf = ""
    if ft.type != TOKEN_TYPE_VAR {
        throwErr(&ft, "Cannot use {TOKEN} as function name.")
    }
    fn.name = prev + ft.cont

    arguments = []variable*

    code = fn.name + "("


    j = j + 2
    
    t = l[j]
    if t.cont != ")" {

        for j < len(l) {
            t = l[j]
            if t.type != TOKEN_TYPE_VAR {
                throwErr(&t, "Cannot use {TOKEN} as argument name.")
            }
            argName = t.cont

            j =j + 1
            if j >= len(l) {
                throwErr(&t, "Cannot declare argument {TOKEN} without a type.")
            }
            t = l[j]
            argType = t.cont

            j =j + 1
            isComa = false
            nbPars = 1
            for j < len(l) {
                t = l[j]
                isComa = false
                if t.cont != "," {
                    if t.cont == "(" {
                        nbPars = nbPars + 1
                    } else if t.cont == ")" {
                        nbPars = nbPars - 1
                    }
                    if t.cont == ")" && nbPars == 0 {
                        break
                    } else {
                        argType = argType + t.cont
                    }
                } else {
                    isComa = true
                    break
                }                
                j =j + 1
            }

            argument = new variable
            argument.name = argName
            argument.type = argType
            arguments[len(arguments)] = argument
            

            argCType = getCType(argType, elems)

            cfrt = string(argType)
            newArgType = argCType.str()
            if cfrt.hasPrefix("[]") == 1 {
                cfrt.trimLeft(2)
                if cfrt.hasSuffix("*") {
                    nbast = cfrt.count("*")
                    cfrt.trimRight(nbast)
                }
                newArgType = "__BAH_ARR_TYPE_" + cfrt.str()
                csatd = compilerState.arrTypesDecl
                if inArrayStr(newArgType, csatd) == false {
                    csatd[len(csatd)] = newArgType
                    tpdf = tpdf + "typedef " + argCType.str() + " " + newArgType + ";\n"
                }
            }
            if cfrt.hasPrefix("function(") == 1 {
                code = code + getCfunctionType(cfrt, argName, elems)
            } else {
                code = code + newArgType + " " + argName
            }
            if isComa == true {
                code = code + ","
            } else {
                code = code + ")"
                break
            }
            j =j + 1
        }
    } else {
        code = code + ")"
    }

    j =j + 1

    returns = new variable
    returns.type = ""
    for j < len(l) {
        t = l[j]
        if t.cont == "{" {
            break
        }
        returns.type = returns.type + t.cont
        j =j + 1
    }
    if strlen(returns.type) {
        rts = string(returns.type)
        rts.replace(" ", "")
        returns.type = rts.content
    }
    *i = j
    returns.name = fn.name
    fn.returns = returns
    fn.args = arguments

    fnRetType = getCType(returns.type, elems)
    newFnRetType = fnRetType.str()

    cfrt = string(returns.type)
    if cfrt.hasPrefix("[]") == 1 {
        cfrt.trimLeft(2)
        if cfrt.hasSuffix("*") {
            nbast = cfrt.count("*")
            cfrt.trimRight(nbast)
        }
        newFnRetType = "__BAH_ARR_TYPE_" + cfrt.str()
        csatd = compilerState.arrTypesDecl
        if inArrayStr(newFnRetType, csatd) == false {
            csatd[len(csatd)] = newFnRetType
            tpdf = tpdf + "typedef " + fnRetType.str() + " " + newFnRetType + ";\n"
        }
    }
    code = tpdf + newFnRetType + " " + code



    return code
}

parseStruct(l []Tok, elems Elems*) {
//     recorder = timer.record("parseStruct")
    s = new cStruct
    structs = elems.structs
    structs[len(structs)] = s
    methds = s.methods
    if len(l) < 4 {
        throwErr(&l[len(l)-1], "Cannot declare struct has such, please do 'struct <name> { <memberName>:<memberType> }'.")
    }
    nameToken = l[1]
    i = 2
    doesOutput = true
    if nameToken.cont == "!" {
        nameToken = l[2]
        i = 3
        doesOutput = false
        s.isBinding = true
    }
    if nameToken.type != TOKEN_TYPE_VAR {
        throwErr(&nameToken, "Cannot use {TOKEN} as struct name.")
    }
    os = searchStruct(nameToken.cont, elems)
    if os != null {
        throwErr(&nameToken, "Struct {TOKEN} already exists.")
    }
    s.name = nameToken.cont
    members = s.members
    currentCStruct = s
    allMembs = []cpstring
    st = l[i]
    if st.type == TOKEN_TYPE_KEYWORD {
        if st.cont == "extend" {
            i++
            extdSNameTk = l[i]
            i++
            if extdSNameTk.type != TOKEN_TYPE_VAR {
                throwErr(&extdSNameTk, "Cannot use {TOKEN} as struct name.")
            }
            extdS = searchStruct(extdSNameTk.cont, elems)
            s.extendedFrom = extdS.name
            if extdS == null {
                throwErr(&extdSNameTk, "Struct {TOKEN} does not exist.")
            }
            extdsmbs = extdS.members
            j=0; for j < len(extdsmbs) {
                em = extdsmbs[j]
                cemt = string(em.type)
                membDeclStr cpstring
                if cemt.hasPrefix("function(") == 1 {
                    tmpfn = parseFnType(cemt)
                    tmpfnRetCType = getCType(tmpfn.returns.type, elems)
                    tmpfnArgsCType = ""
                    j=0; for j < len(tmpfn.args) {
                        arg = tmpfn.args[j]
                        ct = getCType(arg.type, elems)
                        tmpfnArgsCType = tmpfnArgsCType + ct.str()
                        j = j + 1
                        if j < len(tmpfn.args) {
                            tmpfnArgsCType = tmpfnArgsCType + ","
                        }
                    }
                    membDeclStr = tmpfnRetCType.str() + " (*"+em.name+")("+tmpfnArgsCType+")"
                } else {
                    if isRCPpointerType(em.type) {
                        s.hasRCPmemb = true
                    }
                    membDecl = getCType(em.type, elems)
                    membDecl.append(" ")
                    membDecl.append(em.name)
                    membDeclStr = membDecl.content
                    // registerType(&fileDeps, em.type, elems)
                }
                allMembs[len(allMembs)] = membDeclStr
                members[len(members)] = em
                j = j + 1
            }
            k=0; for k < len(extdS.methods) {
                emt = extdS.methods[k]
                // registerFunc(&fileDeps, emt, elems)
                mthdDecl = getCType(emt.returns.type, elems)
                mthdDecl.append("(*" + emt.name + ")(")
                j=0; for j < len(emt.args) {
                    a = emt.args[j]
                    tp = getCType(a.type, elems)
                    tp.append(" " + a.name)
                    max = len(emt.args) - 1
                    if j != max {
                        tp.append(",")
                    }
                    mthdDecl.append(tp.str())
                    j =j + 1
                }
                mthdDecl.append(")")
                allMembs[len(allMembs)] = mthdDecl.str()

                k = k + 1
            }
        } else {
            throwErr(&st, "Cannot use keyword {TOKEN} in struct declaration.")
        }
    }
    braceTk = l[i]
    i++
    if braceTk.cont != "{" {
        throwErr(&braceTk, "Cannot use {TOKEN} in struct declaration.")
    }
    OOUT = OUTPUT
    nextLine = ""
    for i < len(l) {
        t = l[i]
        max = i + 2
        if max >= len(l) {
            if t.type == TOKEN_TYPE_ENCL && t.cont == "}" {
                break
            }
            throwErr(&l[len(l)-1], "Not enough argument in member declaration, ending by {TOKEN}.")
        }
        memb = new structMemb
        if t.type != TOKEN_TYPE_VAR {
            throwErr(&t, "Cannot use {TOKEN} as member name.")
        }
        memb.name = t.cont
        ii=0; for ii < len(members) {
            m = members[ii]
            if m.name == memb.name {
                throwErr(&t, "Member {TOKEN} has already been declared.")
            }
            ii =ii + 1
        }
        i++
        t = l[i]
        if t.cont != ":" {
            if t.cont != "(" {
                throwErr(&t, "Member name should be followed by ':' not {TOKEN}.")
            } else {
                fnPrefix = s.name + "__"
                fn = new func
                nl = []Tok
                j=i-1; for j < len(l) {
                    t = l[j]
                    if t.cont == "{" {
                        break
                    }
                    nl[len(nl)] = t
                    if j == i {
                        t.type = TOKEN_TYPE_VAR
                        t.cont = "this"
                        t.isValue = true
                        nl[len(nl)] = t

                        t.type = TOKEN_TYPE_VAR
                        t.cont = s.name+"*"
                        t.isValue = true
                        nl[len(nl)] = t

                        nt = l[j+1]
                        if nt.cont != ")" {
                            t.type = TOKEN_TYPE_SYNTAX
                            t.cont = ","
                            t.isValue = false
                            nl[len(nl)] = t
                        }
                    }
                    j =j + 1
                }
                i--

                nli = 0

                code = rope(parseFnHeader(fnPrefix, nl, &nli, fn, elems))
                i = i + nli
                i = i - 2

                returns = fn.returns
                arguments = fn.args
                fn.from = s.name
                if shouldOnlyDecl == true {
                    code = code + rope(";\n")
                } else {
                    code = code + rope("{\n")
                }
                
                fnElems = dupElems(elems)
                j=0; for j < len(arguments) {
                    a = arguments[j]
                    a.outterScope = true
                    fnElems.vars[len(fnElems.vars)] = a
                    j =j + 1
                }

                fns = elems.fns
                fns[len(fns)] = fn

                tokens = []Tok
                nbBraces = 1
                t = l[i]
                if t.cont == "{" {
                    i++
                }
                for i < len(l) {
                    t = l[i]
                    if t.cont == "{" {
                        nbBraces =nbBraces + 1
                    } else if t.cont == "}" {
                        nbBraces =nbBraces - 1
                    }
                    if nbBraces == 0 {
                        break
                    }
                    tokens[len(tokens)] = t
                    i++
                }


                mfn = new func
                mfn.args = fn.args
                mfn.name = fn.name
                mfn.returns = fn.returns
                mfn.from = s.name

                strTrimLeft(&mfn.name, strlen(fnPrefix))

                methds[len(methds)] = mfn
                // registerFunc(&fileDeps, mfn, elems)

                if shouldOnlyDecl == false {
                    if len(tokens) == 0 {
                        code = code + rope("};\n")
                    } else {
                        OUTPUT = rope("")
                        currentFn = fn
                        beginRCPscope(fnElems, fn.args)
                        ocurrFnElems = compilerState.currFnElems
                        compilerState.currFnElems = fnElems
                        parseLines(tokens, fnElems)
                        compilerState.currFnElems = ocurrFnElems

                        currentFn = null
                        if fn.returned == false {
                            if strlen(fn.returns.type) > 0 {
                                throwErr(&l[len(l)-1], "Function '"+fn.name+"' is not returned.")
                            }
                            endRCPscope(fnElems, fn.args)
                            // decrRCPstackVars(fn.args, elems)
                        }
                        code = code + OUTPUT + rope("};\n")
                    }
                }

                if doesOutput == true {
                    nextLine = nextLine + code.toStr()
                }

                mthdDecl = getCType(fn.returns.type, elems)
                mthdDecl.append("(*" + mfn.name + ")(")
                j=0; for j < len(arguments) {
                    a = arguments[j]
                    tp = getCType(a.type, elems)
                    tp.append(" "+a.name)
                    max = len(arguments) - 1
                    if j != max {
                        tp.append(",")
                    }
                    mthdDecl.append(tp.str())
                    j =j + 1
                }
                mthdDecl.append(")")
                allMembs[len(allMembs)] = mthdDecl.str()

                i++
                continue

            }
        }
        i++
        mbmType = ""
        currentLine = t.line
        for i < len(l) {
            t = l[i]
            if t.cont == "=" {
                i--
                break
            }
            if t.line != currentLine {
                i--
                break
            }
            mbmType = mbmType + t.cont
            i++
        }
        
        memb.type = mbmType
        i++
        t = l[i]
        if i < len(l) {
            if t.cont == "=" {
                i++
                t = l[i]
                if t.isValue == false {
                    throwErr(&t, "Cannot use {TOKEN} as default value for member.")
                }
                tt = getTypeFromToken(&t, true, elems)
                if compTypes(tt, memb.type) == false {
                    throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+memb.type+" for member.")
                }
                memb.def = t.cont

            } else {
                i--
            }
        }
        if isRCPpointerType(memb.type) {
            s.hasRCPmemb = true
        }
        members[len(members)] = memb
        // registerType(&fileDeps, memb.type, elems)
        membDeclStr cpstring
        cmt = string(memb.type)
        if cmt.hasPrefix("function(") == 1 {
            tmpfn = parseFnType(cmt)
            tmpfnRetCType = getCType(tmpfn.returns.type, elems)
            tmpfnArgsCType = ""
            j=0; for j < len(tmpfn.args) {
                arg = tmpfn.args[j]
                ct = getCType(arg.type, elems)
                tmpfnArgsCType = tmpfnArgsCType + ct.str()
                j = j + 1
                if j < len(tmpfn.args) {
                    tmpfnArgsCType = tmpfnArgsCType + ","
                }
            }
            membDeclStr = tmpfnRetCType.str() + " (*"+memb.name+")("+tmpfnArgsCType+")"
        } else {
            membDecl = getCType(memb.type, elems)
            membDecl.append(" " + memb.name)
            membDeclStr = membDecl.str()
        }
        allMembs[len(allMembs)] = membDeclStr
        i++
    }
    s.members = members
    if doesOutput == true {
        OUTPUT = OOUT
        NEXT_LINE = nextLine
        code = rope("struct "+s.name+" {\n")
        i=0; for i < len(allMembs) {
            m = allMembs[i]
            code = code + rope(m +";\n")
            i++
        }
        // if RCPavailable() == true {
        //     code = code + rope("void * __RCP_counter;\n")
        // }
        
        code = code + rope("};\n")
        OUTPUT += code // + makeRCPfuncFromStruct(s, elems)
    }

    if debug == true {

        ds = new debugStruct
        ds.name = s.name
        i=0; for i < len(s.members) {
            m = s.members[i]
            mv = new variable
            mv.name = m.name
            mv.type = m.type
            mv.isConst = false
            mv.isArray = m.isArray
            ds.membs[i] = mv
            i = i + 1
        }

        debugPrint("struct_declare", nameToken.line, ds)
    }


}

parseDefine(l []Tok, elems Elems*) {

    if len(l) < 3 {
        throwErr(&l[len(l)-1], "Invalid usage of define, cannot end on {TOKEN}.")
    }
    
    ft = l[1]
    st = l[2]

    i = 1
    doesOutput = true
    if ft.cont == "!" {
        ft = l[2]
        st = l[3]
        i = 2
        doesOutput = false
    }

    if st.cont == "(" {
        
        fn = new func
        code = parseFnHeader("", l, &i, fn, elems)
        fns = elems.fns
        fn.isBinding = true
        fns[len(fns)] = fn
        if doesOutput == true {
            OUTPUT = OUTPUT + rope(code+";\n")
        }

    } else {
        tp = ""
        i++; for i < len(l), i++ {
            t = l[i]
            tp = tp + t.cont
        }
        if ft.type != TOKEN_TYPE_VAR {
            throwErr(&ft, "Cannot use {TOKEN} as new type name.")
        }
        cTypeNewType = getCType(tp, elems)
        cTypeNewTypeStr = cTypeNewType.str()
        if doesOutput == true {
            OUTPUT = OUTPUT + rope("typedef " + cTypeNewTypeStr + " " + ft.cont + ";\n")
        }

        if debug == true {
            dt = new debugType
            dt.name = ft.cont
            dt.refers = tp
            debugPrint("type_declare", ft.line, dt)
        }

        tps = elems.types
        tps[len(tps)] = ft.cont
    }

}

parseClib(line []Tok) {

    clibs = compilerState.cLibs
    
    i=1; for i < len(line) {
        t = line[i]
        if t.type != TOKEN_TYPE_STR {
            throwErr(&t, "Cannot use {TOKEN} as C library name.")
        }

        cc = string(t.cont)
        cc.trimLeft(1)
        cc.trimRight(1)
        ccstr = cc.str()

        found = false
        j=0; for j < len(clibs) {
            l = clibs[j]
            if l == ccstr {
                found = true
                break               
            }
            j =j + 1
        }
        if found == true {
            i++
            continue
        }
        clibs[len(clibs)] = ccstr

        i++
    }

}

parseConst(l []Tok, elems Elems*) {
    l = parseCast(l, elems, true)
    if len(l) != 4 {
        throwErr(&l[0], "Invalid usage of {TOKEN}, must be 'const <constName> = <constValue>'. ")
    }
    vart = l[1]
    equt = l[2]
    valt = l[3]
    if vart.type != TOKEN_TYPE_VAR {
        throwErr(&vart, "Cannot take {TOKEN} as const name.")
    }
    if equt.cont != "=" {
        throwErr(&equt, "Expected '=' not {TOKEN}.")
    }
    if valt.isValue == false {
        throwErr(&equt, "Must be a value, not {TOKEN}.")
    }

    if valt.type == TOKEN_TYPE_VAR {
        fn = searchFunc(valt.cont, elems, true)
        if fn != null {
            fn.used = true
        }
    }

    v = new variable

    if isGlobal() {
        v.isGlobal = true
    }

    v.isConst = true
    v.constVal = valt.cont
    v.name = vart.cont
    v.type = getTypeFromToken(&valt, true, elems)
    vars = elems.vars
    vars[len(vars)] = v

    OUTPUT = OUTPUT + rope("#define "+v.name+" "+valt.cont+"\n")

}

parseReturn(l []Tok, elems Elems*) {

    if len(l) > 2 {
        throwErr(&l[0], "Invalid usage of {TOKEN}, must be 'return <returnValue>'")
    }
    if currentFn == null {
        throwErr(&l[0], "Cannot return a value outside of a function.")
    }
    rv = ""
    tt = ""
    tmpV variable* = null
    if len(l) == 1 {
        if strlen(currentFn.returns.type) != 0 {
            throwErr(&l[0], "Cannot return nothing as "+currentFn.returns.type+".")
        }
    } else {
        rvt = l[1]
        tt = getTypeFromToken(&rvt, true, elems)
        rv = rvt.cont
        if rvt.isValue == false {
            throwErr(&rvt, "Must be a value, not {TOKEN}.")
        } else if rvt.type == TOKEN_TYPE_VAR && rvt.isOper == false {
            tmpV = searchVar(rvt.cont, compilerState.currFnElems)
            if tmpV == null {
                tmpV = searchVar(rvt.cont, elems)
            }
        } else if RCPavailable() && rvt.type == TOKEN_TYPE_FUNC {
            rv = genCompilerVar()
            cType = getCType(tt, elems)
            OUTPUT += rope(cType.str()+" "+rv+"="+rvt.cont+";\n")
        }
        if compTypes(tt, currentFn.returns.type) == false {
            throwErr(&rvt, "Cannot return {TOKEN} ("+tt+") as "+currentFn.returns.type+".")
        }
    }
    if compilerState.isBranch == false {
        currentFn.returned = true
    }

    if strlen(rv) > 0 {
        rvar = rv
        if RCPavailable() == true && isRCPtype(currentFn.returns.type, elems) {
            rvar = genCompilerVar()
            cType = getCType(currentFn.returns.type, elems)
            OUTPUT += rope(cType.str() + " " + rvar + " = "+rv+";\n")
            if tmpV != null && tmpV.outterScope == true {
                OUTPUT += incrVar(tmpV, elems)
            }
        }
        if strHasPrefix(tt, "buffer:") {
            rvar = "__STR("+rvar+")"
        }
        if RCPavailable() {
            excl = []variable*
            j=0; for j < len(currentFn.args), j++ {
                excl[j] = currentFn.args[j]
            }
            if tmpV != null {
                excl[len(excl)] = tmpV
            }
            endRCPscope(elems, excl)
        }
        OUTPUT += rope("return "+rvar+";\n")
    } else {
        if RCPavailable() {
            excl = []variable*
            j=0; for j < len(currentFn.args), j++ {
                excl[j] = currentFn.args[j]
            }
            if tmpV != null {
                excl[len(excl)] = tmpV
            }
            endRCPscope(elems, excl)
        }
        OUTPUT += rope("return;\n")
    }
}

parseIf(l []Tok, elems Elems*) {

    if len(l) < 4 {
        ft = l[0]
        throwErr(&ft, "Invalid usage of {TOKEN}, must be 'if <condition> {<code>}'")
    }
    condt = l[1]
    if condt.bahType != "bool" {
        if condt.bahType != "int" {
            throwErr(&condt, "Cannot use {TOKEN} as condition in if statement.")
        }
    }
    t = l[2]
    if t.cont != "{" {
        throwErr(&t, "Expected '{' not {TOKEN} after condtition in if statement.")
    }
    tokens = []Tok
    max = len(l) - 1
    i=3;for i < max {
        t = l[i]
        tokens[len(tokens)] = t
        i++
    }
    OUTPUT = OUTPUT + rope("if ("+condt.cont+") {\n")

    ifElems = dupElems(elems)

    oldIB = compilerState.isBranch
    compilerState.isBranch = true
    beginRCPscopeLeaky(ifElems)
    parseLines(tokens, ifElems)
    endRCPscopeLeaky(ifElems, null)
    if debug == true {
        lt = l[len(l)-1]
        debugEndScope(lt.line, ifElems)
    }
    compilerState.isBranch = oldIB
    OUTPUT = OUTPUT + rope("}\n")


}

parseElse(l []Tok, elems Elems*) {

    if prevLine != LINE_TYPE_IF {
        if prevLine != LINE_TYPE_ELSE {
            throwErr(&l[0], "Can only use {TOKEN} after 'if' statement.")
        }
    }
    if len(l) < 3 {
        throwErr(&l[0], "Incalid usage of {TOKEN}, must be 'else {<code>}'.")
    }
    ft = l[1]
    OUTPUT = OUTPUT + rope("else ")
    if ft.cont == "if" {
        memory = []Tok
        i=1; for i < len(l) {
            memory[len(memory)] = l[i]
            i++
        }
        parseIf(memory, elems)
        prevLine = LINE_TYPE_IF

    } else {
        if ft.cont != "{" {
            throwErr(&ft, "Expected 'if' or '{' not {TOKEN}.")
        }
        memory = []Tok
        max = len(l) - 1
        i=2; for i < max {
            memory[len(memory)] = l[i]
            i++
        }
        OUTPUT = OUTPUT + rope("{\n")
        ifElems = dupElems(elems)

        oldIB = compilerState.isBranch
        compilerState.isBranch = true
        t = l[0]
        beginRCPscopeLeaky(ifElems)
        parseLines(memory, ifElems)
        endRCPscopeLeaky(ifElems, null)
        if debug == true {
            lt = l[len(l)-1]
            debugEndScope(lt.line, ifElems)
        }
        compilerState.isBranch = oldIB
        OUTPUT = OUTPUT + rope("}\n")
    }

}

#define parseLine(l []Tok, elems Elems*)

parseFor(l []Tok, elems Elems*) {

    if len(l) < 4 {
        throwErr(&l[0], "Invalid usage of {TOKEN}.")
    }

    nbComas = 0
    i=1; for i < len(l) {
        t = l[i]
        if t.cont == "{" {
            break
        }
        if t.type == TOKEN_TYPE_SYNTAX && t.cont == "," {
            if nbComas == 1 {
                throwErr(&t, "Invalid line separation of for, cannot set more than 2 lines: {TOKEN}.")
            }
            nbComas = nbComas + 1
        }
        i = i + 1
    }

    tokens = []Tok
    if nbComas > 0 {
        if nbComas != 1 {
            t = l[0]
            throwErr(&t, "Invalid usage of {TOKEN}, can only partition line in 2 using 'for <condition>, <insctruction> {<code>}'.")
        }

        inst = []Tok
        condt = l[1]

        if condt.bahType != "bool" {
            if condt.bahType != "int" {
                throwErr(&condt, "Cannot use {TOKEN} as condition in for statement.")
            }
        }

        st = l[2]

        if st.type != TOKEN_TYPE_SYNTAX || st.cont != "," {
            throwErr(&st, "Cannot use {TOKEN}, need ',' to split for loop instructions.")
        }

        i=3; for i < len(l), i++ {
            t = l[i]
            if t.type == TOKEN_TYPE_ENCL && t.cont == "{" {
                break
            }
            inst[len(inst)] = t
        }

        oldOut = OUTPUT
        OUTPUT = rope("")

        parseLine(inst, elems)

        instC = string(OUTPUT.toStr())
        OUTPUT = oldOut
        instC.trimRight(2)

        t = l[i]
        if t.cont != "{" {
            throwErr(&t, "Expected '{' not {TOKEN} after '<condition>,<instruction>' in for statement.")
        }

        max = len(l) - 1
        i=i+1;for i < max, i++ {
            t = l[i]
            tokens[len(tokens)] = t
        }

        OUTPUT = OUTPUT + rope("for (; "+condt.cont+"; "+instC.str()+") {\n")

    } else {
        condt = l[1]
        if condt.bahType != "bool" {
            if condt.bahType != "int" {
                throwErr(&condt, "Cannot use {TOKEN} as condition in for statement.")
            }
        }
        t = l[2]
        if t.cont != "{" {
            throwErr(&t, "Expected '{' not {TOKEN} after condtition in for statement.")
        }
        max = len(l) - 1
        i=3;for i < max, i++ {
            t = l[i]
            tokens[len(tokens)] = t
        }
        OUTPUT = OUTPUT + rope("while ("+condt.cont+") {\n")
    }
    oForElems = compilerState.currForElems
    ifElems = dupElems(elems)
    compilerState.currForElems = ifElems

    oldIB = compilerState.isBranch
    oldIF = compilerState.isFor
    compilerState.isBranch = true
    compilerState.isFor = true
    t = l[0]
    beginRCPscopeLeaky(ifElems)
    parseLines(tokens, ifElems)
    endRCPscopeLeaky(ifElems, null)
    if debug == true {
        lt = l[len(l)-1]
        debugEndScope(lt.line, ifElems)
    }
    compilerState.isFor = oldIF
    compilerState.isBranch = oldIB
    compilerState.currForElems = oForElems
    OUTPUT = OUTPUT + rope("};\n")

}

parseForOp(l []Tok, elems Elems*) {

    ft = l[0]
    if compilerState.isFor == false {
        throwErr(&ft, "Cannot {TOKEN} outside of for statement.")
    }
    if len(l) != 1 {
        throwErr(&ft, "Nothing expected after {TOKEN}.")
    }
    //TODO: include outter forloop declared variables incase the keyword is inside a if branch,etc...
    
    endRCPscopeLeaky(elems, null)
    endRCPscopeLeaky(compilerState.currForElems, null)
    OUTPUT = OUTPUT + rope(ft.cont + ";\n")

}

makeEvalFunc(fn func*, elems Elems*) {
    if fn.name in compilerState.evals {
        return
    }

    efn = new func{
        name: "__Bah_eval_"+fn.name
    }
    efn.returns = new variable {
        type: "ptr"
    }

    efn.args = []variable*{
        new variable{
            name: "fnArgs"
            type: "[]ptr"
        }
    }

    fnBinding = ""
    fnCall = fn.name+"("
    i=0; for i < len(fn.args), i++ {
        a = fn.args[i]
        v = genCompilerVar()
        cType = getCType(a.type, elems)
        if isRCPpointerType(a.type) == false {
            cType.append("*")
        }
        fnBinding += cType.str() + " " + v + " = fnArgs->data[" + intToStr(i) + "];"
        if i != 0 {
            fnCall += ", "
        }
        if isRCPpointerType(a.type) {
            fnCall += v
        } else {
            fnCall += "*"+v
        }
    }

    setReturnValue = "void* r = 0;"
    if isRCPpointerType(fn.returns.type) {
        setReturnValue = "void* r = "
    } else {
        cType = getCType(fn.returns.type, elems)
        if cType.str() != "void" {
            setReturnValue = cType.str()+"* r = memoryAlloc(sizeof("+cType.str()+"));*r = "
        }
    }

    OUTPUT += rope("void* __attribute__((optimize(\"O0\"))) "+efn.name+"(array(void*)* fnArgs) {
        if (fnArgs->length != "+intToStr(len(fn.args))+") {
            __BAH_panic((char*)\"eval: calling function "+fn.name+"() with the wrong number of arguments.\", \"BAH_COMPILER_INTERNAL\");
        }
        "+fnBinding+"
        "+setReturnValue+fnCall+");
        return (void*)r;
    };")

    compilerState.evals[len(compilerState.evals)] = fn.name
    elems.fns[len(elems.fns)] = efn
}

parsePreKeyword(l []Tok, elems Elems*) {

    ft = l[0]

    if ft.cont == "#warning" {
        if len(l) != 2 {
            throwErr(&ft, "Invalid usage of {TOKEN} '#warning \"message\"'.")
        }
        mt = l[1]
        if mt.type != TOKEN_TYPE_STR {
            throwErr(&mt, "Cannot use {TOKEN} as a string.")
        }

        msg = string(mt.cont)
        msg.trimLeft(1)
        msg.trimRight(1)


        throwWarning(msg.str())
        return
    }


    if ft.cont == "#eval" {

        if "eval.bah" in compilerState.includes == false {
            if includeFile("eval.bah", elems) == false {
                throwErr(&l[0], "Could not find file 'eval.bah'. Check your bah directory ("+BAH_DIR+").")
            }
        }

        if len(l) != 2 || isGlobal() == false {
            throwErr(&l[0], "Invalid usage of {TOKEN} <#eval fnName>.")
        }

        fnT = l[1]
        fn = searchFunc(fnT.cont, elems, false)
        if fn == null {
            throwErr(&fnT, "Unknown function {TOKEN}.")
        }
        fn.used = true

        makeEvalFunc(fn, elems)

        return
    }

    if ft.cont == "#evalAll" {
        i=0; for i < len(elems.fns), i++ {
            fn = elems.fns[i]
            fn.used = true
            if fn.isBinding == false && strHasPrefix(fn.name, "__Bah_eval_") == false {
                makeEvalFunc(fn, elems)
            }
        }
        return
    }
    
    if len(l) < 3 {
        throwErr(&ft, "Invalid usage of keyword {TOKEN}.")
    }
    
    if ft.cont == "#linux" || ft.cont == "#windows" || ft.cont == "#darwin" {
        isOS = string(ft.cont)
        isOS.trimLeft(1)
        if isOS.str() != BAH_OS {
            return
        }
    } else if ft.cont == "#static" {
        if flags.isSet("d") == 1 {
            return
        }
    } else if ft.cont == "#dynamic" {
        if flags.isSet("d") == 0 {
            return
        }
    } else if ft.cont == "#gc" {
        if RCPavailable() == true {
            return
        }
    } else if ft.cont == "#rcp" {
        if RCPavailable() == false {
            return
        }
    } else if ft.cont == "#lib" {
        if flags.isSet("l") == 0 {
            return
        }
    } else if ft.cont == "#exec" {
        if flags.isSet("l") == 1 {
            return
        }
    } else if ft.cont == "#imported" {
        if isSubObject == false || isObject == false {
            return
        }
    } else if ft.cont == "#included" {
        if isSubObject == true || isObject == true {
            return
        }
    } else {
        throwErr(&ft, "Undefined token {TOKEN}.")
    }

    st = l[1]
    lt = l[len(l)-1]
    if st.cont != "{" || lt.cont != "}" {
        throwErr(&st, "Expected code block after keyword {TOKEN}.")
    }

    nl = []Tok
    i=2; for i < len(l) - 1 {
        nl[i-2] = l[i]
        i = i + 1
    }

    parseLines(nl, elems)

}

parseAsync(l []Tok, elems Elems*) {
    if len(l) != 2 {
        ft = l[0]
        throwErr(&ft, "Cannot use keyword {TOKEN} on a function call 'async <function call>'.")
    }
    fnT = l[1]
    if fnT.isFunc == false {
        throwErr(&fnT, "Cannot use keyword async on {TOKEN}. Usage: 'async <function call>'.")
    }
    
    found = false
    i=0; for i < len(compilerState.cLibs) {
        if compilerState.cLibs[i] == "lpthread" {
            found = true
            break
        }
        i = i + 1
    }
    if found == false {
        compilerState.cLibs[len(compilerState.cLibs)] = "lpthread"
    }

    sFnT = string(fnT.cont)
    
    fnNameParts = splitString(sFnT, "(")
    fnName = fnNameParts[0]

    fn = searchFunc(fnName.str(), elems, true)
    
    if fn == null {
        throwErr(&fnT, "Internal compiler error.\n Error parsing async call for function '"+fnName.str()+"', arround {TOKEN}.")
    }
    sMembs = ""
    unSerMembs = ""
    
    i=0; for i < len(fn.args) {
        a = fn.args[i]
        cType = getCType(a.type, elems)
        sMembs = sMembs + cType.str()+" "+a.name+";\n"
        unSerMembs = unSerMembs + "args->"+a.name
        i = i + 1
        if i < len(fn.args) {
            unSerMembs = unSerMembs + ", "
        }
    }

    tmpArgsStruct = "struct {\n"+sMembs+"}"
    fnWrapper = genCompilerVar()
    tmpArgs = genCompilerVar()

    sFnT.trimLeft(fnName.length+1)
    sFnT.trimRight(1)

    tCreate = ""
    if BAH_OS == "windows" {
        tCreate = "pthread_create"
    } else {
        if RCPavailable() {
            tCreate = "pthread_create"
        } else {
            tCreate = "GC_pthread_create"
        }
    }

    OUTPUT = OUTPUT + rope("
    void "+fnWrapper+"("+tmpArgsStruct+"* args) {
        "+fnName.str()+"("+unSerMembs+");
    };
    {
        "+tmpArgsStruct+" "+tmpArgs+" = {"+sFnT.str()+"};
        pthread_t id;
        "+tCreate+"(&id, 0, "+fnWrapper+", &"+tmpArgs+");
    }; 
    
    ")
}

addRCPvars(l []Tok, ltp lineType, elems Elems*) {
//     recorder = timer.record("addRCPvars")
    i=0
    if ltp == LINE_TYPE_VAR {
        i = 1
    }
    for i < len(l) {
        t = l[i]
        if t.type == TOKEN_TYPE_VAR && t.isOper == false {
            v = searchVarByToken(t, elems)
            if v != null {
                compilerState.RCPvars[len(compilerState.RCPvars)] = v
            }
        }
        i = i + 1
    }

}


parseChan(l []Tok, elems Elems*) []Tok {
//     recorder = timer.record("parseChan")
    nl = []Tok
    i=0; for i < len(l), i++ {
        t = l[i]
        if t.type == TOKEN_TYPE_SYNTAX && t.cont == "->" || t.cont == "<-" {
            //receive
            if t.cont == "<-" {
                i++
                if i < len(l) {
                    nt = l[i]
                    if nt.type != TOKEN_TYPE_VAR {
                        throwErr(&nt, "Cannot use {TOKEN} as channel.")
                    }
                    ntt = string(getTypeFromToken(&nt, true, elems))
                    if ntt.hasPrefix("chan:") == 0 {
                        throwErr(&nt, "Cannot use var {TOKEN} ("+ntt.str()+") as channel.")
                    }
                    ntt.trimLeft(5)

                    if isGlobal() {
                        throwErr(&t, "Cannot receive ({TOKEN}) from a channel outside of a function.")
                    }

                    tmpV = ""

                    if isRCPpointerType(ntt.str()) {
                        ct = getCType(ntt.str(), elems)
                        t.cont = "("+ct.str()+")"+nt.cont+"->receive("+nt.cont+")"
                    } else {
                        ct = getCType(ntt.str(), elems)
                        if RCPavailable() {
                            tmpV = registerRCPvar(ntt.str()+"*", "("+ct.str()+"*)"+nt.cont+"->receive("+nt.cont+")", elems)
                            t.cont = "*"+tmpV
                        } else {
                            t.cont = "*("+ct.str()+"*)"+nt.cont+"->receive("+nt.cont+")"
                        }
                    }
                    t.type = TOKEN_TYPE_FUNC
                    t.isFunc = true

                    if RCPavailable() {
                        if isRCPpointerType(ntt.str()) {
                            tmpV = registerRCPvar(ntt.str(), t.cont, elems)
                            t.type = TOKEN_TYPE_VAR
                            t.isFunc = false
                            t.cont = tmpV
                        } else {

                        }
                    }

                    t.isValue = true
                    t.bahType = ntt.str()
                } else {
                    throwErr(&t, "Cannot use {TOKEN} on nothing")
                }
            } else { //send
                if i == 0 {
                    throwErr(&t, "Cannot une {TOKEN} on nothing.")
                }
                if i+1 >= len(l) {
                    throwErr(&t, "Cannot send ({TOKEN}) to nothing.")
                }
                pt = l[i+1]
                nt = l[i-1]
                ntt = getTypeFromToken(&nt, true, elems)

                if pt.type != TOKEN_TYPE_VAR {
                    throwErr(&pt, "Cannot use {TOKEN} as channel.")
                }
                ptt = string(getTypeFromToken(&pt, true, elems))
                if ptt.hasPrefix("chan:") == 0 {
                    throwErr(&pt, "Cannot use var {TOKEN} ("+ntt+") as channel.")
                }
                ptt.trimLeft(5)

                if isGlobal() {
                    throwErr(&t, "Cannot send ({TOKEN}) to a channel outside of a function.")
                }

                if compTypes(ptt.str(), ntt) == false {
                    throwErr(&nt, "Cannot send {TOKEN} ("+ntt+") to channel of type "+ptt.str()+".")
                }

                i++
                if isRCPpointerType(ptt.str()) {
                    OUTPUT = OUTPUT + rope(pt.cont+"->send("+pt.cont+", "+nt.cont+");\n")
                } else {
                    ct = getCType(ntt, elems)
                    tmpV = genCompilerVar()
                    OUTPUT = OUTPUT + rope("
                    "+ct.str()+" "+tmpV+" = "+nt.cont+";
                    "+pt.cont+"->sendAny("+pt.cont+", &"+tmpV+", sizeof("+tmpV+"));\n")
                }

                nl = []Tok
                return nl
            }
        }
        nl[len(nl)] = t
    }
    return nl
}

#include "values.bah"

prePross(line []Tok, ltp lineType, elems Elems*) []Tok {
//     recorder = timer.record("prePross")
    fl = []Tok
    i = 0
    sepI = 0
    nbPar = 0

    if ltp != <lineType>-1 {
        for i < len(line) {
            t = line[i]
            if t.cont == "(" {
                isFunc = true
                nbPar = nbPar + 1
            } else if t.cont == ")" {
                nbPar = nbPar - 1
            } else if nbPar == 0 && t.cont == "{" {
                nt = line[i+1]
                isStructType = true
                if nt.line != t.line {
                    break
                }
            }

            fl[len(fl)] = t
            i++
        }
        sepI = i
    } else {
        isStruct = true
        isFunc = true
        isChan = true
        isArr = true
        isBool = true
        isOper = true
        isCast = true

        needGuard = true

        fl = line
    }

    // print("from: ");debugLine(fl)
    pt = Tok{}
    l = len(fl)

    i=0; for i < len(fl), i++ {
        t = fl[i]
        if i > 0 {
            pt = fl[i-1]
        } else {
            pt = Tok{}
        }
        //parse struct values
        if t.cont == "." && i > 0 {
            i = valueStruct(fl, i, ltp, elems) - 1
        } else if t.cont == "(" && pt.cont != "function" {
            i = valueFunc(null, null, fl, i, ltp, elems) - 1
        } else if t.cont == "[" && pt.isValue == true {
            i = valueArr(fl, i, ltp, elems) - 1
        } else if pt.type == TOKEN_TYPE_CAST && isSmallValue(fl, i) {
            delete(fl, i-1)
            ptc = string(pt.cont)
            ptc.trimLeft(1)
            ptc.trimRight(1)
            t.bahType = ptc.str()
            cType = getCType(ptc.str(), elems)
            t.cont = "("+cType.str()+")"+t.cont
            fl[i-1] = t
            i -= 2
        } else if inArrayStr(pt.cont, signs)  {
            if t.cont == pt.cont && i > 1 {
                ppt = fl[i-2]
                if ppt.type == TOKEN_TYPE_VAR {
                    posTok = i-2
                    delete(fl, i-1)
                    delete(fl, i-1)
                    ppt.cont += t.cont + t.cont
                    ppt.isValue = true
                    ppt.isOper = true
                    fl[posTok] = ppt
                    i = posTok-1
                } else {
                    throwErr(&ppt, "Cannot increment/decrement non variable value {TOKEN}.")
                }
            } else if isValue(fl, i) {
                i = valueOper(fl, i, elems) - 1
            }
        } else if t.cont[0] == '-' && pt.isValue == true {
            // debugLine(fl)
            if t.type == TOKEN_TYPE_INT || t.type == TOKEN_TYPE_FLOAT {
                delete(fl, i)
                ptt = getTypeFromToken(&pt, true, elems)
                pt.bahType = ptt
                pt.isOper = true
                pt.cont += t.cont
                fl[i-1] = pt
                i--
            }
        } else if inArrayStr(pt.cont, comparators) && isValue(fl, i) {
            i = valueBool(fl, i, elems) - 1
        } else if pt.cont == "<-" && isValue(fl, i) {
            i = valueChan(fl, i, elems) - 1
        } else if pt.cont == "->" && isValue(fl, i) {
            if i-2 >= 0 {
                if isValue(fl, i-2) {
                    i = valueSendChan(fl, i, elems) - 1
                }
            } else {
                throwErr(&t, "Cannot {TOKEN} nothing through chan.")
            }
        }
    }


    i=0; for i < len(fl), i++ {
        t = fl[i]
        if t.cont == "||" || t.cont == "&&" {
            if i == 0 || i+1 == len(fl) {
                throwErr(&t, "Cannot use {TOKEN} on nothing.")
            }
            pt = fl[i-1]
            nt = fl[i+1]
            ptt = getTypeFromToken(&pt, true, elems)
            ntt = getTypeFromToken(&nt, true, elems)
            if compTypes(ptt, ntt) == false || compTypes(ptt, "bool") == false {
                throwErr(&t, "Cannot use {TOKEN} on "+ptt+".")
            }
            pt.cont += t.cont+nt.cont
            fl[i-1] = pt
            delete(fl, i)
            delete(fl, i)
            i -= 2
        } else if t.type == TOKEN_TYPE_VAR && t.bahType != "" {
            if t.cont[0] == '&' {
                t.bahType += "*"
                fl[i] = t
            } else if t.cont[0] == '*' {
                tt = string(t.bahType)
                tt.replace("*", "")
                t.bahType = tt.str()
                fl[i] = t
            }
        }
    }

    fl = parseArrayType(fl, elems, true)
    addRCPvars(fl, ltp, elems)
    // fl = parseChan(fl, elems)

    if ltp != <lineType>-1 {
        for sepI < len(line) {
            fl[len(fl)] = line[sepI]
            sepI++
        }
    }


    return fl
}

parseFnDeclare(l []Tok, elems Elems*) {
    i = 0
    fn = new func

    if RCPavailable() == false && RCPenabled == true { //currently parsing a rcp file
        fn.used = true
    }

    ft = l[0]
    code = parseFnHeader("", l, &i, fn, elems)
    fn.line = ft.line
    fn.file = compilerState.currentFile
    ogFn = searchFunc(fn.name, elems, false)
    if ogFn != null {
        if ogFn.isBinding == false {
            lineStr = intToStr(ogFn.line)
            throwErr(&ft, "Cannot redeclare function {TOKEN}, previous declaration: "+ogFn.file+":"+lineStr+".")
        }
    }

    if fn.name == "main" {
        compilerState.haveEntryPoint = true
        if compTypes(fn.returns.type, "int") == false {
            throwErr(&ft, "{TOKEN} function should return 'int'.")
        }
        if len(fn.args) != 1 {
            throwErr(&ft, "{TOKEN} function should take one []cpstring argument. Should be: 
            'main(args []cpstring) int'")
        }
        fa = fn.args[0]
        if compTypes(fa.type, "[]cpstring") == false {
            throwErr(&ft, "{TOKEN} function should take []cpstring as argument. Should be: 
            'main(args []cpstring) int'")
        }
    }

    if shouldOnlyDecl == true {
        if ogFn != null {
            fn.isBinding = false
        }
        elems.fns[len(elems.fns)] = fn
        OUTPUT = OUTPUT + rope(code+";\n")
        return
    }

    code = code + "{\n"

    fn.code = rope(code)


    fnElems = dupElems(elems)
    
    vs = fnElems.vars
    j=0; for j < len(fn.args) {
        a = fn.args[j]
        a.outterScope = true
        vs[len(vs)] = a
        j =j + 1
    }
    fnElems.vars = vs
    
    if ogFn != null {
        ogFn.isBinding = false
        ogFn.used = true
        ogFn = fn
    } else {
        fns = elems.fns
        fns[len(fns)] = fn
    }

    tokens = []Tok
    i++
    max = len(l)-1
    for i < max {
        t = l[i]
        tokens[len(tokens)] = t
        i++
    }

    if len(tokens) == 0 {
        fn.code += rope("};\n")
        OUTPUT = OUTPUT + fn.code
        return
    }

    currentFn = fn

    oOut = OUTPUT
    OUTPUT = rope("")
    t = tokens[0]
    beginRCPscope(fnElems, fn.args)
    ocurrFnElems = compilerState.currFnElems
    compilerState.currFnElems = fnElems
    parseLines(tokens, fnElems)
    compilerState.currFnElems = ocurrFnElems
    
    currentFn = null
    if fn.returned == false {
        if strlen(fn.returns.type) > 0 {
            throwErr(&l[len(l)-1], "Function '"+fn.name+"' is not returned.")
        }
        endRCPscope(fnElems, fn.args)
        // decrRCPstackVars(fn.args, elems)
    }

    fn.code += OUTPUT
    OUTPUT = oOut
    fn.code += rope("};\n")


    OUTPUT += fn.code

    if debug == true {
        df = new debugFunction
        df.name = fn.name
        df.args = fn.args
        df.returns = fn.returns.type
        debugPrint("fn_declare", ft.line, df)
        lt = l[len(l)-1]
        debugEndScope(lt.line, fnElems)
    }

}


//Handling lines

parseLine(line []Tok, elems Elems*) {

    if len(line) == 0 {
        return
    }
    line = parsePointers(line)
    ltp = getLineType(line)

    compilerState.RCPvars = []variable*
    currSetVar = null

    if ltp == LINE_TYPE_VAR && len(line) > 1 {
        ft = line[0]
        st = line[1]
        if st.cont == "=" {
            v = searchVar(ft.cont, elems)
            currSetVar = v
        }
    }
    
    parsed = false
    if ltp == LINE_TYPE_INCLUDE {
        parsed = true
        parseInclude(line, elems)
    } else if ltp == LINE_TYPE_IMPORT {
        parsed = true
        parseImport(line, elems)
    } else if ltp == LINE_TYPE_DEFINE {
        parsed = true
        parseDefine(line, elems)
    } else if ltp == LINE_TYPE_CLIB {
        parsed = true
        parseClib(line)
    } else if ltp == LINE_TYPE_STRUCT {
        parsed = true
        parseStruct(line, elems)
    } else if ltp == LINE_TYPE_CONST {
        parsed = true
        parseConst(line, elems)
    } else if ltp == LINE_TYPE_MACRO {
        return
    } else if ltp != LINE_TYPE_FN_DECL {
        line = prePross(line, ltp, elems)
        if len(line) == 0 {
            return
        }
    }

    ft = line[0]
    if ft.isOper == false && ft.isFunc == true {
        fn = searchFuncByToken(ft, elems)
        if fn != null && fn.returns != null && isRCPtype(fn.returns.type, elems) {
            registerRCPvar(fn.returns.type, ft.cont, elems)
            return
            // println("carefull: "+compilerState.currentFile+":"+intToStr(ft.line))
        }
    }

    if ltp == LINE_TYPE_VAR {
        parsed = true
        parseVar(line, elems)
    } else if ltp == LINE_TYPE_FN_CALL {
        if len(line) > 1 {
            throwErr(&line[len(line)-1], "Not expecting {TOKEN} after function call.")
        }
        parsed = true
        OUTPUT = OUTPUT + rope(ft.cont + ";\n")
    } else if ltp == LINE_TYPE_FN_DECL {
        parsed = true
        parseFnDeclare(line, elems)
    } else if ltp == LINE_TYPE_RETURN {
        parsed = true
        parseReturn(line, elems)
    } else if ltp == LINE_TYPE_IF {
        parsed = true
        parseIf(line, elems)
    } else if ltp == LINE_TYPE_ELSE {
        parsed = true
        parseElse(line, elems)
    } else if ltp == LINE_TYPE_FOR {
        parsed = true
        parseFor(line, elems)
    } else if ltp == LINE_TYPE_FOR_OPERATOR {
        parsed = true
        parseForOp(line, elems)
    } else if ltp == LINE_TYPE_PRE_KEYWORD {
        parsePreKeyword(line, elems)
        parsed = true
    } else if ltp == LINE_TYPE_ASYNC {
        parseAsync(line, elems)
        parsed = true
    }
    
    if parsed == false{
        throwErr(&ft, "{TOKEN} not expected.")
    }

    if strlen(NEXT_LINE) > 0 {
        OUTPUT = OUTPUT + rope(NEXT_LINE)
        NEXT_LINE = ""
    }
    prevLine = ltp


}

parseLines(tokens []Tok, elems Elems*) {

    if len(tokens) == 0 {
        return
    }
    line = []Tok
    ft = tokens[0]
    currentLine = ft.line
    nbEncl = 0
    i=0; for i < len(tokens) {
        t = tokens[i]
        
        if t.type == TOKEN_TYPE_ENCL {
            if t.cont == "(" {
                nbEncl =nbEncl + 1
            } else if t.cont == ")" {
                nbEncl =nbEncl - 1
            } else if t.cont == "{" {
                nbEncl =nbEncl + 1
            } else if t.cont == "}" {
                nbEncl =nbEncl - 1
            } else if t.cont == "[" {
                nbEncl =nbEncl + 1
            } else if t.cont == "]" {
                nbEncl =nbEncl - 1
            }
        }

        if t.type == TOKEN_TYPE_STR && t.begLine == currentLine {
            currentLine = t.line
        }

        if nbEncl == 0 {
            if t.line != currentLine {
                if t.type == TOKEN_TYPE_ENCL {
                    line[len(line)] = t
                    pt = tokens[i-1]
                    currentLine = pt.line
                } else {
                    currentLine = t.line
                }
                parseLine(line, elems)
                clear(line)
                if t.type == TOKEN_TYPE_ENCL {
                    i++
                    continue
                }
            } else if t.cont == ";" {
                currentLine = t.line
                parseLine(line, elems)
                clear(line)
                i++
                continue
            }
        }

        line[len(line)] = t
        i++
    }

    if len(line) > 0 {
        if nbEncl == 0 {
                parseLine(line, elems)
                clear(line)
        } else {
            ft = line[len(line)-1]
            throwErr(&ft, "Missing closing token, line ending by {TOKEN}.")
        }
    }


}

