checkCanBeNull(t Tok*, tt cpstring, elems Elems*) {
    if isUnsafe == false && string(compilerState.currentDir).hasPrefix(BAH_DIR) == false && isRCPpointerType(tt) && t.cont[0] != '&' && t.cont[0] != '*' {
        sv = searchVarByToken(t, elems)
        if sv != null {
            if sv.canBeNull == true && checkedNotNull(sv.name, elems) == false {
                globCheck = ""
                s = searchStruct(sv.type, elems)
                if sv.isGlobal == true && s != null {
                    globCheck = " or declare the var as 'new "+s.name+"'."
                }
                throwErr(t, "{TOKEN} can contain a null value. Check if the value is null"+globCheck+".")
            }
        }
    }
}

setNullStateBranchFlowEnd(elems Elems*) {
    if currentFn == null {
        return
    }
    if compilerState.isBranch == false {
        if currentFn.couldAlreadyReturn == false {
            currentFn.exits = true   
        }
    } else {
        i=0; for i < len(elems.branchChecks), i++ {
            bc = elems.branchChecks[i]
            if bc.v == null {
                continue
            }
            if bc.checkNull == true {
                j=0; for j < len(elems.parent.vars), j++ {
                    pv = elems.parent.vars[j]
                    if pv.name == bc.v.name {
                        pv.canBeNull = false
                        break
                    }
                }
            }
        }
        if prevLine == LINE_TYPE_IF && prevIfExits == true {
            currElems = elems; for currElems != null, currElems = currElems.parent {
                i=0; for i < len(currElems.branchChecks), i++ {
                    bc = currElems.branchChecks[i]
                    if bc.v == null {
                        continue
                    }
                    if bc.checkNull == true {
                        j=0; for j < len(currElems.parent.vars), j++ {
                            pv = currElems.parent.vars[j]
                            if pv.name == bc.v.name {
                                pv.canBeNull = false
                                break
                            }
                        }
                    }
                }
            }
        }
        prevIfExits = true
    }
}

fixMeEnabled() bool {
    if isFixMeEnabled == false {
        return false
    }
    return isInside(BAH_DIR, compilerState.currentDir) == false
}

fixMeRegisterVar(v variable*, t Tok*) {
    if v.isReg == true {
        return
    }
    name = v.name
    if isRCPpointerType(v.type) == false {
        name = "&"+name
    }
    NEXT_LINE += "
    fixMeAddVar(\""+v.name+"\", "+name+", \""+compilerState.currentFile+":"+intToStr(t.line)+"\");
    "
}

fixMeEndScope(elems Elems*, t Tok*) {
    if fixMeEnabled() == false {
        return
    }
    i=0; for i < len(elems.vars), i++ {
        v = elems.vars[i]
        if v.declScope == elems {
            if v.isReg == true {
                return
            }
            name = v.name
            if isRCPpointerType(v.type) == false {
                name = "&"+name
            } else {
                continue
            }
            OUTPUT += rope("
            fixMeRemVar(\""+v.name+"\", "+name+", \""+compilerState.currentFile+":"+intToStr(t.line)+"\");
            ")
        }
    }
}

fixMeTestVar(t Tok*, ltp lineType, elems Elems*) {
    if fixMeEnabled() == false {
        return
    }


    name = t.cont
    tt = getTypeFromToken(t, true, elems)
    if isRCPtype(tt, elems) == false {
        return
    }
    if isRCPpointerType(tt) == false {
        if name[0] == '*' {
            name = name[1:]
        } else {
            name = "&"+name
        }
    }

    if t.type == TOKEN_TYPE_FUNC || t.isOper == true || t.isFunc == true {
        name = registerRCPvar(tt, t.cont, elems)
        t.cont = name
    }

    fn = "fixMeIsVarOk("+name+", \""+t.cont+"\", \""+compilerState.currentFile+":"+intToStr(t.line)+"\")"
    
    if ltp == LINE_TYPE_ELSE {
        prevIfShortcut = fn+"&&"
        return
    }

    OUTPUT += rope(fn+";\n")
}

isStaticToken(t Tok*, elems Elems*) bool {
    if t.type == TOKEN_TYPE_BOOL && (t.cont != "true" || t.cont != "false") {
        return false
    }

    if t.type == TOKEN_TYPE_FUNC {
        return false
    }

    if t.type == TOKEN_TYPE_VAR {
        if t.isOper == true {
            return false
        }
        v = searchVirtVarByToken(t, elems)
        if v != null {
            return v.isConst
        }
    }

    return true
}