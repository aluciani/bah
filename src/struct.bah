#include "./globals.bah"

hasStructSep(n string*) bool {
    max = n.length - 1
    i=0; for i < max, i++ {
        c = n.charAt(i)
        if c == '.' {
            return true
        } else if c == '-' && n.charAt(i+1) == '>' {
            return true
        }
    }
    
    return false
}

splitStructSepBefore(n string*) string {
    
    if n.count(".") {
        res = string(splitStringBefore(*n, "."))
        return res
    }
    if n.count("->") {
        res = string(splitStringBefore(*n, "->"))
        return res
    }

    return string("")
}

splitStructSepAfter(n string) string {
    i=n.length; for i > 0 {
        c = n.charAt(i)
        if c == '.' {
            break
        } else if c == '>' {
            pc = n.charAt(i-1)
            if pc == '-' {
                break
            }
        }
        i = i - 1
    }
    i = i + 1
    n.trimLeft(i)
    return n
}


searchStruct(name cpstring, elems Elems*) cStruct* {
    if len(name) == 0 {
        return null
    }

    //Removing *
    i=0; for i < len(name), i++ {
        if name[len(name)-i-1] != '*' {
            break
        }
    }
    if i != 0 {
        name = name[:len(name)-i]
    }

    i=len(elems.structs)-1; for i != -1, i-- {
        s = elems.structs[i]
        if s.name == name {
            return s
        }
    }
    return null
}

searchStructMemb(name cpstring, s cStruct*, elems Elems*) structMemb* {
    n = string(name)
    if hasStructSep(&n) {
        rn = splitStructSepBefore(&n)
        name = rn.content
        if n.charAt(rn.length) == '.' {
            n.trimLeft(1 + rn.length)
        } else {
            n.trimLeft(2 + rn.length)
        }
        membs = n.content
        memb = searchStructMemb(name, s, elems)
        if n.length > 0 {
            s = searchStruct(memb.type, elems)
            nstr = n.str()
            memb = searchStructMemb(nstr, s, elems)
        }
        return memb
        
    }
    members = s.members
    i=0; for i < len(members) {
        m = members[i]
        if m.name == name {
            return m
        }
        i = i + 1
    }
    mthds = s.methods
    i=0; for i < len(mthds) {
        m = mthds[i]
        if m.name == name {
            sm = new structMemb
            sm.name = m.name
            sm.from = m.from
            sm.type = m.returns.type
            sm.isFn = true
            return sm
        }
        i = i + 1
    }

    if len(s.extendedFrom) == 0 {
        return null
    }

    es = searchStruct(s.extendedFrom, elems)
    if es == null {
        return null
    }
    
    return searchStructMemb(name, es, elems)
}

#define searchFunc(n cpstring, e Elems*, c bool) func*
#define parseFnType(n string) func*

searchStructMethod(name cpstring, s cStruct*, elems Elems*) func* {
    if s == null {
        return null
    }

    fn = searchFunc(s.name+"__"+name, elems, true)
    if fn != null {
        return fn
    }

    i=0; for i < len(s.members), i++ {
        // m = s.members[i]
        if s.members[i].name == name {
            fn = parseFnType(string(s.members[i].type))
            fn.name = name
            fn.isVar = true
            return fn
        }
    }

    s = searchStruct(s.extendedFrom, elems)

    return searchStructMethod(name, s, elems)
}