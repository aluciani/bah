valueFunc(fn func*, parent variable*, l []Tok, i int, ltp lineType, elems Elems*) int {
    tokPos = i

    generic genericFunc*

    //if not defined func, go find it before in the line
    errPos = -1
    if fn == null {
        if i > 0 {
            tokPos = i-1
            pt = l[tokPos]
            if pt.type == TOKEN_TYPE_VAR {
                delete(l, tokPos)
                errPos = pt.pos
                fn = searchFunc(pt.cont, elems, true)
                if fn == null {
                    j=0; for j < len(generics), j++ {
                        if generics[j].baseFn.name == pt.cont {
                            generic = generics[j]
                            fn = generics[j].dupBaseFn()
                            break
                        }
                    }
                    if j == len(generics) {
                        throwErr(&pt, "Unknown func {TOKEN}.")
                    }
                }
            } else {
                tokPos++
            }
        } else {
            return i
        }
    }

    fnt = l[tokPos]
    if errPos != -1 {
        fnt.pos = errPos
    }


    //only have parenthesis
    if fn == null {
        nbEncls = 1
        memory = []Tok
        i = tokPos+1
        fnt.ogCont = "("
        for i < len(l), i++ {
            t = l[i]
            fnt.ogCont += t.ogCont
            if t.cont == "(" || t.cont == "{" || t.cont == "[" {
                nbEncls++
            } else if t.cont == ")" || t.cont == "}" || t.cont == "]" {
                nbEncls--
                if nbEncls == 0 {
                    break
                }
            }
            memory[len(memory)] = t
        }
        deleteRange(l, tokPos+1, i)
        memort = prePross(memory, <lineType>-1, elems)
        ft = memory[0]
        fnt.cont = "("
        fnt.isOper = true
        fnt.isValue = true
        fnt.bahType = getTypeFromToken(&ft, true, elems)
        j=0; for j < len(memory), j++ {
            t = memory[j]
            fnt.cont = fnt.cont + t.cont
        }
        fnt.cont += ")"
        l[tokPos] = fnt
        return tokPos
    }

    //checks if the program should be running after the execution of this function
    if fn.name == "exit" || fn.exits == true {
        setNullStateBranchFlowEnd(elems)
    }

    //making the return token
    fnt.cont = fn.name + "("
    if fn.returns != null && fn.returns.type != "" {
        fnt.isValue = true
        fnt.bahType = fn.returns.type
    }
    fnt.isFunc = true
    fnt.type = TOKEN_TYPE_FUNC

    //pre-processing arguments
    nbEncls = 1
    memory = []Tok
    i = tokPos+1
    fnt.ogCont = fn.name+"("
    for i < len(l), i++ {
        t = l[i]
        fnt.ogCont += t.ogCont
        if t.cont == "(" || t.cont == "{" || t.cont == "[" {
            nbEncls++
        } else if t.cont == ")" || t.cont == "}" || t.cont == "]" {
            nbEncls--
            if nbEncls == 0 {
                break
            }
        }
        memory[len(memory)] = t
    }
    deleteRange(l, tokPos+1, i)

    //noCheck (for c lang in bah)
    if fn.name == "noCheck" {
        fnt.cont = ""
        fnt.isOper = true
        fnt.isValue = true
        fnt.bahType = "ptr"
        j=0; for j < len(memory), j++ {
            t = memory[j]
            fnt.cont = fnt.cont + t.cont
        }
        l[tokPos] = fnt
        return tokPos
    }
    //special functions
    currLine = "\""+compilerState.currentFile + ":" + intToStr(fnt.line)+"\""
    if fn.name == "panic" {
        memory[len(memory)] = Tok {
            type: TOKEN_TYPE_SYNTAX
            cont: ","
            line: fnt.line
        }
        memory[len(memory)] = Tok {
            type: TOKEN_TYPE_STR
            cont: currLine
            line: fnt.line
        }
        fn = searchFunc("__BAH_panic", elems, true)
        fnt.cont = fn.name + "("
    } else if fn.name == "__dumpSymbols" {
        symbols = []variable*
        j=0; for j < len(elems.vars), j++ {
            v = elems.vars[j]
            if v.isConst == false {
                symbols[len(symbols)] = v
            }
        }
        tmpV = new variable {
            name: genCompilerVar()
            type: "[]reflectElement"
            isArray: true
        }
        decls = ""
        j=0; for j < len(symbols), j++ {
            v = symbols[j]
            vname = v.name
            if strCount(v.type, "*") == 0 {
                vname = "&"+v.name
            }
            tmpT = Tok{
                type: TOKEN_TYPE_VAR
                cont: vname
                bahType: v.type
                isValue: true
            }
            tmpT = parseReflect(tmpT, v.type, elems, true, v.name, "0")
            decls += tmpV.name+"->data["+intToStr(j)+"] = " + tmpT.cont + ";\n"
        } 
        elems.vars[len(elems.vars)] = tmpV
        OUTPUT = OUTPUT + rope("
        array(struct reflectElement)* "+tmpV.name+" = memoryAlloc(sizeof(array(struct reflectElement)));
        "+tmpV.name+"->data = memoryAlloc(sizeof(struct reflectElement) * "+intToStr(len(symbols))+");
        "+tmpV.name+"->length = "+intToStr(len(symbols))+";
        "+tmpV.name+"->elemSize = sizeof(struct reflectElement);
        "+decls+"
        ")
        memory[0] = Tok{
            type: TOKEN_TYPE_VAR
            cont: tmpV.name
            line: fnt.line
            isValue: true
        }
    } else if fn.name == "breakPoint" {
        memory = []Tok{
            Tok{
                type: TOKEN_TYPE_VAR
                cont: "__dumpSymbols"
                line: fnt.line
            },
            Tok{
                type: TOKEN_TYPE_SYNTAX
                cont: "("
                line: fnt.line
            },
            Tok{
                type: TOKEN_TYPE_SYNTAX
                cont: ")"
                line: fnt.line
            }
        }
        memory = prePross(memory, LINE_TYPE_FN_CALL, elems)
        memory[len(memory)] = Tok{
            type: TOKEN_TYPE_SYNTAX
            cont: ","
            line: fnt.line
        }
        memory[len(memory)] = Tok{
            type: TOKEN_TYPE_STR
            cont: currLine
            line: fnt.line
        }
        fn = searchFunc("breakPoint__inner", elems, true)
        fnt.cont = fn.name + "("
    } else if fn.name == "sizeof" {
        tp = ""
        j=0; for j < len(memory), j++ {
            tmpT = memory[j]
            tp += tmpT.cont
        }
        cType = getCType(tp, elems)
        fnt.cont += cType.str()+")"
        fnt.type = TOKEN_TYPE_FUNC
        fnt.isFunc = true
        fnt.bahType = "int"
        fnt.bahRef = fn
        l[tokPos] = fnt
        return tokPos
    }

    //processing memory (arguments)
    if len(memory) > 0 {
        memory = prePross(memory, <lineType>-1, elems)
    }

    argIndex = 0
    if parent != null { //adding parent var for method calls
        amp = "&"
        if isRCPpointerType(parent.type) {
            amp = ""
        }
        fnt.cont += amp + parent.name
        argIndex++
        if len(fn.args) > argIndex {
            fnt.cont += ","
        }
    }

    // if fn.name == "strlen" && len(memory) == 1 {
    //     if cont != "" {
    //         fnt.cont = memory[0].cont
    //         fnt.type = TOKEN_TYPE_VAR
    //         fnt.bahType = "int"
    //         l[tokPos] = fnt
    //         return tokPos
    //     }
    // }

    ogFntContL = strlen(fnt.cont)

    // parsing arguments
    j=0; for j < len(memory), j++ {
        t = memory[j]
        if argIndex == len(fn.args) {
            throwErr(&t, "Too many arguments, expected ')' not {TOKEN}.")
        }
        arg = fn.args[argIndex]
        tt = getTypeFromToken(&t, true, elems)

        if arg.type == "reflectElement" && tt != "reflectElement" {
            t = parseReflect(t, tt, elems, false, t.cont, "0")
            tt = "reflectElement"
        }

        if generic != null && arg.type == "<any>" {
            arg.type = tt
            tts = string(tt)
            tts.replace("*", "_AST_")
            tts.replace(":", "_DP_")
            tts.replace("[]", "_ARR_")
            fn.name += "__" + tts.str()
        } else {
            if compTypes(arg.type, tt) == false {
                throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+arg.type+" in function call.")
            }
        }

        checkCanBeNull(&t, tt, elems)

        if RCPavailable() == true && ltp == LINE_TYPE_VAR && t.type == TOKEN_TYPE_VAR && t.isOper == false && currSetVar != null && t.cont == currSetVar.name && isRCPtype(currSetVar.type, elems) {
            OUTPUT += incrVar(currSetVar, elems)
        }

        if t.type == TOKEN_TYPE_FUNC {
            afn = searchFuncByToken(&t, elems)
            if afn != null && isRCPtype(afn.returns.type, elems) == true {
                t.cont = registerRCPvar(afn.returns.type, t.cont, elems)
            }
        }

        fnt.cont += t.cont

        argIndex++

        if j+1 < len(memory) {
            j++
            t = memory[j]
            if t.cont != "," {
                throwErr(&t, "Need separator between arguments, not {TOKEN}.")
            }
            fnt.cont += ","
        }

    }

    if argIndex != len(fn.args) {
        lt = l[tokPos]
        throwErr(&lt, "Not enough argument {TOKEN}, calling '"+fn.name+"'.")
    }

    if generic != null {
        fnt.cont = "__generic_" + fn.name + "(" + fnt.cont[ogFntContL:]
        if generic.isAlreadyDecl(fn.name) == false {
            generic.declare(fn, elems)
        }
    }

    fnt.bahRef = fn
    fnt.cont += ")"
    l[tokPos] = fnt
    return tokPos

}

valueStruct(l []Tok, i int, ltp lineType, elems Elems*) int {
    tokPos = i-1
    // delete(l, i)

    //is prev token a struct type
    t = l[i-1]
    tt = getTypeFromToken(&t, true, elems)
    s = searchStruct(tt, elems)
    if s == null {
        if tt[strlen(tt)-1] == '!' {
            throwErr(&t, "Cannot use maybe value {TOKEN} ("+tt+") as structure.")
        } else {
            throwErr(&t, "Unkown struct {TOKEN} ("+tt+").")
        }
    }

    checkCanBeNull(&t, tt, elems)

    //is next token a member name
    nt = l[i+1]
    // delete(l, i)
    if nt.isValue == false {
        throwErr(&nt, "Cannot use {TOKEN} as member.")
    }
    deleteRange(l, i, i+1)

    //get appropriate C-separator
    sep = "."
    if isRCPpointerType(tt) {
        sep = "->"
    }

    //member is a method
    if i < len(l) {
        ntt = l[i]
        if ntt.cont == "(" {
            parent variable*
            if t.type == TOKEN_TYPE_VAR {
                parent = searchVar(t.cont, elems)
            } else {
                tmpV = genCompilerVar()
                cType = getCType(tt, elems)
                OUTPUT += rope("
                "+cType.str()+" "+tmpV+" = "+t.cont+";
                ")
                t.cont = tmpV
                parent = new variable {
                    name: tmpV
                    type: tt
                }
                if RCPavailable() {
                    elems.vars[len(elems.vars)] = parent
                }
            }
            fn = searchStructMethod(nt.cont, s, elems)
            if fn == null {
                throwErr(&nt, "Unknown method {TOKEN} in struct "+s.name+".")
            }
            if t.type == TOKEN_TYPE_VAR {
                if fn.isImported == true || fn.isMut == true {
                    rp = searchVarByToken(&t, elems)
                    rp.lastSet = elems
                    if rp.isArg == true {
                        currentFn.isMut = true
                    }
                }
            }
            if fn.isVar == true {
                fn.name = t.cont + sep + fn.name
            }
            if parent == null {
                throwErr(&t, "Could not find structure {TOKEN}.")
            }
            valueFunc(fn, parent, l, i, ltp, elems)
            fnt = l[i]
            delete(l, i)
            fnt.ogCont = t.ogCont + "." + nt.ogCont
            fnt.pos = t.pos
            // fnt.cont = t.cont + sep + fnt.cont
            // fnt.cont = t.cont + sep + fnt.cont
            l[tokPos] = fnt
            return tokPos
        }
    }

    //member is a variable
    m = searchStructMemb(nt.cont, s, elems)
    if m == null {
        throwErr(&nt, "Unknown struct member {TOKEN} in struct '"+s.name+"'.")
    }
    if m.isFn == true {
        t.cont = s.name+"__"+m.name
    } else {
        if t.type == TOKEN_TYPE_VAR {
            t.parent = searchVarByToken(&t, elems)
        }
        t.cont += sep + nt.cont
    }
    t.ogCont += "."+nt.cont
    t.bahType = m.type
    t.bahRef = new variable {
        name: t.cont
        type: t.bahType
    }

    l[tokPos] = t
    return tokPos
}

valueArr(l []Tok, i int, ltp lineType, elems Elems*) int {
    tokPos = i-1
    //get previous value
    pt = l[tokPos]
    delete(l, tokPos)
    if pt.isValue == false {
        throwErr(&pt, "Cannot use {TOKEN} as value (array).")
    }
    ptt = string(getTypeFromToken(&pt, true, elems))

    //make return token
    t = pt
    t.isValue = true
    t.ogCont += "["

    //pre-processing index value
    nbEncls = 1
    memory = []Tok
    i = tokPos+1
    for i < len(l), i++ {
        tmpT = l[i]
        // delete(l, i)
        if tmpT.cont == "(" || tmpT.cont == "{" || tmpT.cont == "[" {
            nbEncls++
        } else if tmpT.cont == ")" || tmpT.cont == "}" || tmpT.cont == "]" {
            nbEncls--
            t.ogCont += "]"
            if nbEncls == 0 {
                break
            }
        }
        t.ogCont += tmpT.ogCont
        memory[len(memory)] = tmpT
    }
    deleteRange(l, tokPos+1, i)
    memory = prePross(memory, <lineType>-1, elems)
    
    //handle empty index
    if len(memory) == 0 {
        throwErr(&pt, "Cannot access empty index of array {TOKEN}.")
    }

    // parsing substitution values
    split = false
    from = ""
    to = ""
    if len(memory) > 1 {
        split = true
        first = memory[0]
        second Tok
        third Tok

        if len(memory) == 3 {
            second = memory[1]
            third = memory[2]
            firstT = getTypeFromToken(&first, true, elems)
            if compTypes(firstT, "int") == false {
                throwErr(&first, "Cannot use {TOKEN} as int.")
            }
            thirdT = getTypeFromToken(&third, true, elems)
            if compTypes(thirdT, "int") == false {
                throwErr(&third, "Cannot use {TOKEN} as int.")
            }
            if second.cont != ":" {
                throwErr(&second, "Expected ':' not {TOKEN}.")
            }
            from = first.cont
            to = third.cont
        } else if len(memory) == 2 {
            second = memory[1]

            if first.cont == ":" {
                from = "0"
                secondT = getTypeFromToken(&second, true, elems)
                if compTypes(secondT, "int") == false {
                    throwErr(&second, "Cannot use {TOKEN} as int.")
                }
                to = second.cont
            } else if second.cont == ":" {
                firstT = getTypeFromToken(&first, true, elems)
                if compTypes(firstT, "int") == false {
                    throwErr(&first, "Cannot use {TOKEN} as int.")
                }
                from = first.cont
            } else {
                throwErr(&second, "Expected ':' not {TOKEN}")
            }
        } else {
            throwErr(&memory[3], "Cannot substiture with more than 2 values, expected ']' not {TOKEN}.")
        }
    }

    if ptt.hasPrefix("[]") { //is array
        if split == false {
            index = memory[0]
            if compTypes(getTypeFromToken(&index, true, elems), "int") == false {
                throwErr(&index, "Cannot use {TOKEN} as array index (int).")
            }
            t.cont = pt.cont+"->data["+index.cont+"]"
            ptt.trimLeft(2)
            t.bahType = ptt.str()
        } else {
            t.bahType = ptt.str()
            if to == "" {
                to = pt.cont+"->length"
            }
            t.cont = "arraySubstitute("+pt.cont+", "+from+", "+to+")"
        }

    } else if ptt.hasPrefix("buffer:") { //is a buffer
        if split == false {
            t.bahType = "char"
            index = memory[0]
            if compTypes(getTypeFromToken(&index, true, elems), "int") == false {
                throwErr(&index, "Cannot use {TOKEN} as buffer index (int).")
            }
            t.cont = pt.cont+"["+index.cont+"]"
        } else {
            t.bahType = "cpstring"
            if to == "" {
                to = "strlen("+pt.cont+")"
            }
            t.cont = "cpstringSubsitute("+pt.cont+", "+from+", "+to+")"
        }
    } else if ptt.hasPrefix("map:") { //is a map
        if split == true {
            throwErr(&pt, "Cannot do substitution on a map {TOKEN}.")
        }
        ptt.trimLeft(4)
        elemType = getCType(ptt.str(), elems)
        index = memory[0]
        if compTypes(getTypeFromToken(&index, true, elems), "cpstring") == false {
            throwErr(&index, "Cannot use {TOKEN} as map index (cpstring).")
        }
        if tokPos == 0 && ltp == LINE_TYPE_VAR { //setting map value
            tmpV = new variable {
                name: genCompilerVar()
                type: ptt.str()
            }
            elems.vars[len(elems.vars)] = tmpV
            if isGlobal() {
                INIT += rope(elemType.str() + " " + tmpV.name+";\n")
            } else {
                OUTPUT += rope(elemType.str() + " " + tmpV.name+";\n")
            }
            if isRCPpointerType(ptt.str()) {
                NEXT_LINE = "mapWrapper__set("+pt.cont+", "+index.cont+", "+tmpV.name+");\n"
            } else {
                NEXT_LINE = "mapWrapper__setAny("+pt.cont+", "+index.cont+", &"+tmpV.name+", sizeof("+elemType.str()+"));\n"
            }
            t.cont = tmpV.name
            t.bahType = ptt.str()
        } else { //getting map value
            t.isFunc = true
            res rope*
            tmpV = genCompilerVar()
            if isRCPpointerType(ptt.str()) {
                res = rope(elemType.str()+" "+tmpV+"=mapWrapper__get("+t.cont+", "+index.cont+");\n")
                t.cont = tmpV 
            } else {
                res = rope(elemType.str() + "* "+tmpV+"=mapWrapper__get("+pt.cont+", "+index.cont+");\n")
                t.cont = "("+elemType.str()+")(*"+tmpV+")"
            }
            if RCPavailable() {
                elems.vars[len(elems.vars)] = new variable{
                    name: tmpV
                    type: ptt.str()
                }
            }
            if isGlobal() {
                INIT += res
            } else {
                OUTPUT += res
            }
            t.bahType = ptt.str()
        }

    } else if ptt.str() == "cpstring" { // is a string
        t.isFunc = true
        t.type = TOKEN_TYPE_FUNC
        if split == false {
            t.bahType = "char"
            index = memory[0]
            if compTypes(getTypeFromToken(&index, true, elems), "int") == false {
                throwErr(&index, "Cannot use {TOKEN} as cpstring index (int).")
            }
            t.cont = pt.cont+"["+index.cont+"]"
        } else {
            if to == "" {
                to = "strlen("+pt.cont+")"
            }
            t.cont = "cpstringSubsitute("+pt.cont+", "+from+", "+to+")"

        }
    } else if ptt.hasPrefix("tuple:") {
        t.isOper = true
        v = searchVar(pt.cont, elems)
        if v == null {
            throwErr(&pt, "Unkown var {TOKEN}.")
        }
        parts = splitString(ptt, ":")
        index = memory[0]
        if index.type == TOKEN_TYPE_INT {
            ind = strToInt(index.cont)
            if ind >= strToInt(parts[1].str()) {
                throwErr(&index, "Cannot access index {TOKEN} of tupple "+pt.cont+" of length "+parts[1].str()+".")
            }
        } else {
            if compTypes(getTypeFromToken(&index, true, elems), "int") == false {
                throwErr(&index, "Cannot use {TOKEN} as tuple index (int).")
            }
        }
        t.cont = pt.cont+"["+index.cont+"]"
        t.bahType = parts[2].str()
    } else {
        throwErr(&pt, "Cannot use {TOKEN} ("+ptt.str()+") as array.")
    }

    t.isValue = true    
    l[tokPos] = t

    return tokPos
}

valueBool(l []Tok, i int, ltp lineType, elems Elems*) int {

    tokPos = i-2

    // get previous value
    pt = l[tokPos]
    ptt = getTypeFromToken(&pt, true, elems)

    t = l[tokPos+1]

    deleteRange(l, tokPos, tokPos+1)

    //sets looping variable as register is faster
    if ltp == LINE_TYPE_FOR && ptt == "int" || ptt == "float" {
        v = getRealVar(pt.cont, elems)
        if v != null && v.canBeReg == true && v.isReg == false && v.declRope != null {
            odecl = v.declRope.toStr()
            if strHasPrefix(odecl, "register ") == false {
                OUTPUT.totalLen += ropeSet(v.declRope, "register "+odecl)
            }
            v.isReg = true
        }
    }

    //checking condition of branch for safety checks
    if isUnsafe == false {
        if tokPos > 0 {
            if l[tokPos-1].cont != "&&" {
                clear(currChecks)
            }
        } else {
            clear(currChecks)
        }
    }

    //checking if two values are the same type
    nt = l[tokPos]
    ntt = getTypeFromToken(&nt, true, elems)
    if t.cont == "in" {
        arrT = string(ntt)
        if arrT.hasPrefix("[]") == 0 {
            throwErr(&nt, "Cannot use {TOKEN} ("+ntt+") as array.")
        }
        arrT.trimLeft(2)
        if compTypes(ptt, arrT.str()) == false {
            throwErr(&pt, "Cannot search for {TOKEN} ("+ptt+") in "+ntt+".")
        }
        compVar = genCompilerVar()
        comp = ""
        if ptt == "cpstring" {
            comp = nt.cont+"->data[i] != 0 && strcmp("+nt.cont+"->data[i], "+pt.cont+") == 0"
        } else {
            comp = nt.cont+"->data[i] == "+pt.cont
        }
        OUTPUT += rope("
        char "+compVar+" = 0;
        for(int i="+nt.cont+"->length-1; i!=-1;i--) {
            if ("+comp+") {
                "+compVar+"=1;
                break;
            };
        }
        ")
        pt.cont = compVar
    } else {
        if compTypes(ptt, ntt) == false {
            throwErr(&nt, "Cannot compare {TOKEN} ("+ntt+") with type "+ptt+".")
        }
        if ptt == "cpstring" {
            if t.cont == "==" {
                pt.cont = "(strcmp("+pt.cont+", "+nt.cont+") == 0)"

            } else if t.cont == "!=" {
                pt.cont = "(strcmp("+pt.cont+", "+nt.cont+") != 0)"
            } else if t.cont == ">" {
                pt.cont = "(strlen("+pt.cont+") > srtlen("+nt.cont+"))"
            } else if t.cont == "<" {
                pt.cont = "(strlen("+pt.cont+") < srtlen("+nt.cont+"))"
            } else if t.cont == ">=" {
                pt.cont = "(strlen("+pt.cont+") >= srtlen("+nt.cont+"))"
            } else if t.cont == "<=" {
                pt.cont = "(strlen("+pt.cont+") <= srtlen("+nt.cont+"))"
            }
        } else {
            if isUnsafe == false && pt.type == TOKEN_TYPE_VAR && pt.isOper == false && isRCPpointerType(ptt) {
                ptV = searchVar(pt.cont, elems)
                if ptV != null {
                    ntIsNull = false
                    if nt.cont == "null" {
                        ntIsNull = true
                    } else if nt.type == TOKEN_TYPE_VAR && nt.isOper == false {
                        nv = searchVar(nt.cont, elems)
                        if nv != null {
                            ntIsNull = nv.canBeNull
                        }
                    } else if nt.isFunc == true {
                        fn = searchFuncByToken(&nt, elems)
                        if fn != null && fn.returns != null {
                            ntIsNull = fn.returns.type[strlen(fn.returns.type)-1] == '!'
                        }
                    }
                    if t.cont == "==" {
                        currChecks[len(currChecks)] = varCheck{
                            v: ptV
                            checkNull: ntIsNull
                        }
                    } else if t.cont == "!=" {
                        currChecks[len(currChecks)] = varCheck{
                            v: ptV
                            checkNull: ntIsNull == false
                        }
                    }
                }
            }
            pt.cont = "(" + pt.cont + t.cont + nt.cont + ")"
        }
    }


    pt.isOper = true
    pt.bahType = "bool"
    pt.isValue = true
    l[tokPos] = pt
    return tokPos
}


valueOper(l []Tok, i int, elems Elems*) int {
    tokPos = i - 2
    //get previous value
    pt = l[tokPos]
    ptt = getTypeFromToken(&pt, true, elems)

    //get operator
    t = l[tokPos+1]
    deleteRange(l, tokPos, tokPos+1)

    //get second value
    nt = l[tokPos]
    
    //for increment and decrement
    if nt.cont == t.cont {
        pt.isOper = true
        pt.cont = t.cont + t.cont + pt.cont
        l[tokPos] = pt
        return tokPos
    }

    //check if the two values are the same type
    ntt = getTypeFromToken(&nt, true, elems)
    if compTypes(ptt, ntt) == false {
        throwErr(&nt, "Cannot compare {TOKEN} ("+ntt+") as "+ptt+".")
    }

    //parse string concatenation
    if ptt == "cpstring" {        
        //add first two cpstrings to the concat array
        //strs contains all the cpstrings to concatenate in reverse order
        strs = []cpstring{nt.cont, pt.cont}

        if t.cont != "+" {
            throwErr(&t, "Can only do concatenation on cpstring, not {TOKEN}.")
        }
        
        //concatenate all strings at once to reduce memory allocations
        if tokPos -1 >= 0 {
            nat = l[tokPos-1]
            if nat.cont == "+" {
                // delete(l, tokPos-1)
                rangeEnds = tokPos-1
                i = tokPos-2
                nb = 2
                for i >= 0, i-- {
                    tokPos = i
                    currStrTk = l[i]
                    //type guard
                    tt = getTypeFromToken(&currStrTk, true, elems)
                    if compTypes(tt, "cpstring") == false {
                        throwErr(&currStrTk, "Cannot concatenate cpstring with {TOKEN} ("+tt+").")
                    }
                    //add to the array of cpstrings to allocate
                    strs[len(strs)] = currStrTk.cont

                    // delete(l, i)
                    if i-1 >= 0 {
                        i--
                        t = l[i]
                        if t.cont != "+" {
                            if t.cont in signs {
                                throwErr(&t, "Can only do concatenation on cpstring, not {TOKEN}.")
                            } else {
                                i++
                                break
                            }
                        }
                        // delete(l, i) 
                    } else {
                        i = 0
                        break
                    }
                }
                deleteRange(l, i, rangeEnds)
            } else if inArrayStr(nat.cont, signs) {
                throwErr(&nat, "Can only do concatenation on cpstring, not {TOKEN}.")
            }
        }

        //build concatenation code

        pt.type = TOKEN_TYPE_VAR
        pt.isValue = true
        pt.cont = genConcat(strs, elems)
        pt.isOper = false
    } else {

        s = searchStruct(ptt, elems)
        if s != null {
            sep = "."
            amp = "&"

            if isRCPpointerType(ptt) {
                sep = "->"
                amp = ""
            }
            mName = ""
            if t.cont == "+" {
                mName = "add"
            } else if t.cont == "-" {
                mName = "sub"
            } else if t.cont == "*" {
                mName = "mult"
            } else if t.cont == "/" {
                mName = "div"
            } else {
                throwErr(&pt, "Undefined operation on struct {TOKEN} ("+ptt+").")
            }
            methd = searchStructMemb(mName, s, elems)
            if methd != null && methd.isFn == true {
                if RCPavailable() {
                    pt.cont = registerRCPvar(ptt, s.name + "__" + mName + "(" +amp+pt.cont + ", " + nt.cont + ")", elems)
                    pt.type = TOKEN_TYPE_VAR; pt.isFunc = false; pt.isOper = false
                } else {
                    pt.cont = s.name + "__" + mName + "(" +amp+pt.cont + ", " + nt.cont + ")"
                    pt.isFunc = true
                }
            }
        } else {
            pt.cont += t.cont + nt.cont
        }
        pt.isOper = true

    }

    l[tokPos] = pt
    return tokPos
}

valueSendChan(l []Tok, i int, elems Elems*) int {
    posTok = i-2
    //value to send
    nt = l[posTok]
    //channel
    pt = l[posTok+2]
    deleteRange(l, posTok, posTok+2)

    ntt = getTypeFromToken(&nt, true, elems)

    ptt = string(getTypeFromToken(&pt, true, elems))
    if ptt.hasPrefix("chan:") == 0 {
        throwErr(&pt, "Cannot use {TOKEN} ("+ptt.str()+") as chan.")
    }
    ptt.trimLeft(5)

    if isGlobal() {
        throwErr(&pt, "Cannot send to channel {TOKEN} of a function.")
    }

    if compTypes(ntt, ptt.str()) == false {
        throwErr(&nt, "Cannot send {TOKEN} ("+ntt+") through chan:"+ptt.str()+".")
    }

    if isRCPpointerType(ptt.str()) {
        OUTPUT += rope("channel__send("+pt.cont+", "+nt.cont+");\n")
    } else {
        ct = getCType(ntt, elems)
        tmpV = genCompilerVar()
        OUTPUT += rope("
        "+ct.str()+" "+tmpV+" = "+nt.cont+";
        channel__sendAny("+pt.cont+", &"+tmpV+", sizeof("+tmpV+"));
        ")
    }

    return posTok
}

valueChan(l []Tok, i int, elems Elems*) int {
    posTok = i-1
    delete(l, posTok) //->

    //channel token
    nt = l[posTok]
    
    ntt = string(getTypeFromToken(&nt, true, elems))
    if ntt.hasPrefix("chan:") == 0 {
        throwErr(&nt, "Cannot use {TOKEN} ("+ntt.str()+") as chan.")
    }

    ntt.trimLeft(5)

    if isGlobal() {
        throwErr(&nt, "Cannot receive from chan {TOKEN} outside a function body.")
    }

    ct = getCType(ntt.str(), elems)
    if isRCPpointerType(ntt.str()) {
        tmpV = registerRCPvar(ntt.str(), "channel__receive("+nt.cont+")", elems)
        nt.cont = tmpV
    } else {
        if RCPavailable() {
            tmpV = registerRCPvar(ntt.str()+"*", "("+ct.str()+"*)channel__receive("+nt.cont+")", elems)
            nt.cont = "*"+tmpV
        } else {
            nt.cont = "*("+ct.str()+"*)channel__receive("+nt.cont+")"
        }
    }

    nt.type = TOKEN_TYPE_FUNC
    nt.isFunc = true
    nt.isValue = true
    nt.bahType = ntt.str()

    l[posTok] = nt

    return posTok
}

valueTuple(l []Tok, i int, elems Elems*) int {
    tokPos = i

    nbBracks = 0
    if l[tokPos+1].cont == "]" {
        //is arr type
        if l[tokPos+2].type == TOKEN_TYPE_VAR {
            return tokPos+1
        }
        throwErr(&l[tokPos], "Cannot declare {TOKEN} empty tuple.")
    }


    ft = l[tokPos+1]

    tupT = getTypeFromToken(&ft, true, elems)

    vals = []cpstring

    nbEncl = 1
    i++; for i < len(l), i++ {
        if l[i].cont == "[" || l[i].cont == "(" {
            nbEncl++
        } else if l[1].cont == "]" || l[i].cont == ")" {
            nbEncl--
            if nbEncl == 0 {
                break
            }
        }
    }

    memory = l[tokPos+1:i]

    memory = prePross(memory, <lineType>-1, elems)

    j=0; for j < len(memory), j += 2 {
        t = memory[j]
        tt = getTypeFromToken(&t, true, elems)
        if compTypes(tupT, tt) == false {
            throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+tupT+" in tuple declaration.")
        }
        vals[len(vals)] = t.cont
        nt = memory[j+1]
        if nt.cont == "]" {
            break
        } else if nt.cont != "," {
            throwErr(&nt, "Expected separator between values in tuple declaration, got {TOKEN}.")
        }
    }

    type = "tuple:"+intToStr(len(vals))+":"+tupT

    deleteRange(l, tokPos+1, j+1)

    v = registerRCPvar(type, "alloca(sizeof("+getCType(tupT, elems).str()+") * "+intToStr(len(vals))+")", elems)
    
    r = ""
    i=0; for i < len(vals), i++ {
        r += v+"["+intToStr(i)+"] = "+vals[i]+";"
    }
    
    if isGlobal() {
        INIT += rope(r)
    } else {
        OUTPUT += rope(r)
    }

    l[tokPos] = Tok {
        type: TOKEN_TYPE_VAR
        bahType: type
        cont: v
    }

    return tokPos
}

isSmallValue(l []Tok, i int) bool {
    t = l[i]
    if t.type == TOKEN_TYPE_CAST || t.cont == "(" {
        return false
    } else if t.isValue == false {
        throwErr(&t, "Cannot use {TOKEN} as value.")
    }
    if i+1 < len(l) {
        nt = l[i+1]
        if nt.cont == "[" || nt.cont == "." || nt.cont == "(" {
            return false
        }
    }
    return true
}

isValue(l []Tok, i int) bool {
    t = l[i]
    if t.type == TOKEN_TYPE_CAST || t.cont == "(" {
        return false
    } else if t.isValue == false {
        throwErr(&t, "Cannot use {TOKEN} as value.")
    }
    if i+1 < len(l) {
        nt = l[i+1]
        if nt.cont == "[" || nt.cont == "." || nt.cont == "(" || inArrayStr(nt.cont, signs) {
            return false
        }
    }
    return true
}


// matchToken(t Tok, mt Tok) bool {
//     if t.type != mt.type {
//         return false
//     }
//     if t.isValue == true {
//         return true
//     }
//     if t.cont == mt.cont {
//         return true
//     }
//     return false
// }

// matchLine(l []Tok, j int, m []Tok) bool {
//     i=0; for i < len(m), i++ {
//         if j >= len(l) {
//             return false
//         }
//         if m[i].cont == "%%" {
//             i++
//             for j < len(l), j++ {
//                 if matchToken(l[j], m[i]) {
//                     break
//                 }
//             }
//             if j == len(l) {
//                 return false
//             }
//         } else if matchToken(l[j], m[i]) == false {
//             return false
//         }
//         j++
//     }
//     return true
// }