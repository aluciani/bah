//Values function take an array of token and the position of the token.
//The multiple tokens used to parse the resulting token are then deleted from the array and replaced by the result.
//They are ment to be called in a loop (in the function 'prePross()').
//They then return the index of the affected token, which the loop iterator should be set to.

//Makes a function token from ['var', '(', <'arg,'>, ')']. It can also parse struct methods and generics.
valueFunc(fn func*, parent variable*, l []Tok, i int, ltp lineType, elems Elems*) int {
    tokPos = i

    generic genericFunc*

    //if not defined func, go find it before in the line
    errPos = -1
    if fn == null {
        if i > 0 {
            tokPos = i-1
            pt = l[tokPos]
            if pt.type == TOKEN_TYPE_VAR {
                delete(l, tokPos)
                errPos = pt.pos
                fn = searchVirtFuncByToken(&pt, elems)
                if fn == null {
                    j=0; for j < len(generics), j++ {
                        if generics[j].baseFn.name == pt.cont {
                            generic = generics[j]
                            generics[j].setCurrGeneric(&pt)
                            fn = generics[j].dupBaseFn()
                            break
                        }
                    }
                    if j == len(generics) {
                        throwErr(&pt, "Unknown func {TOKEN}.")
                    }
                } else if pt.isOper {
                    fnt = string(getTypeFromToken(&pt, true, elems))
                    tmpV = new variable {
                        type: fnt.str()
                    }
                    // if pt.isFunc {
                    //     tmpV.name = "keep_ref_"+genCompilerVar()
                    // } else {
                        tmpV.name = genCompilerVar()
                    // }
                    OUTPUT += rope(getCfunctionType(&fnt, tmpV.name, elems)+" = "+pt.cont+";\n")
                    pt.cont = tmpV.name
                    fn.name = tmpV.name
                    pt.setRefVar(tmpV)
                }
            } else {
                tokPos++
            }
        } else if l[0].cont != "(" {
            return i
        }
    }

    fnt = l[tokPos]
    if errPos != -1 {
        fnt.pos = errPos
    }


    //only have parenthesis
    if fn == null {
        nbEncls = 1
        memory = []Tok
        i = tokPos+1
        fnt.ogCont = "("
        for i < len(l), i++ {
            t = l[i]
            fnt.ogCont += t.ogCont
            if t.cont == "(" || t.cont == "{" || t.cont == "[" {
                nbEncls++
            } else if t.cont == ")" || t.cont == "}" || t.cont == "]" {
                nbEncls--
                if nbEncls == 0 {
                    break
                }
            }
            memory[len(memory)] = t
        }
        deleteRange(l, tokPos+1, i)
        memort = prePross(memory, <lineType>-1, elems)
        ft = memory[0]
        fnt.cont = "("
        fnt.isOper = true
        fnt.isValue = true
        fnt.bahType = getTypeFromToken(&ft, true, elems)
        j=0; for j < len(memory), j++ {
            t = memory[j]
            fnt.cont = fnt.cont + t.cont
        }
        fnt.cont += ")"

        //For dereferencing parenthesis
        if tokPos > 0 && l[tokPos-1].cont == "*" && (tokPos == 1 || (tokPos > 1 && l[tokPos-2].isValue == false)) {
            if isRCPpointerType(fnt.bahType) == false {
                throwErr(&fnt, "Cannot dereference non pointer {TOKEN} ("+fnt.bahType+").")
            }

            fnt.cont = "*" + fnt.cont
            
            if fnt.bahType[len(fnt.bahType)-1] == '*' {
                fnt.bahType = fnt.bahType[:len(fnt.bahType)-1]
            } else if fnt.bahType == "cpstring" {
                fnt.bahType = "char"
            } else if fnt.bahType == "ptr" {
                throwErr(&fnt, "Cannot dereference {TOKEN} of type ptr.")
            }
            
            tokPos--
            delete(l, tokPos)
        }

        l[tokPos] = fnt
        return tokPos
    }

    //checks if the program should be running after the execution of this function
    if fn.name == "exit" || fn.name == "panic" || fn.exits == true {
        if compilerState.isBranch == true {
            elems.currFlowEnd = true
        }
        setNullStateBranchFlowEnd(elems)
    }

    //making the return token
    fnt.cont = fn.name + "("
    if fn.returns != null && fn.returns.type != "" {
        fnt.isValue = true
        fnt.bahType = fn.returns.type
    }
    fnt.isFunc = true
    fnt.type = TOKEN_TYPE_FUNC

    //pre-processing arguments
    memory = <[]Tok>null
    nbEncls = 1
    i = tokPos+1
    if parent == null {
        fnt.ogCont = fn.name
    }
    start = i
    for i < len(l), i++ {
        t = l[i]
        if t.type == TOKEN_TYPE_ENCL {
            if t.cont[0] == '(' || t.cont[0] == '{' || t.cont[0] == '[' {
                nbEncls++
            } else if t.cont[0] == ')' || t.cont[0] == '}' || t.cont[0] == ']' {
                nbEncls--
                if nbEncls == 0 {
                    break
                }
            }
        }
    }
    if start < i {
        memory = l[start:i]
    }
    deleteRange(l, tokPos+1, i)

    //noCheck (for c lang in bah)
    if fn.name == "noCheck" {
        fnt.cont = ""
        fnt.isOper = true
        fnt.isValue = true
        fnt.bahType = "ptr"
        j=0; for j < len(memory), j++ {
            t = memory[j]
            fnt.cont += " " + t.cont
        }
        l[tokPos] = fnt
        return tokPos
    }
    //special functions
    currLine = "\""+compilerState.currentFile + ":" + intToStr(fnt.line)+"\""
    if fn.name == "panic" {
        memory[len(memory)] = Tok {
            type: TOKEN_TYPE_SYNTAX
            cont: ","
            line: fnt.line
        }
        memory[len(memory)] = Tok {
            type: TOKEN_TYPE_STR
            cont: currLine
            line: fnt.line
        }
        fn = searchFunc("__BAH_panic", elems, true)
        fnt.cont = fn.name + "("
    } else if fn.name == "__dumpSymbols" {
        symbols = []variable*
        j=0; for j < len(elems.vars), j++ {
            v = elems.vars[j]
            if v.isConst == false {
                symbols[len(symbols)] = v
            }
        }
        tmpV = new variable {
            name: genCompilerVar()
            type: "[]reflectElement"
            isArray: true
        }
        decls = ""
        j=0; for j < len(symbols), j++ {
            v = symbols[j]
            vname = v.name
            if string(v.type).containsChar('*') == false {
                vname = "&"+v.name
            }
            tmpT = Tok{
                type: TOKEN_TYPE_VAR
                cont: vname
                bahType: v.type
                isValue: true
            }
            tmpT = parseReflect(tmpT, v.type, elems, true, v.name, "0")
            decls += "((struct reflectElement*)"+tmpV.name+"->data)["+intToStr(j)+"] = " + tmpT.cont + ";\n"
        } 
        elems.vars[len(elems.vars)] = tmpV
        OUTPUT = OUTPUT + rope("
        struct Bah_Array_Type* "+tmpV.name+" = memoryAlloc(sizeof(struct Bah_Array_Type));
        "+tmpV.name+"->data = memoryAlloc(sizeof(struct reflectElement) * "+intToStr(len(symbols))+");
        "+tmpV.name+"->length = "+intToStr(len(symbols))+";
        "+tmpV.name+"->elemSize = sizeof(struct reflectElement);
        "+decls+"
        ")
        memory = []Tok{
            Tok{
                type: TOKEN_TYPE_VAR
                cont: tmpV.name
                line: fnt.line
                isValue: true
            }
        }
    } else if fn.name == "breakPoint" {
        memory = []Tok{
            Tok{
                type: TOKEN_TYPE_VAR
                cont: "__dumpSymbols"
                line: fnt.line
            },
            Tok{
                type: TOKEN_TYPE_SYNTAX
                cont: "("
                line: fnt.line
            },
            Tok{
                type: TOKEN_TYPE_SYNTAX
                cont: ")"
                line: fnt.line
            }
        }
        memory = prePross(memory, LINE_TYPE_FN_CALL, elems)
        memory[len(memory)] = Tok{
            type: TOKEN_TYPE_SYNTAX
            cont: ","
            line: fnt.line
        }
        memory[len(memory)] = Tok{
            type: TOKEN_TYPE_STR
            cont: currLine
            line: fnt.line
        }
        fn = searchFunc("breakPoint__inner", elems, true)
        fnt.cont = fn.name + "("
    } else if fn.name == "sizeof" {
        tp = ""
        j=0; for j < len(memory), j++ {
            tmpT = memory[j]
            tp += tmpT.cont
        }
        tmpV = searchVar(tp, &memory[0], elems)
        if tmpV != null {
            cType = getCType(tmpV.type, elems)
            fnt.cont += cType.str()+")"
        } else {
            cType = getCType(tp, elems)
            if cType.length == 0 {
                ft = memory[0]
                throwErr(&ft, "Cannot get size of {TOKEN}.")
            }
            fnt.cont += cType.str()+")"
        }
        fnt.type = TOKEN_TYPE_FUNC
        fnt.isFunc = true
        fnt.bahType = "int"
        fnt.setRefFn(fn)
        l[tokPos] = fnt
        return tokPos
    }

    //processing memory (arguments)
    if len(memory) > 0 {
        memory = prePross(memory, ltp, elems)
    }

    argIndex = 0
    if parent != null { //adding parent var for method calls
        amp = "&"
        if isRCPpointerType(parent.type) {
            amp = ""
        }
        fnt.cont += amp + l[tokPos-1].cont
        argIndex++
        if len(fn.args) > argIndex {
            fnt.cont += ","
        }
    }

    ogFntContL = len(fnt.cont)

    ltt = ""

    // parsing arguments
    j=0; for j < len(memory), j++ {
        t = memory[j]
        if argIndex == len(fn.args) {
            throwErr(&t, "Too many arguments, expected ')' not {TOKEN}.\n"+getFuncDef(fn))
        }
        arg = fn.args[argIndex]
        tt = getTypeFromToken(&t, true, elems)
        ltt = tt

        if isFixMeEnabled && (fn.isImported == true || isInside(BAH_DIR, fn.file)) && t.type == TOKEN_TYPE_VAR {
            fixMeTestVar(&t, ltp, elems)
        }

        if arg.type == "reflectElement" && tt != "reflectElement" {
            t = parseReflect(t, tt, elems, false, t.cont, "0")
            tt = "reflectElement"
        }

        if RCPavailable() {
            RCPkeepFuncRef(&t, tt, elems)
        }

        if generic != null && arg.type == "<any>" {
            arg.type = tt
            tts = string(tt)
            tts.replace("*", "_AST_")
            tts.replace(":", "_DP_")
            tts.replace("[]", "_ARR_")
            fn.name += "__" + tts.str()
        } else {
            if compTypes(arg.type, tt) == false {
                throwErr(&t, "Cannot use {TOKEN} ("+tt+") as "+arg.type+" in function call.\n"+getFuncDef(fn))
            }
        }

        //Converts cpstring to char* when a C binding is called.
        if tt == "cpstring" && fn.isCbinding && fn.name != "strlen" {
            t.cont = "cStr("+t.cont+")"
        }

        //Make sure that the argument passed cannot be null.
        checkCanBeNull(&t, tt, elems)

        //Adds token contents to the func token.
        fnt.cont += t.cont

        argIndex++

        //Make sure that the next token is a ',' or that this is the end of arguments.
        if j+1 < len(memory) {
            j++
            t = memory[j]
            if t.cont != "," {
                throwErr(&t, "Need separator between arguments, not {TOKEN}.\n"+getFuncDef(fn))
            }
            if j+1 >= len(memory) {
                throwErr(&t, "Trailing {TOKEN} with no argument after.\n"+getFuncDef(fn))
            }
            fnt.cont += ","
        }

    }

    if isTupleType(fn.returns.type) {
        coma = ""
        if len(fn.args) > 0 {
            coma = ","
        }
        alloc = "alloca"
        if ltp == LINE_TYPE_ASYNC {
            alloc = "memoryAlloc"
        }
        fnt.cont += coma+alloc+"("+getTupleSize(fn.returns.type, elems)+")"
    }

    fnt.cont += ")"

    if argIndex != len(fn.args) {
        throwErr(&fnt, "Not enough argument {TOKEN}, calling '"+fn.name+"'.\n"+getFuncDef(fn))
    }

    //If the function is a generic, its C name will be '__generic_' + function's name.
    //We will need to replace it in the function token.
    if generic != null {
        fnt.cont = "__generic_" + fn.name + "(" + fnt.cont[ogFntContL:]
        if generic.isAlreadyDecl(fn.name) == false {
            generic.declare(fn, elems)
        }
    }

    //Shortcut reference to find the function by token faster.
    fnt.setRefFn(fn)

    //Some basic string conversions.
    if fn.name == "strlen" && ltt != "cpstring" {
        fnt.cont = "C"+fnt.cont
    } else if fn.name == "len" && ltt == "cpstring" {
        fnt.cont = "str"+fnt.cont
    } else if fn.isCbinding && fn.returns.type == "cpstring" {
        fnt.cont = "cStrToBah("+fnt.cont+")"
    }

    if noticeEnabled == true && ltt == "cpstring" && fn.name == "strlen" {
        throwNoticeLine("Function strlen() can be used for char*. Use len() for better code readability.", l[tokPos].line)
    }

    if isUnsafe == false && fn.name == "len" && ltt != "cpstring" && string(ltt).hasPrefix("[]") == false {
        throwErr(&memory[0], "Cannot use len({TOKEN}) ("+ltt+") as cpstring or array.")
    }

    l[tokPos] = fnt
    return tokPos

}

//Makes a var token from ['var', '.', 'member'].
valueStruct(l []Tok, i int, ltp lineType, elems Elems*) int {
    tokPos = i-1

    //is prev token a struct type
    t = l[i-1]
    tt = getTypeFromToken(&t, true, elems)
    s = searchStruct(tt, elems)
    if s == null {
        if tt[len(tt)-1] == '!' {
            throwErr(&t, "Cannot use maybe value {TOKEN} ("+tt+") as structure.")
        } else {
            throwErr(&t, "Unknown struct {TOKEN} ("+tt+").")
        }
    }

    checkCanBeNull(&t, tt, elems)

    //is next token a member name
    nt = l[i+1]
    if nt.isValue == false {
        throwErr(&nt, "Cannot use {TOKEN} as member.")
    }
    deleteRange(l, i, i+1)

    //get appropriate C-separator
    sep = "."
    if isRCPpointerType(tt) {
        sep = "->"
    }

    //FixMe test
    if t.type == TOKEN_TYPE_VAR {
        fixMeTestVar(&t, ltp, elems)
    }

    //calling a method, make some pre-processing before passing the result to valueFunc()
    if i < len(l) {
        ntt = l[i]
        if ntt.cont == "(" {
            parent variable*
            if t.type == TOKEN_TYPE_VAR {
                if t.getRefVar() != null {
                    parent = t.getRefVar()
                } else {
                    parent = searchVirtVarByToken(&t, elems)
                }

                // if parent != null && isRCPpointerType(parent.type) == false {
                //     nParent = new variable
                //     *nParent = *parent
                //     parent = nParent
                //     parent.name = registerRCPtrackedVar(parent.type, t.cont, elems)
                // }
            } else {
                tmpV = "keep_ref_"+genCompilerVar()
                if RCPavailable() {
                    elems.vars[len(elems.vars)] = new variable {
                        name: tmpV
                        type: tt
                        declScope: elems
                    }
                }
                cType = getCType(tt, elems)
                OUTPUT += rope("
                "+cType.str()+" "+tmpV+" = "+t.cont+";
                ")
                t.cont = tmpV
                parent = new variable {
                    name: tmpV
                    type: tt
                }
                l[i-1].type = TOKEN_TYPE_VAR
                l[i-1].cont = tmpV
            }
            fn = searchStructMethod(nt.cont, s, elems)
            if fn == null {
                throwErr(&nt, "Unknown method {TOKEN} in struct "+s.name+".")
            }
            if t.type == TOKEN_TYPE_VAR && t.isFunc == false && t.isOper == false {
                if fn.isImported == true || fn.isMut == true {
                    let rp = searchVarByToken(&t, elems) then {
                        rp.lastSet = elems
                        if rp.isArg == true {
                            currentFn.isMut = true
                        }
                    }
                }
            }
            if fn.isVar {
                fn.fromVar = parent
                fn.name = t.cont + sep + fn.name
            }
            if parent == null {
                throwErr(&t, "Could not find structure {TOKEN}.")
            }
            valueFunc(fn, parent, l, i, ltp, elems)
            fnt = l[i]
            delete(l, i)
            fnt.ogCont = t.ogCont + "." + nt.ogCont
            fnt.pos = t.pos
            l[tokPos] = fnt
            return tokPos
        }
    }

    //member is a variable
    m = searchStructMemb(nt.cont, s, elems)
    if m == null {
        throwErr(&nt, "Unknown struct member {TOKEN} in struct '"+s.name+"'.")
    }
    ast = ""
    if t.cont[0] == '&' {
        ast = "*"
    }

    //Accessed member can be a method even if it is not called.
    //Because function pointers of methods are not stored inside the struct,
    //we need to return the C name of the function.
    if m.isFn == true {
        t.cont = s.name+"__"+m.name
    } else {
        if t.type == TOKEN_TYPE_VAR {
            t.parent = searchVarByToken(&t, elems)
        }
        t.cont += sep + nt.cont
    }

    t.ogCont += "."+nt.cont
    t.bahType = m.type + ast
    r = new variable {
        name: t.cont
        type: t.bahType
    }
    t.setRefVar(r)

    l[tokPos] = t
    return tokPos
}

//Makes a var token from ['a', '[', 'i', ']'].
//Also handles a[s:e], a[s:] and a[:e].
valueArr(l []Tok, i int, ltp lineType, elems Elems*) int {
    tokPos = i-1
    //get previous value
    pt = l[tokPos]
    delete(l, tokPos)
    if pt.isValue == false {
        throwErr(&pt, "Cannot use {TOKEN} as value (array).")
    }
    ptt = string(getTypeFromToken(&pt, true, elems))

    if pt.hasAmp {
        pt.cont = pt.cont[1:]
    }
    //make return token
    t = pt
    t.isValue = true
    t.ogCont += "["

    //pre-processing index value
    nbEncls = 1
    memory = []Tok
    i = tokPos+1
    for i < len(l), i++ {
        tmpT = l[i]
        if tmpT.cont == "(" || tmpT.cont == "{" || tmpT.cont == "[" {
            nbEncls++
        } else if tmpT.cont == ")" || tmpT.cont == "}" || tmpT.cont == "]" {
            nbEncls--
            t.ogCont += "]"
            if nbEncls == 0 {
                break
            }
        }
        t.ogCont += tmpT.ogCont
        memory[len(memory)] = tmpT
    }
    deleteRange(l, tokPos+1, i)
    memory = prePross(memory, <lineType>-1, elems)
    
    //handle empty index
    if len(memory) == 0 {
        throwErr(&pt, "Cannot access empty index of array {TOKEN}.")
    }

    // parsing substitution values
    split = false
    from = ""
    to = ""
    if len(memory) > 1 {
        split = true
        first = memory[0]
        second Tok
        third Tok

        //a[s:e]
        if len(memory) == 3 {
            second = memory[1]
            third = memory[2]
            firstT = getTypeFromToken(&first, true, elems)
            if compTypes(firstT, "int") == false {
                throwErr(&first, "Cannot use {TOKEN} as int.")
            }
            thirdT = getTypeFromToken(&third, true, elems)
            if compTypes(thirdT, "int") == false {
                throwErr(&third, "Cannot use {TOKEN} as int.")
            }
            if second.cont != ":" {
                throwErr(&second, "Expected ':' not {TOKEN}.")
            }
            from = first.cont
            to = third.cont
        } else if len(memory) == 2 { //a[s:] or a[:e]
            second = memory[1]

            if first.cont == ":" { //a[:e]
                from = "0"
                secondT = getTypeFromToken(&second, true, elems)
                if compTypes(secondT, "int") == false {
                    throwErr(&second, "Cannot use {TOKEN} as int.")
                }
                to = second.cont
            } else if second.cont == ":" { //a[s:]
                firstT = getTypeFromToken(&first, true, elems)
                if compTypes(firstT, "int") == false {
                    throwErr(&first, "Cannot use {TOKEN} as int.")
                }
                from = first.cont
            } else {
                throwErr(&second, "Expected ':' not {TOKEN}")
            }
        } else {
            throwErr(&memory[3], "Cannot substiture with more than 2 values, expected ']' not {TOKEN}.")
        }
    }

    if ptt.hasPrefix("[]") { //is array
        if split == false {
            index = memory[0]
            if compTypes(getTypeFromToken(&index, true, elems), "int") == false {
                throwErr(&index, "Cannot use {TOKEN} as array index (int).")
            }
            if (ltp == LINE_TYPE_VAR && tokPos == 0 && len(l) > tokPos+1 && l[tokPos+1].cont == "=") == false {
                checkBounds(&pt, 0, &index, elems)
            }
            ptt.trimLeft(2)
            t.bahType = ptt.str()
            isFunc = ptt.hasPrefix("function(")
            if isFunc {
                t.cont = genCompilerVar()
                tmpFn = parseFnType(ptt)
                tmpFn.name = t.cont
                t.setRefFn(tmpFn)
                OUTPUT += rope(getCtypeFromFunc(tmpFn, elems)+" = ((void**)"+pt.cont+"->data)["+index.cont+"];\n")
            } else {
                t.cont = "(("+getCType(ptt.str(), elems).str()+"*)"+pt.cont+"->data)["+index.cont+"]"
            }

            indT = new Tok
            *indT = index
            rootT = new Tok
            *rootT = pt

            if t.hasAmp {
                t.bahType += "*"
                t.processedPtr = true
            }

            if isFunc == false {
                tmpV = new variable {
                    name: pt.ogCont
                    type: t.bahType
                    isArray: true
                    arrIndex: indT
                    arrRoot: rootT
                }

                t.setRefVar(tmpV)
            }

        } else {
            t.bahType = ptt.str()
            if to == "" {
                to = pt.cont+"->length"
            }
            t.isFunc = true
            t.cont = "arraySubstitute("+pt.cont+", "+from+", "+to+")"
            r = new variable {
                name: pt.ogCont+"[:]"
                type: ptt.str()
                isArray: true
            }
            t.setRefVar(r)
        }

    } else if ptt.hasPrefix("buffer:") { //is a buffer
        if split == false {
            t.bahType = "char"
            index = memory[0]
            if compTypes(getTypeFromToken(&index, true, elems), "int") == false {
                throwErr(&index, "Cannot use {TOKEN} as buffer index (int).")
            }
            checkBounds(&pt, 1, &index, elems)
            t.cont = pt.cont+"["+index.cont+"]"
            r = new variable {
                name: pt.ogCont+"["+index.ogCont+"]"
                type: "char"
            }
            t.setRefVar(r)
        } else {
            t.bahType = "cpstring"
            if to == "" {
                to = "strlen("+pt.cont+")"
            }
            t.isFunc = true
            t.cont = "cpstringSubsitute("+pt.cont+", "+from+", "+to+")"
            r = new variable {
                name: pt.ogCont+"[:]"
                type: "cpstring"
            }
            t.setRefVar(r)
        }
    } else if ptt.hasPrefix("map:") { //is a map
        if split == true {
            throwErr(&pt, "Cannot do substitution on a map {TOKEN}.")
        }
        ptt.trimLeft(4)
        elemType = getCType(ptt.str(), elems)
        index = memory[0]
        if compTypes(getTypeFromToken(&index, true, elems), "cpstring") == false {
            throwErr(&index, "Cannot use {TOKEN} as map index (cpstring).")
        }
        if RCPavailable() {
            index.cont = registerRCPtrackedVar("cpstring", index.cont, elems)
        }
        if tokPos == 0 && ltp == LINE_TYPE_VAR { //setting map value
            tmpV = new variable {
                name: "keep_ref_"+genCompilerVar()
                type: ptt.str()
                declScope: elems
            }
            t.setRefVar(tmpV)
            elems.vars[len(elems.vars)] = tmpV
            if isGlobal() {
                INIT += rope(elemType.str() + " " + tmpV.name+";\n")
            } else {
                OUTPUT += rope(elemType.str() + " " + tmpV.name+";\n")
            }
            if isRCPpointerType(ptt.str()) {
                NEXT_LINE = pt.cont+"->set("+pt.cont+", "+index.cont+", "+tmpV.name+");\n"
            } else {
                NEXT_LINE = "mapWrapper__setAny("+pt.cont+", "+index.cont+", &"+tmpV.name+", sizeof("+elemType.str()+"));\n"
            }
            t.cont = tmpV.name
            t.bahType = ptt.str()
        } else { //getting map value
            t.isFunc = true
            res rope*
            tmpV = genCompilerVar()
            if isRCPpointerType(ptt.str()) {
                res = rope(elemType.str()+" "+tmpV+"="+t.cont+"->get("+t.cont+", "+index.cont+");\n")
                t.cont = tmpV 
            } else {
                res = rope(elemType.str() + "* "+tmpV+"="+pt.cont+"->get("+pt.cont+", "+index.cont+");\n")
                t.cont = "("+elemType.str()+")(*"+tmpV+")"
            }
            tmpVr = new variable{
                name: tmpV
                type: ptt.str()
            }
            t.setRefVar(tmpVr)
            if isGlobal() {
                INIT += res
            } else {
                OUTPUT += res
            }
            t.bahType = ptt.str()
        }

    } else if ptt.str() == "cpstring" { // is a string
        t.isFunc = true
        if split == false {
            t.bahType = "char"
            index = memory[0]
            if compTypes(getTypeFromToken(&index, true, elems), "int") == false {
                throwErr(&index, "Cannot use {TOKEN} as cpstring index (int).")
            }
            checkBounds(&pt, 2, &index, elems)
            t.cont = pt.cont+"["+index.cont+"+4]"
            r = new variable {
                name: pt.ogCont+"["+index.ogCont+"]"
                type: "char"
            }
            t.setRefVar(r)
        } else {
            if to == "" {
                to = "strlen("+pt.cont+")"
            }
            t.cont = "cpstringSubsitute("+pt.cont+", "+from+", "+to+")"
            r = new variable {
                name: pt.ogCont+"[:]"
                type: "cpstring"
            }
            t.setRefVar(r)
        }
    } else if ptt.hasPrefix("[") && ptt.hasSuffix("]") { // is a tuple
        t.isOper = true
        parts = getTypesFromTuple(ptt.str())
        index = memory[0]
        ind = 0
        if compTypes(getTypeFromToken(&index, true, elems), "int") {
            if isStaticToken(&index, elems) == false {
                throwErr(&index, "Tuple cannot be indexed at runtime. Use a static value instead of {TOKEN}.")
            }
            ind = strToInt(getStaticValue(&index, elems))
            if ind >= len(parts) || ind < 0 {
                throwErr(&index, "Cannot access index {TOKEN} ("+intToStr(ind)+") of tuple "+pt.ogCont+" ("+ptt.str()+") of length "+intToStr(len(parts))+".")
            }
        } else {
            throwErr(&index, "Tuple cannot get index {TOKEN} of a tuple. Wanted int, got "+getTypeFromToken(&index, true, elems)+".")
        }
        
        name = genCompilerVar()

        offsets = "0"
        j=0; for j < ind, j++ {
            offsets += "+ sizeof("+getCType(parts[j], elems).str()+")"
        }

        t.cont = "*("+getCType(parts[ind], elems).str()+"*)((char*)"+pt.cont+"+"+offsets+")"
        r = new variable {
            name: t.cont
            type: parts[ind]
        }
        t.setRefVar(r)
        t.bahType = parts[ind]
    } else {
        throwErr(&pt, "Cannot use {TOKEN} ("+ptt.str()+") as an indexable value.\nIndexable values are [array, buffer, cpstring, tuple, map].")
    }

    if t.hasAmp {
        t.cont = "&" + t.cont
    }

    t.isValue = true    
    l[tokPos] = t


    return tokPos
}

//Makes a bool token from a condition ['a', '==', 'b'].
valueBool(l []Tok, i int, ltp lineType, elems Elems*) int {

    tokPos = i-2 //because 'i' is the index of 'b' in 'a == b'.

    // get previous value
    pt = l[tokPos]
    ptt = getTypeFromToken(&pt, true, elems)

    t = l[tokPos+1]

    // In case of '(else) if a == b', do indepth checks for switch optimization.
    //Condition checked here because deleteRange() comes after.
    isSingleCheck = t.cont == "==" && ((ltp == LINE_TYPE_IF && len(l) == 4) || (ltp == LINE_TYPE_ELSE && len(l) == 5)) 

    deleteRange(l, tokPos, tokPos+1)

    //sets looping variable as register (optimization).
    if isFixMeEnabled == false && ltp == LINE_TYPE_FOR && ptt == "int" || ptt == "float" {
        v = getRealVar(pt.cont, elems)
        if v != null {
            v.iterScope = elems
            if v.canBeReg == true && v.isReg == false && v.declRope != null {
                odecl = v.declRope.toStr()
                if strHasPrefix(odecl, "register ") == false {
                    OUTPUT.totalLen += ropeSet(v.declRope, "register "+odecl)
                }
                v.isReg = true
            }
        }
    }

    //Checking condition of branch for safety checks,
    //if the the previous condition did not allow a null value inside the code block and this previous
    //condition is not chained with '&&', a null value could be passed inside the scope.
    if isUnsafe == false {
        if tokPos > 0 {
            if l[tokPos-1].cont != "&&" {
                clear(currChecks)
            }
        } else {
            clear(currChecks)
        }
    }

    //checking if two values are the same type
    nt = l[tokPos]
    ntt = getTypeFromToken(&nt, true, elems)

    if RCPavailable() {
        RCPkeepFuncRef(&pt, ptt, elems)
        RCPkeepFuncRef(&nt, ntt, elems)
    }

    //Checking if condition allows for swhitch instead of else if.
    //Must check if number var is equal to const.
    if isSingleCheck && ptt != "bool" && isTypeCprim(ptt, elems) {
        varTok Tok* = null
        cnstTok Tok* = null
        if pt.type == TOKEN_TYPE_VAR {
            sv = searchVirtVarByToken(&pt, elems)
            if sv != null {
                varTok = &pt
                cnstTok = &nt
            }
        }

        if varTok == null && nt.type == TOKEN_TYPE_VAR {
            sv = searchVirtVarByToken(&nt, elems)
            if sv != null {
                varTok = &nt
                cnstTok = &pt
            }
        }

        if varTok != null && cnstTok != null && isStaticToken(cnstTok, elems) {
            valT = new Tok
            *valT = *cnstTok
            varT = new Tok
            *varT = *varTok
            pt.switchOpt = new switchOptimization {
                var: varT
                value: valT
            }
        }
    }

    if t.cont == "in" {
        arrT = string(ntt)
        if arrT.hasPrefix("[]") == 0 {
            throwErr(&nt, "Cannot use {TOKEN} ("+ntt+") as array.")
        }
        arrT.trimLeft(2)
        if compTypes(ptt, arrT.str()) == false {
            throwErr(&pt, "Cannot search for {TOKEN} ("+ptt+") in "+ntt+".")
        }
        
        //Generate the C function that will be called to check weither a is inside the array b.
        comp = ""
        if ptt == "cpstring" {
            comp = "((char**)arr->data)[i] != 0 && strcmp(((char**)arr->data)[i], el) == 0"
        } else {
            comp = "(("+getCType(arrT.str(), elems).str()+"*)arr->data)[i] == el"
        }
        name = genCompilerVar()
        if arrT.charAt(arrT.length-1) == '*' {
            nbast = arrT.countChar('*')
            arrT.trimRight(nbast)
        }
        
        fnTest = "char "+name+"(struct Bah_Array_Type* arr, "+getCType(ptt, elems).str()+" el) {
        if (arr == 0) {
            return 0;
        };
        for(int i=arr->length-1; i!=-1;i--) {
            if ("+comp+") {
                return 1;
            };
        }
        return 0;
        }\n"
        
        //Declare the function inside the global scope.
        postDeclHandle.append(rope(fnTest))

        fnCall = name+"("+nt.cont+", "+pt.cont+")" 

        pt.isExpensive = true
        pt.cont = fnCall
    } else {
        if compTypes(ptt, ntt) == false {
            throwErr(&nt, "Cannot compare {TOKEN} ("+ntt+") with type "+ptt+".")
        }
        if ptt == "cpstring" {
            if t.cont == "==" {
                pt.cont = "(strcmp("+pt.cont+", "+nt.cont+") == 0)"

            } else if t.cont == "!=" {
                pt.cont = "(strcmp("+pt.cont+", "+nt.cont+") != 0)"
            } else if t.cont == ">" {
                pt.cont = "(strlen("+pt.cont+") > srtlen("+nt.cont+"))"
            } else if t.cont == "<" {
                pt.cont = "(strlen("+pt.cont+") < srtlen("+nt.cont+"))"
            } else if t.cont == ">=" {
                pt.cont = "(strlen("+pt.cont+") >= srtlen("+nt.cont+"))"
            } else if t.cont == "<=" {
                pt.cont = "(strlen("+pt.cont+") <= srtlen("+nt.cont+"))"
            }
            pt.isExpensive = true
        } else {
            if isUnsafe == false && pt.type == TOKEN_TYPE_VAR && pt.isOper == false && isRCPpointerType(ptt) {
                ptV = searchVirtVarByToken(&pt, elems)
                if ptV != null {
                    ntIsNull = false
                    if nt.cont == "null" {
                        ntIsNull = true
                    } else if nt.type == TOKEN_TYPE_VAR && nt.isOper == false {
                        nv = searchVirtVarByToken(&nt, elems)
                        if nv != null {
                            ntIsNull = nv.canBeNull
                        }
                    } else if nt.isFunc == true {
                        fn = searchFuncByToken(&nt, elems)
                        if fn != null && fn.returns != null {
                            ntIsNull = fn.returns.type[len(fn.returns.type)-1] == '!'
                        }
                    }
                    if t.cont == "==" {
                        currChecks[len(currChecks)] = varCheck{
                            v: ptV
                            checkNull: ntIsNull
                        }
                    } else if t.cont == "!=" {
                        currChecks[len(currChecks)] = varCheck{
                            v: ptV
                            checkNull: ntIsNull == false
                        }
                    }
                }
            }
            if isExprExpensive(&pt) || isExprExpensive(&nt) {
                pt.isExpensive = true
            } else {
                pt.isExpensive = false
            }
            pt.cont = "(" + pt.cont + t.cont + nt.cont + ")"
        }
    }


    pt.isOper = true
    pt.bahType = "bool"
    pt.isValue = true
    l[tokPos] = pt
    return tokPos
}

//Makes a var token from an operation: ['a', '+', 'b'].
//Also handles 'a++' and 'a--'.
valueOper(l []Tok, i int, elems Elems*) int {
    tokPos = i - 2
    //get previous value
    pt = l[tokPos]
    ptt = getTypeFromToken(&pt, true, elems)

    //get operator
    t = l[tokPos+1]
    deleteRange(l, tokPos, tokPos+1)

    //get second value
    nt = l[tokPos]
    
    //for increment and decrement
    if nt.cont == t.cont {
        pt.isOper = true
        pt.cont = t.cont + t.cont + pt.cont
        if pt.type == TOKEN_TYPE_VAR && pt.getRefVar() == null {
            v = searchVar(pt.cont, &pt, elems)
            pt.setRefVar(v)
        }
        l[tokPos] = pt
        return tokPos
    }

    //check if the two values are the same type
    ntt = getTypeFromToken(&nt, true, elems)
    if compTypes(ptt, ntt) == false {
        throwErr(&nt, "Cannot operate {TOKEN} ("+ntt+") as "+ptt+".")
    }

    if ptt == "ptr" {
        throwErr(&pt, "Cannot do operation on {TOKEN} (ptr).")
    }
    if ntt == "ptr" {
        throwErr(&nt, "Cannot do operation on {TOKEN} (ptr).")
    }

    if RCPavailable() {
        RCPkeepFuncRef(&pt, ptt, elems)
        RCPkeepFuncRef(&nt, ntt, elems)
    }

    //parse string concatenation
    if ptt == "cpstring" {
        //add first two cpstrings to the concat array
        //strs contains all the cpstrings to concatenate in reverse order
        strs = []cpstring{nt.cont, pt.cont}

        if t.cont != "+" {
            throwErr(&t, "Can only do concatenation on cpstring, not {TOKEN}.")
        }
        
        //concatenate all strings at once to reduce memory allocations
        if tokPos -1 >= 0 {
            nat = l[tokPos-1]
            if nat.cont == "+" {
                rangeEnds = tokPos-1
                i = tokPos-2
                nb = 2
                for i >= 0, i-- {
                    tokPos = i
                    currStrTk = l[i]
                    //type guard
                    tt = getTypeFromToken(&currStrTk, true, elems)
                    if compTypes(tt, "cpstring") == false {
                        throwErr(&currStrTk, "Cannot concatenate cpstring with {TOKEN} ("+tt+").")
                    }
                    //add to the array of cpstrings to allocate
                    strs[len(strs)] = currStrTk.cont

                    if i-1 >= 0 {
                        i--
                        t = l[i]
                        if t.cont != "+" {
                            if t.cont in signs {
                                throwErr(&t, "Can only do concatenation on cpstring, not {TOKEN}.")
                            } else {
                                i++
                                break
                            }
                        }
                    } else {
                        i = 0
                        break
                    }
                }
                deleteRange(l, i, rangeEnds)
            } else if nat.cont in signs {
                throwErr(&nat, "Can only do concatenation on cpstring, not {TOKEN}.")
            }
        }

        //build concatenation code

        pt.type = TOKEN_TYPE_VAR
        pt.isValue = true
        pt.cont = genConcat(strs, elems)
        pt.isOper = false
    } else {

        s = searchStruct(ptt, elems)
        //Cannot do operation on struct, except if they are defined as methods (.add(), .sub()...).
        if s != null {
            sep = "."
            amp = "&"

            if isRCPpointerType(ptt) {
                sep = "->"
                amp = ""
            }
            mName = ""
            if t.cont == "+" {
                mName = "add"
            } else if t.cont == "-" {
                mName = "sub"
            } else if t.cont == "*" {
                mName = "mult"
            } else if t.cont == "/" {
                mName = "div"
            } else {
                throwErr(&pt, "Undefined operation on struct {TOKEN} ("+ptt+").")
            }
            methd = searchStructMemb(mName, s, elems)
            if methd != null && methd.isFn == true {
                pt.cont = s.name + "__" + mName + "(" +amp+pt.cont + ", " + nt.cont + ")"
                pt.isFunc = true
            }
        } else {
            //The two values are primitive types, then symply concatenate their contents.
            pt.cont += t.cont + nt.cont
        }
        pt.isOper = true

    }
    pt.isNotExpsvOper = false
    l[tokPos] = pt
    return tokPos
}

//Makes a var token from ['a', '->', 'c'].
valueSendChan(l []Tok, i int, elems Elems*) int {
    posTok = i-2
    //value to send
    nt = l[posTok]
    //channel
    pt = l[posTok+2]
    deleteRange(l, posTok, posTok+2)

    ntt = getTypeFromToken(&nt, true, elems)

    ptt = string(getTypeFromToken(&pt, true, elems))
    if ptt.hasPrefix("chan:") == 0 {
        throwErr(&pt, "Cannot use {TOKEN} ("+ptt.str()+") as chan.")
    }
    ptt.trimLeft(5)

    if isGlobal() {
        throwErr(&pt, "Cannot send to channel {TOKEN} of a function.")
    }

    if compTypes(ntt, ptt.str()) == false {
        throwErr(&nt, "Cannot send {TOKEN} ("+ntt+") through chan:"+ptt.str()+".")
    }

    //If it is a pointer, send it throug the channel.
    if isRCPpointerType(ptt.str()) {
        OUTPUT += rope("channel__send("+pt.cont+", "+nt.cont+");\n")
    } else { //Else, because the scope may expire before it is received, copy the value's content to a heap pointer.
        ct = getCType(ntt, elems)
        tmpV = genCompilerVar()
        OUTPUT += rope("
        "+ct.str()+" "+tmpV+" = "+nt.cont+";
        channel__sendAny("+pt.cont+", &"+tmpV+", sizeof("+tmpV+"));
        ")
    }

    return posTok
}

//Makes a func token from ['<-', 'c'].
valueChan(l []Tok, i int, elems Elems*) int {
    posTok = i-1
    delete(l, posTok) //<-

    //channel token
    nt = l[posTok]
    
    ntt = string(getTypeFromToken(&nt, true, elems))
    if ntt.hasPrefix("chan:") == 0 {
        throwErr(&nt, "Cannot use {TOKEN} ("+ntt.str()+") as chan.")
    }

    ntt.trimLeft(5)

    if isGlobal() {
        throwErr(&nt, "Cannot receive from chan {TOKEN} outside a function body.")
    }

    ct = getCType(ntt.str(), elems)
    //If the value is a pointer, simply return it.
    if isRCPpointerType(ntt.str()) {
        tmpV = registerRCPtrackedVar(ntt.str(), "channel__receive("+nt.cont+")", elems)
        nt.cont = tmpV
    } else { //Else, dereference the pointer to get the value.
        if RCPavailable() {
            tmpV = registerRCPtrackedVar(ct.str()+"*", "channel__receive("+nt.cont+")", elems)
            nt.cont = "*"+tmpV
        } else {
            nt.cont = "*("+ct.str()+"*)channel__receive("+nt.cont+")"
        }
    }

    nt.type = TOKEN_TYPE_FUNC
    nt.isFunc = true
    nt.isValue = true
    nt.bahType = ntt.str()

    l[posTok] = nt

    return posTok
}

//Makes a var token from a tuple declaration: [a,b].
valueTuple(l []Tok, i int, elems Elems*) int {
    tokPos = i

    nbBracks = 0
    if l[tokPos+1].cont == "]" {
        //is arr type
        offset = 1
        for l[tokPos+offset+1].cont == "[" && l[tokPos+offset+2].cont == "]" {
            offset += 2
        }
        if l[tokPos+offset+1].type == TOKEN_TYPE_VAR || l[tokPos+offset+1].cont == "function" {
            return tokPos+1
        }
        throwErr(&l[tokPos], "Cannot declare {TOKEN} empty tuple.")
    }



    vals = []cpstring

    nbEncl = 1
    i++; for i < len(l), i++ {
        if l[i].cont == "[" || l[i].cont == "(" {
            nbEncl++
        } else if l[i].cont == "]" || l[i].cont == ")" {
            nbEncl--
            if nbEncl == 0 {
                break
            }
        }
    }

    memory = l[tokPos+1:i+1]
    deleteRange(l, tokPos+1, i)

    memory = prePross(memory, <lineType>-1, elems)
    ft = memory[0]
    tupT = ""
    size = ""
    types = []cpstring

    j=0; for j < len(memory), j += 2 {
        t = memory[j]
        tt = getTypeFromToken(&t, true, elems)
        tupT += tt
        types[len(types)] = tt
        size += "sizeof("+getCType(tt, elems).str()+")"
        vals[len(vals)] = t.cont
        nt = memory[j+1]
        if nt.cont == "]" {
            break
        } else if nt.cont != "," {
            throwErr(&nt, "Expected separator between values in tuple declaration, got {TOKEN}.")
        }
        tupT += ","
        size += "+"
    }

    type = "["+tupT+"]"

    allocator = "alloca"
    if isGlobal() {
        allocator = "memoryAlloc"
    }

    v = registerRCPvar(type, allocator+"("+size+")", elems)
    offsetVar = genCompilerVar()

    r = "long int "+offsetVar+" = 0;\n"
    k=0; for k < len(vals), k++ {
        ct = getCType(types[k], elems).str()
        r += "*("+ct+"*)((char*)"+v+" + "+offsetVar+") = "+vals[k]+";\n"+offsetVar+"+=sizeof("+ct+");\n"
    }
    
    if isGlobal() {
        INIT += rope(r)
    } else {
        OUTPUT += rope(r)
    }

    l[tokPos].type = TOKEN_TYPE_VAR
    l[tokPos].bahType = type
    l[tokPos].cont = v
    l[tokPos].isValue = true

    return tokPos
}

//Is the token a 'small' value.
//This means a function call/variable (including array element and struct element).
//This will return false if the token is a not yet parsed parenthesis: ['(', 'a', '+', 'b', ')'].
//A small value is smaller than a value because it can form an operation,
//if the value is inside an operation, it is not a 'small' value because it can be evaluated further.
isSmallValue(l []Tok, i int) bool {
    t = l[i]
    if t.type == TOKEN_TYPE_CAST || t.cont == "(" {
        return false
    } else if t.isValue == false {
        throwErr(&t, "Cannot use {TOKEN} as value.")
    }
    if i+1 < len(l) {
        nt = l[i+1]
        if nt.cont == "[" || nt.cont == "." || nt.cont == "(" {
            return false
        }
    }
    return true
}

//Does the same as the function above 'isSmallValue()' but if the value is an operand of a not yet parsed operation,
//then it is not yet a value but a small value because it can be evaluated further.
//This returns true only if the value cannot be evaluated further.
isValue(l []Tok, i int) bool {
    t = l[i]
    if t.type == TOKEN_TYPE_CAST || t.cont == "(" {
        return false
    } else if t.isValue == false {
        throwErr(&t, "Cannot use {TOKEN} as value.")
    }
    if i+1 < len(l) {
        nt = l[i+1]
        if nt.cont == "[" || nt.cont == "." || nt.cont == "(" || nt.cont in signs || (nt.isValue && nt.cont[0] == '-') {
            return false
        }
    }
    return true
}