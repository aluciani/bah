#include "iostream.bah"
#include "string.bah"

#include "./globals.bah"


#include "./errors.bah"
#include "./lexer.bah"
#include "./type.bah"
#include "./fns.bah"

searchVar(name cpstring, elems Elems*) variable* {
    ogName = name
    n = string(name)
    n.replace("&", "")
    n.replace("*", "")
    
    if n.hasSuffix("]") {
        i=n.length; for i > 0 {
            c = n.charAt(i)
            if c == '[' {
                break
            }
            i = i - 1
        }
        tamm = n.length - i
        n.trimRight(tamm + 6)
        name = n.str()
        v = searchVar(name, elems)
        
        vt = string(v.type)
        vt.trimLeft(2)
        vtstr = vt.str()

        nv = new variable
        nv.type = vtstr
        nv.name = ogName
        nv.isArray = true
        return nv
    }
    
    name = n.content


    if hasStructSep(n) && n.count(")") == 0 {
        rn = splitStructSepBefore(n)
        name = rn.content
        n.trimLeft(rn.length)
        if n.hasPrefix(".") {
            n.trimLeft(1)
        } else {
            n.trimLeft(2)
        }
        membs = n.content
        v = searchVar(name, elems)
        if v == null {
            return null
        }
        s = searchStruct(v.type, elems)
        if s == null {
            return null   
        }
        memb = searchStructMemb(membs, s, elems)
        if memb == null {
            return null
        }
        nv = new variable
        nv.from = memb.from
        nv.name = memb.name
        nv.type = memb.type
        nv.name = ogName

        r = nv.type
        tcc = string(ogName)
        if tcc.count("&") {
            r = r + "*"
        }
        nbUnaries = tcc.count("*")
        if nbUnaries > 0 {
            ct = string(r)
            pointerLevel = ct.count("*")
            if pointerLevel < nbUnaries {
                throwErr(null, "Cannot use '*' on "+nv.name+" because it is not pointer.")
            }
            ct.trimRight(nbUnaries)
            r = ct.str()
        }
        nv.type = r
        nv.name = ogName

        return nv
    }


    i=0; for i < len(elems.vars) {
        v = elems.vars[i]
            if v == null {
                panic("\e[1;31m[INTERNAL COMPILER ERROR]\e[0m\n Please report the bug as 'compiler searching '"+name+"' resulting in null var'.")    
            }
        if v.name == name {
            nv = new variable
            nv.type = v.type
            nv.name = v.name
            nv.isConst = v.isConst
            r = nv.type
            tcc = string(ogName)
            if tcc.count("&") {
                r = r + "*"
            }

            nbUnaries = tcc.count("*")
            if nbUnaries > 0 {
                ct = string(r)
                pointerLevel = ct.count("*")
                if pointerLevel < nbUnaries {
                    throwErr(null, "Cannot use '*' on "+v.name+" because it is not pointer.")
                }
                ct.trimRight(nbUnaries)
                r = ct.str()
            }
            nv.type = r
            nv.name = ogName

            return nv
        }
        // else {
        //     println(name+" != "+v.name)
        // }
        i = i + 1
    }

    i=0; for i < len(elems.fns) {
        fn = elems.fns[i]
        if fn.name == name {
            nv = new variable
            nv.name = name
            nv.type = "function("
            j=0; for j < len(fn.args) {
                arg = fn.args[j]
                nv.type = nv.type + arg.type
                j = j + 1
                if j < len(fn.args) {
                    nv.type = nv.type + ","
                }
            }
            nv.type = nv.type + ")" + fn.returns.type
            return nv
        }
        i = i + 1
    }



    return null

}

setCType(v variable*, elems Elems*) cpstring {
        tp = getCType(v.type, elems)
        t = tp.str()
        t = t + " " + v.name
        return t
}

getTypeFromToken(t Tok*, strict bool, elems Elems*) cpstring {
    if strlen(t.bahType) > 0 {
        r = t.bahType
        return r
    }
    if t.type == TOKEN_TYPE_VAR {
        v = searchVar(t.cont, elems)
        if v == null {
            if strict == true {
                throwErr(t, "Unknown var {TOKEN}.")
            } else {
                return ""
            }
        }
        if strict == true {
            if strlen(v.type) == 0 {
                throwErr(t, "Cannot use {TOKEN} because it does not have any type.")
            }
        }
        r = v.type        
        return r
    }

    if t.type == TOKEN_TYPE_FLOAT {
        return "float"
    }
    if t.type == TOKEN_TYPE_INT {
        return "int"
    }
    if t.type == TOKEN_TYPE_STR {
        return "cpstring"
    }
    if t.type == TOKEN_TYPE_CHAR {
        return "char"
    }
    if t.type == TOKEN_TYPE_BOOL {
        return "bool"
    }
    
    throwErr(t, "Cannot use {TOKEN} as value.")
    return ""

}

parseFnType(cvt string) func* {
    nf = new func
    cvt.trimLeft(9)
    memory = []char
    j=0; for j < cvt.length {
        c = cvt.charAt(j)
        if c == ')' {
            break
        }
        arg = new variable
        arg.name = "arg_"+intToStr(len(nf.args))
        for j < cvt.length {
            c = cvt.charAt(j)
            if c == ',' || c == ')' {
                break
            }
            memory[len(memory)] = c
            j = j + 1
        }
        arg.type = arrToStr(memory)
        clear(memory)
        nf.args[len(nf.args)] = arg
        if c == ')' {
            break
        }
        j = j + 1
    }
    j = j + 1
    for j < cvt.length {
        c = cvt.charAt(j)
        memory[len(memory)] = c
        j = j + 1
    }
    nf.returns = new variable
    nf.returns.name = "_return"
    nf.returns.type = arrToStr(memory)
    return nf
}


searchFunc(name cpstring, elems Elems*, inclCurr bool) func* {
    ogName = name
    if name == "noCheck" {
        fn = new func
        fn.name = "noCheck"
        return fn
    }
    n = string(name)
    if hasStructSep(n) {
        fnName = splitStructSepAfter(n)
        n.trimRight(fnName.length)
        c = n.charAt(n.length-1)
        if c == '.' {
            n.trimRight(1)
        } else {
            n.trimRight(2)
        }
        name = n.str()
        v = searchVar(name, elems)
        s = searchStruct(v.type, elems)
        memb = searchStructMemb(fnName.str(), s, elems)
        name = fnName.content
        name = memb.from+"__"+name

    }
    
    fns = elems.fns
    i=0; for i < len(fns) {
        fn = fns[i]
        if fn == null {
                panic("\e[1;31m[INTERNAL COMPILER ERROR]\e[0m\n Please report the bug as 'compiler searching '"+name+"' resulting in null func'.")    
        }
        if fn.name == name {
            fn.used = true
            return fn
        }
        i = i + 1
    }

    if inclCurr == true {
        if currentFn.name == name {
            currentFn.used = true
            return currentFn
        }
    }

    v = searchVar(ogName, elems)
    if v == null {
        return null
    }
    nf = new func
    nf.name = ogName
    cvt = string(v.type)
    if cvt.hasPrefix("function(") == 0 {
        return null
    }
    pfn = parseFnType(cvt)
    nf.returns = pfn.returns
    nf.args = pfn.args
    return nf
}

#define RCPavailable() bool

declareStructMethods(v variable*, s cStruct*, elems Elems*) cpstring {
    code = ""
    members = s.members
    typec = string(v.type)
    sep = "."
    if typec.count("*") {
        sep = "->"
    }
    i=0; for i < len(members) {
        m = members[i]
        cmpt = string(m.type)
        declared = false
        if strlen(m.def) > 0 {
            code = code + v.name + sep + m.name + " = " + m.def + ";\n"
            declared = true
        }
        if cmpt.hasPrefix("[]") == 1 {
            cmpt.trimLeft(2)
            cmptstr = cmpt.str()
            elemCType = getCType(cmptstr, elems)
            elemCTypeStr = elemCType.str()
            code = code + v.name + sep + m.name + " = memoryAlloc(sizeof(array("+elemCTypeStr+")));
            "+v.name+sep+m.name+"->length = 0;
            "+v.name+sep+m.name+"->elemSize = sizeof("+elemCTypeStr+");
            "
            declared = true
        }

        if isRCPpointerType(m.type) && declared == false {
            code = code + v.name + sep + m.name + "= null;\n"
        }

        i = i + 1
    }

    if strlen(s.extendedFrom) > 0 {
        es = searchStruct(s.extendedFrom, elems)
        i=0; for i < len(es.methods) {
            m = es.methods[i]
            code = code + v.name + sep + m.name + " = " + es.name + "__" + m.name + ";\n"
            i = i + 1
        }
    }

    methods = s.methods
    i=0; for i < len(methods) {
        m = methods[i]
            code = code + v.name + sep + m.name + " = " + s.name + "__" + m.name + ";\n"
        i = i + 1
    }

    if s.isBinding == false && RCPavailable() && s.hasRCPmemb == true {
        if strCount(v.type, "*") == 0 {
            code = code + v.name+".__RCP_counter = malloc(sizeof(int));*(int*)"+v.name+".__RCP_counter = 1;\n"
        } else {
            code = code + v.name+"->__RCP_counter = RCP_request("+v.name+");\n"
        }
    }

    return code
}

NB_COMP_VAR = 0

genCompilerVar() cpstring {
    name = "____BAH_COMPILER_VAR_"+intToStr(NB_COMP_VAR)
    NB_COMP_VAR = NB_COMP_VAR + 1
    return name
}

varInArr(v variable*, arr []variable*) bool {
    if arr == null {
        return false
    }
    j=0; for j < len(arr) {
        ev = arr[j]
        if ev.name == v.name {
            return true
        }
        j = j + 1
    }
    return false
}

pathToVarName(p cpstring) cpstring {
    a = strToArr(p)
    i=0; for i < len(a), i++ {
        c int = a[i]
        c -= <int>'a'
        if c < 0 {
            c = 0 - c
        }
        c = c % (<int>'z' - <int>'a')
        c += <int>'a'
        a[i] = <char>c
    }
    return arrToStr(a)
}

makeInit() {
    name = "__BAH_init"
    if isObject == true {
        name += pathToVarName(compilerState.currentFile)
    }

    // evals = "__evals_bindings = memoryAlloc("+intToStr(len(compilerState.evals))+" * sizeof(struct __eval_binding));\n"
    evals = ""
    evalsTMPDecl = "volatile struct __eval_binding __tmp__evals_bindings["+intToStr(len(compilerState.evals))+"] = {"
    i=0; for i < len(compilerState.evals), i++ {
        e = compilerState.evals[i]
        evalsTMPDecl += "{
            .name = \""+e+"\",
            .evalFn = __Bah_eval_"+e+"
        }"
        if i+1 != len(compilerState.evals) {
            evalsTMPDecl += ",\n"
        } else {
            evalsTMPDecl += "};"
        }
        // evals += "__evals_bindings["+intToStr(i)+"].name = \""+e+"\";
        // __evals_bindings["+intToStr(i)+"].evalFn = __Bah_eval_"+e+";\n"
    }

    if len(compilerState.evals) != 0 {
        evals = "__evals_bindings = __tmp__evals_bindings; __evals_length = "+intToStr(len(compilerState.evals))+";"
    } else {
        evalsTMPDecl = ""
    }

    OUTPUT = OUTPUT + rope("
    "+evalsTMPDecl+"
    void __attribute__((optimize(\"O0\"))) "+name+"() {
        ") + INIT + rope("
        "+evals+"
    };
    ")
}