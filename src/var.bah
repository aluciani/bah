#include "./globals.bah"


#include "./errors.bah"
#include "./lexer.bah"
#include "./type.bah"
#include "./fns.bah"

getRealVar(n cpstring, elems Elems*) variable* {
    i=len(elems.vars)-1; for i != -1, i-- {
        if elems.vars[i].name == n {
            return elems.vars[i]
        }
    }
    return null
}

removeVarUnar(s string*) {
    i=0; for i < s.length, i++ {
        c = s.charAt(i)
        if c != '&' && c != '*' {
            break
        }
    }
    if i != 0 {
        s.trimLeft(i)
    }
}

searchVar(name cpstring, elems Elems*) variable* {
//     recorder = timer.record("searchVar")
    ogName = name
    n = string(name)
    removeVarUnar(&n)

    if n.charAt(n.length-1) == ']' {
        i=n.length; for i > 0, i-- {
            c = n.charAt(i)
            if c == '[' {
                break
            }
        }
        tamm = n.length - i
        n.trimRight(tamm)
        isArr = n.hasSuffix("->data") == 1
        if isArr == true {
            n.trimRight(6)
        }
        name = n.str()
        v = searchVar(name, elems)
        
        vt = string(v.type)
        if isArr == true {
            vt.trimLeft(2)
        } else if vt.hasPrefix("tuple:") {
            i=vt.length-1; for i >= 0, i-- {
                if vt.charAt(i) == ':' {
                    break
                }
            }
            vt.trimLeft(i)
        } else {
            vt.set("char") //buffer
        }
        vtstr = vt.str()

        nv = new variable
        *nv = *v
        nv.type = vtstr
        nv.name = ogName
        nv.isArray = isArr
        return nv
    }
    
    name = n.content


    if hasStructSep(&n) && n.count(")") == 0 {
        rn = splitStructSepBefore(&n)
        name = rn.content
        if n.charAt(rn.length) == '.' {
            n.trimLeft(1 + rn.length)
        } else {
            n.trimLeft(2 + rn.length)
        }
        membs = n.content
        v = searchVar(name, elems)
        if v == null {
            return null
        }
        s = searchStruct(v.type, elems)
        if s == null {
            return null   
        }
        memb = searchStructMemb(membs, s, elems)
        if memb == null {
            return null
        }
        nv = new variable
        nv.from = memb.from
        nv.name = memb.name
        nv.type = memb.type
        nv.declScope = v.declScope
        nv.name = ogName

        r = nv.type
        tcc = string(ogName)
        if tcc.charAt(0) == '&' {
            r += "*"
        }
        nbUnaries = tcc.count("*")
        if nbUnaries > 0 {
            ct = string(r)
            pointerLevel = ct.count("*")
            if pointerLevel < nbUnaries {
                throwErr(null, "Cannot use '*' on '"+name+"' because it is not pointer.")
            }
            ct.trimRight(nbUnaries)
            r = ct.str()
        }
        nv.type = r
        nv.name = ogName

        return nv
    }

    i=len(elems.vars)-1; for i != -1, i-- {
        v = elems.vars[i]
        if v.name == name {
            nv = new variable
            *nv = *v
            r = nv.type
            tcc = string(ogName)
            if tcc.count("&") {
                r = r + "*"
            }

            nbUnaries = tcc.count("*")
            if nbUnaries > 0 {
                ct = string(r)
                pointerLevel = ct.count("*")
                if pointerLevel < nbUnaries {
                    throwErr(null, "Cannot use '*' on '"+name+"' because it is not pointer.")
                }
                ct.trimRight(nbUnaries)
                r = ct.str()
            }
            nv.type = r
            nv.name = ogName
            return nv
        }
    }

    i=0; for i < len(elems.fns), i++ {
        fn = elems.fns[i]
        if fn.name == name {
            nv = new variable
            nv.name = name
            nv.type = "function("
            j=0; for j < len(fn.args) {
                arg = fn.args[j]
                nv.type = nv.type + arg.type
                j = j + 1
                if j < len(fn.args) {
                    nv.type = nv.type + ","
                }
            }
            fn.used = true
            nv.type = nv.type + ")" + fn.returns.type
            return nv
        }
    }



    return null

}

searchVarByToken(t Tok*, elems Elems*) variable* {
    if t.bahRef != null {
        return t.bahRef
    }
    cont = string(t.cont)
    removeVarUnar(&cont)
    return getRealVar(cont.str(), elems)
}

searchVirtVarByToken(t Tok*, elems Elems*) variable* {
    if t.isOper == true {
        return null
    }
    if t.bahRef != null {
        return t.bahRef
    }
    return searchVar(t.cont, elems)
}

setCType(v variable*, elems Elems*) cpstring {
        tp = getCType(v.type, elems)
        t = tp.str()
        t = t + " " + v.name
        return t
}

isMissingVar(t Tok*, elems Elems*) {
    i=0; for i < len(elems.deletedVars), i++ {
        if elems.deletedVars[i].name == t.cont {
            throwErr(t, "Variable {TOKEN} has reached its end of life.")
        }
    }
}

getTypeFromToken(t Tok*, strict bool, elems Elems*) cpstring {
//     recorder = timer.record("getTypeFromToken")
    if t.bahType != "" {
        r = t.bahType
        return r
    }
    if t.type == TOKEN_TYPE_VAR {
        v = searchVar(t.cont, elems)
        if v == null {
            if strict == true {
                isMissingVar(t, elems)
                throwErr(t, "Unknown var {TOKEN}.")
            } else {
                return ""
            }
        }
        if strict == true {
            if v.type == "" {
                throwErr(t, "Cannot use {TOKEN} because it does not have any type.")
            }
        }
        t.bahType = v.type
        return v.type
    }

    if t.type == TOKEN_TYPE_FLOAT {
        return "float"
    }
    if t.type == TOKEN_TYPE_INT {
        return "int"
    }
    if t.type == TOKEN_TYPE_STR {
        return "cpstring"
    }
    if t.type == TOKEN_TYPE_CHAR {
        return "char"
    }
    if t.type == TOKEN_TYPE_BOOL {
        return "bool"
    }
    
    throwErr(t, "Cannot use {TOKEN} as value.")
    return ""

}

parseFnType(cvt string) func* {
    nf = new func
    cvt.trimLeft(9)
    memory = []char
    j=0; for j < cvt.length {
        c = cvt.charAt(j)
        if c == ')' {
            break
        }
        arg = new variable
        arg.name = "arg_"+intToStr(len(nf.args))
        for j < cvt.length {
            c = cvt.charAt(j)
            if c == ',' || c == ')' {
                break
            }
            memory[len(memory)] = c
            j = j + 1
        }
        arg.type = arrToStr(memory)
        clear(memory)
        nf.args[len(nf.args)] = arg
        if c == ')' {
            break
        }
        j = j + 1
    }
    j = j + 1
    for j < cvt.length {
        c = cvt.charAt(j)
        memory[len(memory)] = c
        j = j + 1
    }
    nf.returns = new variable
    nf.returns.name = "_return"
    nf.returns.type = arrToStr(memory)
    return nf
}

searchFunc(name cpstring, elems Elems*, inclCurr bool) func* {
//     recorder = timer.record("searchFunc")
    ogName = name
    if name == "noCheck" {
        fn = new func
        fn.name = "noCheck"
        return fn
    }
    n = string(name)
    if hasStructSep(&n) {
        fnName = splitStructSepAfter(n)
        if n.charAt(n.length-1-fnName.length) == '.' {
            n.trimRight(fnName.length + 1)
        } else {
            n.trimRight(fnName.length + 2)
        }
        name = n.str()
        v = searchVar(name, elems)
        if v == null {
            return null
        }
        s = searchStruct(v.type, elems)
        if s == null {
            return null
        }
        memb = searchStructMemb(fnName.str(), s, elems)
        if memb == null {
            return null
        }
        name = fnName.content
        name = memb.from+"__"+name

    }
    
    fns = elems.fns
    i=0; for i < len(fns) {
        fn = fns[i]
        if fn.name == name {
            fn.used = true
            return fn
        }
        i = i + 1
    }

    if inclCurr == true && currentFn != null {
        if currentFn.name == name {
            currentFn.used = true
            return currentFn
        }
    }

    v = searchVar(ogName, elems)
    if v == null {
        return null
    }
    nf = new func
    nf.name = ogName
    cvt = string(v.type)
    if cvt.hasPrefix("function(") == 0 {
        return null
    }
    pfn = parseFnType(cvt)
    nf.returns = pfn.returns
    nf.args = pfn.args
    return nf
}

searchFuncByToken(t Tok*, elems Elems*) func* {
    if t.bahRef != null {
        return t.bahRef
    }
    fnName = splitStringBefore(string(t.cont), "(")
    return searchFunc(fnName, elems, true)
}

#define RCPavailable() bool

declareStructMethods(v variable*, s cStruct*, elems Elems*) cpstring {
    code = ""
    members = s.members
    typec = string(v.type)
    sep = "."
    amp = "&"
    if typec.count("*") {
        sep = "->"
        amp = ""
    }
    i=0; for i < len(members), i++ {
        m = members[i]
        cmpt = string(m.type)
        if m.def != "" {
            if m.def != "false" && m.def != "0" && m.def != "null" {
                code = code + v.name + sep + m.name + " = " + m.def + ";\n"
            }
            continue
        }
        if cmpt.hasPrefix("[]") == 1 {
            cmpt.trimLeft(2)
            cmptstr = cmpt.str()
            elemCType = getCType(cmptstr, elems)
            elemCTypeStr = elemCType.str()
            code = code + v.name + sep + m.name + " = memoryAlloc(sizeof(array("+elemCTypeStr+")));
            "+v.name+sep+m.name+"->length = 0;
            "+v.name+sep+m.name+"->elemSize = sizeof("+elemCTypeStr+");
            "
            continue
        }
        if cmpt.hasPrefix("map:") == 1 {
            cmpt.trimLeft(4)
            code += v.name + sep + m.name + " = mapWrapper();\n"
            continue
        }
        if cmpt.hasPrefix("chan:") == 1 {
            cmpt.trimLeft(5)
            code += v.name + sep + m.name + " = channel();\n"
        }
    }

    if s.isBinding == false {
        found = 0
        i=0; for i < len(s.methods), i++ {
            m = s.methods[i]
            if m.name == "_init" {
                code += s.name+"__"+m.name+"("+amp+v.name+");\n"
                found++
            } else if m.name == "_end" {
                if sep == "->" {
                    code += "memoryOnEnd("+v.name+", "+s.name+"__"+m.name+");\n"
                }
                found++
            }
            if found == 2 {
                break
            }
        }
    }

    return code
}

NB_COMP_VAR = 0

genCompilerVar() cpstring {
    name = "____BAH_COMPILER_VAR_"+intToStr(NB_COMP_VAR)
    NB_COMP_VAR = NB_COMP_VAR + 1
    return name
}

varInArr(v variable*, arr []variable*) bool {
    if arr == null {
        return false
    }
    j=0; for j < len(arr) {
        ev = arr[j]
        if ev.name == v.name {
            return true
        }
        j = j + 1
    }
    return false
}

pathToVarName(p cpstring) cpstring {
    a = strToArr(p)
    i=0; for i < len(a), i++ {
        c int = a[i]
        c -= <int>'a'
        if c < 0 {
            c = 0 - c
        }
        c = c % (<int>'z' - <int>'a')
        c += <int>'a'
        a[i] = <char>c
    }
    return arrToStr(a)
}

#define strLitteralToBahStr(s cpstring) cpstring

makeInit() {
    name = "__BAH_init"
    if isObject == true {
        name += pathToVarName(compilerState.currentFile)
    }

    evals = ""
    evalsTMPDecl = "volatile struct __eval_binding __tmp__evals_bindings["+intToStr(len(compilerState.evals))+"] = {"
    i=0; for i < len(compilerState.evals), i++ {
        e = compilerState.evals[i]
        evalsTMPDecl += "{
            .name = "+strLitteralToBahStr("\""+e+"\"")+",
            .evalFn = __Bah_eval_"+e+"
        }"
        if i+1 != len(compilerState.evals) {
            evalsTMPDecl += ",\n"
        } else {
            evalsTMPDecl += "};"
        }
    }

    if len(compilerState.evals) != 0 {
        evals = "__evals_bindings = __tmp__evals_bindings; __evals_length = "+intToStr(len(compilerState.evals))+";"
    } else {
        evalsTMPDecl = ""
    }

    OUTPUT += rope("
    "+evalsTMPDecl+"
    void __attribute__((optimize(\"O0\"))) "+name+"() {
        ") + INIT + rope("
        "+evals+"
    };
    ")
}

checkedNull(v cpstring, elems Elems*) bool {
    for elems != null, elems = elems.parent {
        i=0; for i < len(elems.branchChecks), i++ {
            bc = elems.branchChecks[i]
            if bc.v == null {
                continue
            }
            if bc.v.name == v {
                return bc.checkNull
            }
        }
        i=0; for i < len(currChecks), i++ {
            bc = currChecks[i]
            if bc.v == null {
                continue
            }
            if bc.v.name == v {
                return bc.checkNull
            }
        }
    }
    return false
}

checkedNotNull(v cpstring, elems Elems*) bool {
    for elems != null, elems = elems.parent {
        i=0; for i < len(elems.branchChecks), i++ {
            bc = elems.branchChecks[i]
            if bc.v == null {
                continue
            }
            if bc.v.name == v {
                return bc.checkNull == false
            }
        }
        i=0; for i < len(currChecks), i++ {
            bc = currChecks[i]
            if bc.v == null {
                continue
            }
            if bc.v.name == v {
                return bc.checkNull == false
            }
        }
    }
    return false
}

canChangeNullState(v variable*, elems Elems*) bool {
    if v.declScope == elems {
        return true
    }
    return checkedNull(v.name, elems)
}

removeCast(s cpstring) cpstring {
    i = len(s)-1; for i >= 0, i-- {
        if s[i] == ')' {
            s = s[i+1:]
            break
        }
    }
    return s
}