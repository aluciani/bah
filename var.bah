#include "iostream.bah"
#include "string.bah"



#include "./errors.bah"
#include "./lexer.bah"
#include "./type.bah"
#include "./fns.bah"

searchVar(name cpstring, elems Elems*) variable* {
    ogName = name
    n = string(name)
    n.replace("&", "")
    n.replace("*", "")
    name = n.content
    if hasStructSep(n) {
        rn = splitStructSepBefore(n)
        name = rn.content
        n.trimLeft(rn.length)
        if n.hasPrefix(".") {
            n.trimLeft(1)
        } else {
            n.trimLeft(2)
        }
        membs = n.content
        v = searchVar(name, elems)
        s = searchStruct(v.type, elems)
        memb = searchStructMemb(membs, s, elems)
        if memb == null {
            return null
        }
        v = new variable
        v.name = memb.name
        v.type = memb.type
        v.name = ogName

        r = v.type
        tcc = string(ogName)
        if tcc.count("&") {
            r += "*"
        }
        nbUnaries = tcc.count("*")
        if nbUnaries {
            ct = string(r)
            pointerLevel = ct.count("*")
            if pointerLevel < nbUnaries {
                throwErr(null, "Cannot use '*' on "+v.name+" because it is not pointer.")
            }
            ct.trimRight(nbUnaries)
            r = ct.str()
        }
        v.type = r
        v.name = ogName

        return v
    }

    i=0; for i < len(elems.vars) {
        v = elems.vars[i]
        if v.name == name {

            nv = new variable
            nv.type = v.type
            nv.name = v.name
            r = nv.type
            tcc = string(ogName)
            if tcc.count("&") {
                r += "*"
            }

            nbUnaries = tcc.count("*")
            if nbUnaries {
                ct = string(r)
                pointerLevel = ct.count("*")
                if pointerLevel < nbUnaries {
                    throwErr(null, "Cannot use '*' on "+v.name+" because it is not pointer.")
                }
                ct.trimRight(nbUnaries)
                r = ct.str()
            }
            nv.type = r
            nv.name = ogName

            return nv
        }
        i++
    }

    return null

}

setCType(v variable*, elems Elems*) cpstring {
        tp = getCType(v.type, elems)
        t = tp.str()
        t = t + " " + v.name
        return t
}

getTypeFromToken(t Tok*, strict bool, elems Elems*) cpstring {
    if strlen(t.bahType) > 0 {
        r = t.bahType
        return r
    }
    if t.type == TOKEN_TYPE_VAR {
        v = searchVar(t.cont, elems)
        if v == null {
            if strict {
                throwErr(t, "Unknown var {TOKEN}.")
            } else {
                return ""
            }
        }
        if strict {
            if strlen(v.type) == 0 {
                throwErr(t, "Cannot use {TOKEN} because it does not have any type.")
            }
        }
        r = v.type        
        return r
    }

    if t.type == TOKEN_TYPE_FLOAT {
        return "float"
    }
    if t.type == TOKEN_TYPE_INT {
        return "int"
    }
    if t.type == TOKEN_TYPE_STR {
        return "cpstring"
    }
    if t.type == TOKEN_TYPE_CHAR {
        return "char"
    }
    if t.type == TOKEN_TYPE_BOOL {
        return "bool"
    }
    
    throwErr(t, "Cannot use {TOKEN} as value.")

}



searchFunc(name cpstring, elems Elems*) func* {
    if name == "noCheck" {
        fn = new func
        fn.name = "noCheck"
        return fn
    }
    n = string(name)
    if hasStructSep(n) {
        fnName = splitStructSepAfter(n)
        n.trimRight(fnName.length)
        c = n.charAt(n.length-1)
        if c == '.' {
            n.trimRight(1)
        } else {
            n.trimRight(2)
        }
        v = searchVar(n, elems)
        s = searchStruct(v.type, elems)
        name = fnName.content
        name = s.name+"__"+name

    }
    
    fns = elems.fns
    i=0; for i < len(fns) {
        fn = fns[i]
        if fn.name == name {
            return fn
        }
        i++
    }
    return null
}
